<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>gitk - RDoc Documentation</title>

<link href="../../fonts.css" rel="stylesheet">
<link href="../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script src="../../js/jquery.js"></script>
<script src="../../js/navigation.js"></script>
<script src="../../js/search_index.js"></script>
<script src="../../js/search.js"></script>
<script src="../../js/searcher.js"></script>
<script src="../../js/darkfish.js"></script>


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../table_of_contents.html#pages">Pages</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    <div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
  
    <li><a href="../../Gemfile.html">Gemfile</a>
  
    <li><a href="../../Gemfile_lock.html">Gemfile.lock</a>
  
    <li><a href="../../README_md.html">README</a>
  
    <li><a href="../../Rakefile.html">Rakefile</a>
  
    <li><a href="../../app/assets/javascripts/application_js.html">application.js</a>
  
    <li><a href="../../app/assets/javascripts/pages_js_coffee.html">pages.js.coffee</a>
  
    <li><a href="../../app/assets/javascripts/pins_js_coffee.html">pins.js.coffee</a>
  
    <li><a href="../../app/assets/stylesheets/application_css.html">application.css</a>
  
    <li><a href="../../app/assets/stylesheets/bootstrap_and_customization_css_scss.html">bootstrap_and_customization.css.scss</a>
  
    <li><a href="../../app/assets/stylesheets/pages_css_scss.html">pages.css.scss</a>
  
    <li><a href="../../app/assets/stylesheets/pins_css_scss.html">pins.css.scss</a>
  
    <li><a href="../../config_ru.html">config.ru</a>
  
    <li><a href="../../git/COPYING.html">COPYING</a>
  
    <li><a href="../../git/Documentation/CodingGuidelines.html">CodingGuidelines</a>
  
    <li><a href="../../git/Documentation/Makefile.html">Makefile</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_1_txt.html">1.5.0.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_2_txt.html">1.5.0.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_3_txt.html">1.5.0.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_4_txt.html">1.5.0.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_5_txt.html">1.5.0.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_6_txt.html">1.5.0.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_7_txt.html">1.5.0.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_0_txt.html">1.5.0</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_1_1_txt.html">1.5.1.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_1_2_txt.html">1.5.1.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_1_3_txt.html">1.5.1.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_1_4_txt.html">1.5.1.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_1_5_txt.html">1.5.1.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_1_6_txt.html">1.5.1.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_1_txt.html">1.5.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_2_1_txt.html">1.5.2.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_2_2_txt.html">1.5.2.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_2_3_txt.html">1.5.2.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_2_4_txt.html">1.5.2.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_2_5_txt.html">1.5.2.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_2_txt.html">1.5.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_1_txt.html">1.5.3.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_2_txt.html">1.5.3.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_3_txt.html">1.5.3.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_4_txt.html">1.5.3.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_5_txt.html">1.5.3.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_6_txt.html">1.5.3.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_7_txt.html">1.5.3.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_8_txt.html">1.5.3.8</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_3_txt.html">1.5.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_1_txt.html">1.5.4.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_2_txt.html">1.5.4.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_3_txt.html">1.5.4.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_4_txt.html">1.5.4.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_5_txt.html">1.5.4.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_6_txt.html">1.5.4.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_7_txt.html">1.5.4.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_4_txt.html">1.5.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_5_1_txt.html">1.5.5.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_5_2_txt.html">1.5.5.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_5_3_txt.html">1.5.5.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_5_4_txt.html">1.5.5.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_5_5_txt.html">1.5.5.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_5_6_txt.html">1.5.5.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_5_txt.html">1.5.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_6_1_txt.html">1.5.6.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_6_2_txt.html">1.5.6.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_6_3_txt.html">1.5.6.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_6_4_txt.html">1.5.6.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_6_5_txt.html">1.5.6.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_6_6_txt.html">1.5.6.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_5_6_txt.html">1.5.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_0_1_txt.html">1.6.0.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_0_2_txt.html">1.6.0.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_0_3_txt.html">1.6.0.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_0_4_txt.html">1.6.0.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_0_5_txt.html">1.6.0.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_0_6_txt.html">1.6.0.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_0_txt.html">1.6.0</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_1_1_txt.html">1.6.1.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_1_2_txt.html">1.6.1.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_1_3_txt.html">1.6.1.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_1_4_txt.html">1.6.1.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_1_txt.html">1.6.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_2_1_txt.html">1.6.2.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_2_2_txt.html">1.6.2.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_2_3_txt.html">1.6.2.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_2_4_txt.html">1.6.2.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_2_5_txt.html">1.6.2.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_2_txt.html">1.6.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_3_1_txt.html">1.6.3.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_3_2_txt.html">1.6.3.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_3_3_txt.html">1.6.3.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_3_4_txt.html">1.6.3.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_3_txt.html">1.6.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_4_1_txt.html">1.6.4.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_4_2_txt.html">1.6.4.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_4_3_txt.html">1.6.4.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_4_4_txt.html">1.6.4.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_4_5_txt.html">1.6.4.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_4_txt.html">1.6.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_1_txt.html">1.6.5.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_2_txt.html">1.6.5.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_3_txt.html">1.6.5.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_4_txt.html">1.6.5.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_5_txt.html">1.6.5.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_6_txt.html">1.6.5.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_7_txt.html">1.6.5.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_8_txt.html">1.6.5.8</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_9_txt.html">1.6.5.9</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_5_txt.html">1.6.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_6_1_txt.html">1.6.6.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_6_2_txt.html">1.6.6.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_6_3_txt.html">1.6.6.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_6_6_txt.html">1.6.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_1_txt.html">1.7.0.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_2_txt.html">1.7.0.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_3_txt.html">1.7.0.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_4_txt.html">1.7.0.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_5_txt.html">1.7.0.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_6_txt.html">1.7.0.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_7_txt.html">1.7.0.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_8_txt.html">1.7.0.8</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_9_txt.html">1.7.0.9</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_0_txt.html">1.7.0</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_1_1_txt.html">1.7.1.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_1_2_txt.html">1.7.1.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_1_3_txt.html">1.7.1.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_1_4_txt.html">1.7.1.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_1_txt.html">1.7.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_10_1_txt.html">1.7.10.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_10_2_txt.html">1.7.10.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_10_3_txt.html">1.7.10.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_10_4_txt.html">1.7.10.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_10_5_txt.html">1.7.10.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_10_txt.html">1.7.10</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_1_txt.html">1.7.11.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_2_txt.html">1.7.11.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_3_txt.html">1.7.11.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_4_txt.html">1.7.11.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_5_txt.html">1.7.11.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_6_txt.html">1.7.11.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_7_txt.html">1.7.11.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_11_txt.html">1.7.11</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_12_1_txt.html">1.7.12.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_12_2_txt.html">1.7.12.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_12_3_txt.html">1.7.12.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_12_4_txt.html">1.7.12.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_12_txt.html">1.7.12</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_2_1_txt.html">1.7.2.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_2_2_txt.html">1.7.2.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_2_3_txt.html">1.7.2.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_2_4_txt.html">1.7.2.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_2_5_txt.html">1.7.2.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_2_txt.html">1.7.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_3_1_txt.html">1.7.3.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_3_2_txt.html">1.7.3.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_3_3_txt.html">1.7.3.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_3_4_txt.html">1.7.3.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_3_5_txt.html">1.7.3.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_3_txt.html">1.7.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_4_1_txt.html">1.7.4.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_4_2_txt.html">1.7.4.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_4_3_txt.html">1.7.4.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_4_4_txt.html">1.7.4.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_4_5_txt.html">1.7.4.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_4_txt.html">1.7.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_5_1_txt.html">1.7.5.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_5_2_txt.html">1.7.5.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_5_3_txt.html">1.7.5.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_5_4_txt.html">1.7.5.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_5_txt.html">1.7.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_6_1_txt.html">1.7.6.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_6_2_txt.html">1.7.6.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_6_3_txt.html">1.7.6.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_6_4_txt.html">1.7.6.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_6_5_txt.html">1.7.6.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_6_6_txt.html">1.7.6.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_6_txt.html">1.7.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_1_txt.html">1.7.7.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_2_txt.html">1.7.7.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_3_txt.html">1.7.7.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_4_txt.html">1.7.7.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_5_txt.html">1.7.7.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_6_txt.html">1.7.7.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_7_txt.html">1.7.7.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_7_txt.html">1.7.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_8_1_txt.html">1.7.8.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_8_2_txt.html">1.7.8.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_8_3_txt.html">1.7.8.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_8_4_txt.html">1.7.8.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_8_5_txt.html">1.7.8.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_8_6_txt.html">1.7.8.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_8_txt.html">1.7.8</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_1_txt.html">1.7.9.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_2_txt.html">1.7.9.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_3_txt.html">1.7.9.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_4_txt.html">1.7.9.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_5_txt.html">1.7.9.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_6_txt.html">1.7.9.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_7_txt.html">1.7.9.7</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_7_9_txt.html">1.7.9</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_0_1_txt.html">1.8.0.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_0_2_txt.html">1.8.0.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_0_3_txt.html">1.8.0.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_0_txt.html">1.8.0</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_1_1_txt.html">1.8.1.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_1_2_txt.html">1.8.1.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_1_3_txt.html">1.8.1.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_1_4_txt.html">1.8.1.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_1_5_txt.html">1.8.1.5</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_1_6_txt.html">1.8.1.6</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_1_txt.html">1.8.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_2_1_txt.html">1.8.2.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_2_2_txt.html">1.8.2.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_2_3_txt.html">1.8.2.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_2_txt.html">1.8.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_3_1_txt.html">1.8.3.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_3_2_txt.html">1.8.3.2</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_3_3_txt.html">1.8.3.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_3_4_txt.html">1.8.3.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_3_txt.html">1.8.3</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_4_1_txt.html">1.8.4.1</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_4_txt.html">1.8.4</a>
  
    <li><a href="../../git/Documentation/RelNotes/1_8_5_txt.html">1.8.5</a>
  
    <li><a href="../../git/Documentation/SubmittingPatches.html">SubmittingPatches</a>
  
    <li><a href="../../git/Documentation/asciidoc_conf.html">asciidoc.conf</a>
  
    <li><a href="../../git/Documentation/blame-options_txt.html">blame-options</a>
  
    <li><a href="../../git/Documentation/build-docdep_perl.html">build-docdep.perl</a>
  
    <li><a href="../../git/Documentation/cat-texi_perl.html">cat-texi.perl</a>
  
    <li><a href="../../git/Documentation/cmd-list_perl.html">cmd-list.perl</a>
  
    <li><a href="../../git/Documentation/config_txt.html">config</a>
  
    <li><a href="../../git/Documentation/date-formats_txt.html">date-formats</a>
  
    <li><a href="../../git/Documentation/diff-config_txt.html">diff-config</a>
  
    <li><a href="../../git/Documentation/diff-format_txt.html">diff-format</a>
  
    <li><a href="../../git/Documentation/diff-generate-patch_txt.html">diff-generate-patch</a>
  
    <li><a href="../../git/Documentation/diff-options_txt.html">diff-options</a>
  
    <li><a href="../../git/Documentation/docbook-xsl_css.html">docbook-xsl.css</a>
  
    <li><a href="../../git/Documentation/docbook_xsl.html">docbook.xsl</a>
  
    <li><a href="../../git/Documentation/everyday_txt.html">everyday</a>
  
    <li><a href="../../git/Documentation/fetch-options_txt.html">fetch-options</a>
  
    <li><a href="../../git/Documentation/fix-texi_perl.html">fix-texi.perl</a>
  
    <li><a href="../../git/Documentation/git-add_txt.html">git-add</a>
  
    <li><a href="../../git/Documentation/git-am_txt.html">git-am</a>
  
    <li><a href="../../git/Documentation/git-annotate_txt.html">git-annotate</a>
  
    <li><a href="../../git/Documentation/git-apply_txt.html">git-apply</a>
  
    <li><a href="../../git/Documentation/git-archimport_txt.html">git-archimport</a>
  
    <li><a href="../../git/Documentation/git-archive_txt.html">git-archive</a>
  
    <li><a href="../../git/Documentation/git-bisect-lk2009_txt.html">git-bisect-lk2009</a>
  
    <li><a href="../../git/Documentation/git-bisect_txt.html">git-bisect</a>
  
    <li><a href="../../git/Documentation/git-blame_txt.html">git-blame</a>
  
    <li><a href="../../git/Documentation/git-branch_txt.html">git-branch</a>
  
    <li><a href="../../git/Documentation/git-bundle_txt.html">git-bundle</a>
  
    <li><a href="../../git/Documentation/git-cat-file_txt.html">git-cat-file</a>
  
    <li><a href="../../git/Documentation/git-check-attr_txt.html">git-check-attr</a>
  
    <li><a href="../../git/Documentation/git-check-ignore_txt.html">git-check-ignore</a>
  
    <li><a href="../../git/Documentation/git-check-mailmap_txt.html">git-check-mailmap</a>
  
    <li><a href="../../git/Documentation/git-check-ref-format_txt.html">git-check-ref-format</a>
  
    <li><a href="../../git/Documentation/git-checkout-index_txt.html">git-checkout-index</a>
  
    <li><a href="../../git/Documentation/git-checkout_txt.html">git-checkout</a>
  
    <li><a href="../../git/Documentation/git-cherry-pick_txt.html">git-cherry-pick</a>
  
    <li><a href="../../git/Documentation/git-cherry_txt.html">git-cherry</a>
  
    <li><a href="../../git/Documentation/git-citool_txt.html">git-citool</a>
  
    <li><a href="../../git/Documentation/git-clean_txt.html">git-clean</a>
  
    <li><a href="../../git/Documentation/git-clone_txt.html">git-clone</a>
  
    <li><a href="../../git/Documentation/git-column_txt.html">git-column</a>
  
    <li><a href="../../git/Documentation/git-commit-tree_txt.html">git-commit-tree</a>
  
    <li><a href="../../git/Documentation/git-commit_txt.html">git-commit</a>
  
    <li><a href="../../git/Documentation/git-config_txt.html">git-config</a>
  
    <li><a href="../../git/Documentation/git-count-objects_txt.html">git-count-objects</a>
  
    <li><a href="../../git/Documentation/git-credential-cache--daemon_txt.html">git-credential-cache--daemon</a>
  
    <li><a href="../../git/Documentation/git-credential-cache_txt.html">git-credential-cache</a>
  
    <li><a href="../../git/Documentation/git-credential-store_txt.html">git-credential-store</a>
  
    <li><a href="../../git/Documentation/git-credential_txt.html">git-credential</a>
  
    <li><a href="../../git/Documentation/git-cvsexportcommit_txt.html">git-cvsexportcommit</a>
  
    <li><a href="../../git/Documentation/git-cvsimport_txt.html">git-cvsimport</a>
  
    <li><a href="../../git/Documentation/git-cvsserver_txt.html">git-cvsserver</a>
  
    <li><a href="../../git/Documentation/git-daemon_txt.html">git-daemon</a>
  
    <li><a href="../../git/Documentation/git-describe_txt.html">git-describe</a>
  
    <li><a href="../../git/Documentation/git-diff-files_txt.html">git-diff-files</a>
  
    <li><a href="../../git/Documentation/git-diff-index_txt.html">git-diff-index</a>
  
    <li><a href="../../git/Documentation/git-diff-tree_txt.html">git-diff-tree</a>
  
    <li><a href="../../git/Documentation/git-diff_txt.html">git-diff</a>
  
    <li><a href="../../git/Documentation/git-difftool_txt.html">git-difftool</a>
  
    <li><a href="../../git/Documentation/git-fast-export_txt.html">git-fast-export</a>
  
    <li><a href="../../git/Documentation/git-fast-import_txt.html">git-fast-import</a>
  
    <li><a href="../../git/Documentation/git-fetch-pack_txt.html">git-fetch-pack</a>
  
    <li><a href="../../git/Documentation/git-fetch_txt.html">git-fetch</a>
  
    <li><a href="../../git/Documentation/git-filter-branch_txt.html">git-filter-branch</a>
  
    <li><a href="../../git/Documentation/git-fmt-merge-msg_txt.html">git-fmt-merge-msg</a>
  
    <li><a href="../../git/Documentation/git-for-each-ref_txt.html">git-for-each-ref</a>
  
    <li><a href="../../git/Documentation/git-format-patch_txt.html">git-format-patch</a>
  
    <li><a href="../../git/Documentation/git-fsck-objects_txt.html">git-fsck-objects</a>
  
    <li><a href="../../git/Documentation/git-fsck_txt.html">git-fsck</a>
  
    <li><a href="../../git/Documentation/git-gc_txt.html">git-gc</a>
  
    <li><a href="../../git/Documentation/git-get-tar-commit-id_txt.html">git-get-tar-commit-id</a>
  
    <li><a href="../../git/Documentation/git-grep_txt.html">git-grep</a>
  
    <li><a href="../../git/Documentation/git-gui_txt.html">git-gui</a>
  
    <li><a href="../../git/Documentation/git-hash-object_txt.html">git-hash-object</a>
  
    <li><a href="../../git/Documentation/git-help_txt.html">git-help</a>
  
    <li><a href="../../git/Documentation/git-http-backend_txt.html">git-http-backend</a>
  
    <li><a href="../../git/Documentation/git-http-fetch_txt.html">git-http-fetch</a>
  
    <li><a href="../../git/Documentation/git-http-push_txt.html">git-http-push</a>
  
    <li><a href="../../git/Documentation/git-imap-send_txt.html">git-imap-send</a>
  
    <li><a href="../../git/Documentation/git-index-pack_txt.html">git-index-pack</a>
  
    <li><a href="../../git/Documentation/git-init-db_txt.html">git-init-db</a>
  
    <li><a href="../../git/Documentation/git-init_txt.html">git-init</a>
  
    <li><a href="../../git/Documentation/git-instaweb_txt.html">git-instaweb</a>
  
    <li><a href="../../git/Documentation/git-log_txt.html">git-log</a>
  
    <li><a href="../../git/Documentation/git-lost-found_txt.html">git-lost-found</a>
  
    <li><a href="../../git/Documentation/git-ls-files_txt.html">git-ls-files</a>
  
    <li><a href="../../git/Documentation/git-ls-remote_txt.html">git-ls-remote</a>
  
    <li><a href="../../git/Documentation/git-ls-tree_txt.html">git-ls-tree</a>
  
    <li><a href="../../git/Documentation/git-mailinfo_txt.html">git-mailinfo</a>
  
    <li><a href="../../git/Documentation/git-mailsplit_txt.html">git-mailsplit</a>
  
    <li><a href="../../git/Documentation/git-merge-base_txt.html">git-merge-base</a>
  
    <li><a href="../../git/Documentation/git-merge-file_txt.html">git-merge-file</a>
  
    <li><a href="../../git/Documentation/git-merge-index_txt.html">git-merge-index</a>
  
    <li><a href="../../git/Documentation/git-merge-one-file_txt.html">git-merge-one-file</a>
  
    <li><a href="../../git/Documentation/git-merge-tree_txt.html">git-merge-tree</a>
  
    <li><a href="../../git/Documentation/git-merge_txt.html">git-merge</a>
  
    <li><a href="../../git/Documentation/git-mergetool--lib_txt.html">git-mergetool--lib</a>
  
    <li><a href="../../git/Documentation/git-mergetool_txt.html">git-mergetool</a>
  
    <li><a href="../../git/Documentation/git-mktag_txt.html">git-mktag</a>
  
    <li><a href="../../git/Documentation/git-mktree_txt.html">git-mktree</a>
  
    <li><a href="../../git/Documentation/git-mv_txt.html">git-mv</a>
  
    <li><a href="../../git/Documentation/git-name-rev_txt.html">git-name-rev</a>
  
    <li><a href="../../git/Documentation/git-notes_txt.html">git-notes</a>
  
    <li><a href="../../git/Documentation/git-p4_txt.html">git-p4</a>
  
    <li><a href="../../git/Documentation/git-pack-objects_txt.html">git-pack-objects</a>
  
    <li><a href="../../git/Documentation/git-pack-redundant_txt.html">git-pack-redundant</a>
  
    <li><a href="../../git/Documentation/git-pack-refs_txt.html">git-pack-refs</a>
  
    <li><a href="../../git/Documentation/git-parse-remote_txt.html">git-parse-remote</a>
  
    <li><a href="../../git/Documentation/git-patch-id_txt.html">git-patch-id</a>
  
    <li><a href="../../git/Documentation/git-peek-remote_txt.html">git-peek-remote</a>
  
    <li><a href="../../git/Documentation/git-prune-packed_txt.html">git-prune-packed</a>
  
    <li><a href="../../git/Documentation/git-prune_txt.html">git-prune</a>
  
    <li><a href="../../git/Documentation/git-pull_txt.html">git-pull</a>
  
    <li><a href="../../git/Documentation/git-push_txt.html">git-push</a>
  
    <li><a href="../../git/Documentation/git-quiltimport_txt.html">git-quiltimport</a>
  
    <li><a href="../../git/Documentation/git-read-tree_txt.html">git-read-tree</a>
  
    <li><a href="../../git/Documentation/git-rebase_txt.html">git-rebase</a>
  
    <li><a href="../../git/Documentation/git-receive-pack_txt.html">git-receive-pack</a>
  
    <li><a href="../../git/Documentation/git-reflog_txt.html">git-reflog</a>
  
    <li><a href="../../git/Documentation/git-relink_txt.html">git-relink</a>
  
    <li><a href="../../git/Documentation/git-remote-ext_txt.html">git-remote-ext</a>
  
    <li><a href="../../git/Documentation/git-remote-fd_txt.html">git-remote-fd</a>
  
    <li><a href="../../git/Documentation/git-remote-helpers_txto.html">git-remote-helpers.txto</a>
  
    <li><a href="../../git/Documentation/git-remote-testgit_txt.html">git-remote-testgit</a>
  
    <li><a href="../../git/Documentation/git-remote_txt.html">git-remote</a>
  
    <li><a href="../../git/Documentation/git-repack_txt.html">git-repack</a>
  
    <li><a href="../../git/Documentation/git-replace_txt.html">git-replace</a>
  
    <li><a href="../../git/Documentation/git-repo-config_txt.html">git-repo-config</a>
  
    <li><a href="../../git/Documentation/git-request-pull_txt.html">git-request-pull</a>
  
    <li><a href="../../git/Documentation/git-rerere_txt.html">git-rerere</a>
  
    <li><a href="../../git/Documentation/git-reset_txt.html">git-reset</a>
  
    <li><a href="../../git/Documentation/git-rev-list_txt.html">git-rev-list</a>
  
    <li><a href="../../git/Documentation/git-rev-parse_txt.html">git-rev-parse</a>
  
    <li><a href="../../git/Documentation/git-revert_txt.html">git-revert</a>
  
    <li><a href="../../git/Documentation/git-rm_txt.html">git-rm</a>
  
    <li><a href="../../git/Documentation/git-send-email_txt.html">git-send-email</a>
  
    <li><a href="../../git/Documentation/git-send-pack_txt.html">git-send-pack</a>
  
    <li><a href="../../git/Documentation/git-sh-i18n--envsubst_txt.html">git-sh-i18n--envsubst</a>
  
    <li><a href="../../git/Documentation/git-sh-i18n_txt.html">git-sh-i18n</a>
  
    <li><a href="../../git/Documentation/git-sh-setup_txt.html">git-sh-setup</a>
  
    <li><a href="../../git/Documentation/git-shell_txt.html">git-shell</a>
  
    <li><a href="../../git/Documentation/git-shortlog_txt.html">git-shortlog</a>
  
    <li><a href="../../git/Documentation/git-show-branch_txt.html">git-show-branch</a>
  
    <li><a href="../../git/Documentation/git-show-index_txt.html">git-show-index</a>
  
    <li><a href="../../git/Documentation/git-show-ref_txt.html">git-show-ref</a>
  
    <li><a href="../../git/Documentation/git-show_txt.html">git-show</a>
  
    <li><a href="../../git/Documentation/git-stage_txt.html">git-stage</a>
  
    <li><a href="../../git/Documentation/git-stash_txt.html">git-stash</a>
  
    <li><a href="../../git/Documentation/git-status_txt.html">git-status</a>
  
    <li><a href="../../git/Documentation/git-stripspace_txt.html">git-stripspace</a>
  
    <li><a href="../../git/Documentation/git-submodule_txt.html">git-submodule</a>
  
    <li><a href="../../git/Documentation/git-svn_txt.html">git-svn</a>
  
    <li><a href="../../git/Documentation/git-symbolic-ref_txt.html">git-symbolic-ref</a>
  
    <li><a href="../../git/Documentation/git-tag_txt.html">git-tag</a>
  
    <li><a href="../../git/Documentation/git-tar-tree_txt.html">git-tar-tree</a>
  
    <li><a href="../../git/Documentation/git-tools_txt.html">git-tools</a>
  
    <li><a href="../../git/Documentation/git-unpack-file_txt.html">git-unpack-file</a>
  
    <li><a href="../../git/Documentation/git-unpack-objects_txt.html">git-unpack-objects</a>
  
    <li><a href="../../git/Documentation/git-update-index_txt.html">git-update-index</a>
  
    <li><a href="../../git/Documentation/git-update-ref_txt.html">git-update-ref</a>
  
    <li><a href="../../git/Documentation/git-update-server-info_txt.html">git-update-server-info</a>
  
    <li><a href="../../git/Documentation/git-upload-archive_txt.html">git-upload-archive</a>
  
    <li><a href="../../git/Documentation/git-upload-pack_txt.html">git-upload-pack</a>
  
    <li><a href="../../git/Documentation/git-var_txt.html">git-var</a>
  
    <li><a href="../../git/Documentation/git-verify-pack_txt.html">git-verify-pack</a>
  
    <li><a href="../../git/Documentation/git-verify-tag_txt.html">git-verify-tag</a>
  
    <li><a href="../../git/Documentation/git-web--browse_txt.html">git-web--browse</a>
  
    <li><a href="../../git/Documentation/git-whatchanged_txt.html">git-whatchanged</a>
  
    <li><a href="../../git/Documentation/git-write-tree_txt.html">git-write-tree</a>
  
    <li><a href="../../git/Documentation/git_txt.html">git</a>
  
    <li><a href="../../git/Documentation/gitattributes_txt.html">gitattributes</a>
  
    <li><a href="../../git/Documentation/gitcli_txt.html">gitcli</a>
  
    <li><a href="../../git/Documentation/gitcore-tutorial_txt.html">gitcore-tutorial</a>
  
    <li><a href="../../git/Documentation/gitcredentials_txt.html">gitcredentials</a>
  
    <li><a href="../../git/Documentation/gitcvs-migration_txt.html">gitcvs-migration</a>
  
    <li><a href="../../git/Documentation/gitdiffcore_txt.html">gitdiffcore</a>
  
    <li><a href="../../git/Documentation/gitglossary_txt.html">gitglossary</a>
  
    <li><a href="../../git/Documentation/githooks_txt.html">githooks</a>
  
    <li><a href="../../git/Documentation/gitignore_txt.html">gitignore</a>
  
    <li><a href="../../git/Documentation/gitk_txt.html">gitk</a>
  
    <li><a href="../../git/Documentation/gitmodules_txt.html">gitmodules</a>
  
    <li><a href="../../git/Documentation/gitnamespaces_txt.html">gitnamespaces</a>
  
    <li><a href="../../git/Documentation/gitremote-helpers_txt.html">gitremote-helpers</a>
  
    <li><a href="../../git/Documentation/gitrepository-layout_txt.html">gitrepository-layout</a>
  
    <li><a href="../../git/Documentation/gitrevisions_txt.html">gitrevisions</a>
  
    <li><a href="../../git/Documentation/gittutorial-2_txt.html">gittutorial-2</a>
  
    <li><a href="../../git/Documentation/gittutorial_txt.html">gittutorial</a>
  
    <li><a href="../../git/Documentation/gitweb_conf_txt.html">gitweb.conf</a>
  
    <li><a href="../../git/Documentation/gitweb_txt.html">gitweb</a>
  
    <li><a href="../../git/Documentation/gitworkflows_txt.html">gitworkflows</a>
  
    <li><a href="../../git/Documentation/glossary-content_txt.html">glossary-content</a>
  
    <li><a href="../../git/Documentation/howto-index_sh.html">howto-index.sh</a>
  
    <li><a href="../../git/Documentation/howto/maintain-git_txt.html">maintain-git</a>
  
    <li><a href="../../git/Documentation/howto/new-command_txt.html">new-command</a>
  
    <li><a href="../../git/Documentation/howto/rebase-from-internal-branch_txt.html">rebase-from-internal-branch</a>
  
    <li><a href="../../git/Documentation/howto/rebuild-from-update-hook_txt.html">rebuild-from-update-hook</a>
  
    <li><a href="../../git/Documentation/howto/recover-corrupted-blob-object_txt.html">recover-corrupted-blob-object</a>
  
    <li><a href="../../git/Documentation/howto/revert-a-faulty-merge_txt.html">revert-a-faulty-merge</a>
  
    <li><a href="../../git/Documentation/howto/revert-branch-rebase_txt.html">revert-branch-rebase</a>
  
    <li><a href="../../git/Documentation/howto/separating-topic-branches_txt.html">separating-topic-branches</a>
  
    <li><a href="../../git/Documentation/howto/setup-git-server-over-http_txt.html">setup-git-server-over-http</a>
  
    <li><a href="../../git/Documentation/howto/update-hook-example_txt.html">update-hook-example</a>
  
    <li><a href="../../git/Documentation/howto/use-git-daemon_txt.html">use-git-daemon</a>
  
    <li><a href="../../git/Documentation/howto/using-merge-subtree_txt.html">using-merge-subtree</a>
  
    <li><a href="../../git/Documentation/howto/using-signed-tag-in-pull-request_txt.html">using-signed-tag-in-pull-request</a>
  
    <li><a href="../../git/Documentation/i18n_txt.html">i18n</a>
  
    <li><a href="../../git/Documentation/install-doc-quick_sh.html">install-doc-quick.sh</a>
  
    <li><a href="../../git/Documentation/install-webdoc_sh.html">install-webdoc.sh</a>
  
    <li><a href="../../git/Documentation/line-range-format_txt.html">line-range-format</a>
  
    <li><a href="../../git/Documentation/mailmap_txt.html">mailmap</a>
  
    <li><a href="../../git/Documentation/manpage-1_72_xsl.html">manpage-1.72.xsl</a>
  
    <li><a href="../../git/Documentation/manpage-base-url_xsl_in.html">manpage-base-url.xsl.in</a>
  
    <li><a href="../../git/Documentation/manpage-base_xsl.html">manpage-base.xsl</a>
  
    <li><a href="../../git/Documentation/manpage-bold-literal_xsl.html">manpage-bold-literal.xsl</a>
  
    <li><a href="../../git/Documentation/manpage-normal_xsl.html">manpage-normal.xsl</a>
  
    <li><a href="../../git/Documentation/manpage-quote-apos_xsl.html">manpage-quote-apos.xsl</a>
  
    <li><a href="../../git/Documentation/manpage-suppress-sp_xsl.html">manpage-suppress-sp.xsl</a>
  
    <li><a href="../../git/Documentation/merge-config_txt.html">merge-config</a>
  
    <li><a href="../../git/Documentation/merge-options_txt.html">merge-options</a>
  
    <li><a href="../../git/Documentation/merge-strategies_txt.html">merge-strategies</a>
  
    <li><a href="../../git/Documentation/pretty-formats_txt.html">pretty-formats</a>
  
    <li><a href="../../git/Documentation/pretty-options_txt.html">pretty-options</a>
  
    <li><a href="../../git/Documentation/pull-fetch-param_txt.html">pull-fetch-param</a>
  
    <li><a href="../../git/Documentation/rev-list-options_txt.html">rev-list-options</a>
  
    <li><a href="../../git/Documentation/revisions_txt.html">revisions</a>
  
    <li><a href="../../git/Documentation/sequencer_txt.html">sequencer</a>
  
    <li><a href="../../git/Documentation/technical/api-allocation-growing_txt.html">api-allocation-growing</a>
  
    <li><a href="../../git/Documentation/technical/api-argv-array_txt.html">api-argv-array</a>
  
    <li><a href="../../git/Documentation/technical/api-builtin_txt.html">api-builtin</a>
  
    <li><a href="../../git/Documentation/technical/api-config_txt.html">api-config</a>
  
    <li><a href="../../git/Documentation/technical/api-credentials_txt.html">api-credentials</a>
  
    <li><a href="../../git/Documentation/technical/api-decorate_txt.html">api-decorate</a>
  
    <li><a href="../../git/Documentation/technical/api-diff_txt.html">api-diff</a>
  
    <li><a href="../../git/Documentation/technical/api-directory-listing_txt.html">api-directory-listing</a>
  
    <li><a href="../../git/Documentation/technical/api-gitattributes_txt.html">api-gitattributes</a>
  
    <li><a href="../../git/Documentation/technical/api-grep_txt.html">api-grep</a>
  
    <li><a href="../../git/Documentation/technical/api-hash_txt.html">api-hash</a>
  
    <li><a href="../../git/Documentation/technical/api-history-graph_txt.html">api-history-graph</a>
  
    <li><a href="../../git/Documentation/technical/api-in-core-index_txt.html">api-in-core-index</a>
  
    <li><a href="../../git/Documentation/technical/api-index-skel_txt.html">api-index-skel</a>
  
    <li><a href="../../git/Documentation/technical/api-index_sh.html">api-index.sh</a>
  
    <li><a href="../../git/Documentation/technical/api-lockfile_txt.html">api-lockfile</a>
  
    <li><a href="../../git/Documentation/technical/api-merge_txt.html">api-merge</a>
  
    <li><a href="../../git/Documentation/technical/api-object-access_txt.html">api-object-access</a>
  
    <li><a href="../../git/Documentation/technical/api-parse-options_txt.html">api-parse-options</a>
  
    <li><a href="../../git/Documentation/technical/api-quote_txt.html">api-quote</a>
  
    <li><a href="../../git/Documentation/technical/api-ref-iteration_txt.html">api-ref-iteration</a>
  
    <li><a href="../../git/Documentation/technical/api-remote_txt.html">api-remote</a>
  
    <li><a href="../../git/Documentation/technical/api-revision-walking_txt.html">api-revision-walking</a>
  
    <li><a href="../../git/Documentation/technical/api-run-command_txt.html">api-run-command</a>
  
    <li><a href="../../git/Documentation/technical/api-setup_txt.html">api-setup</a>
  
    <li><a href="../../git/Documentation/technical/api-sha1-array_txt.html">api-sha1-array</a>
  
    <li><a href="../../git/Documentation/technical/api-sigchain_txt.html">api-sigchain</a>
  
    <li><a href="../../git/Documentation/technical/api-strbuf_txt.html">api-strbuf</a>
  
    <li><a href="../../git/Documentation/technical/api-string-list_txt.html">api-string-list</a>
  
    <li><a href="../../git/Documentation/technical/api-tree-walking_txt.html">api-tree-walking</a>
  
    <li><a href="../../git/Documentation/technical/api-xdiff-interface_txt.html">api-xdiff-interface</a>
  
    <li><a href="../../git/Documentation/technical/http-protocol_txt.html">http-protocol</a>
  
    <li><a href="../../git/Documentation/technical/index-format_txt.html">index-format</a>
  
    <li><a href="../../git/Documentation/technical/pack-format_txt.html">pack-format</a>
  
    <li><a href="../../git/Documentation/technical/pack-heuristics_txt.html">pack-heuristics</a>
  
    <li><a href="../../git/Documentation/technical/pack-protocol_txt.html">pack-protocol</a>
  
    <li><a href="../../git/Documentation/technical/protocol-capabilities_txt.html">protocol-capabilities</a>
  
    <li><a href="../../git/Documentation/technical/protocol-common_txt.html">protocol-common</a>
  
    <li><a href="../../git/Documentation/technical/racy-git_txt.html">racy-git</a>
  
    <li><a href="../../git/Documentation/technical/send-pack-pipeline_txt.html">send-pack-pipeline</a>
  
    <li><a href="../../git/Documentation/technical/shallow_txt.html">shallow</a>
  
    <li><a href="../../git/Documentation/technical/trivial-merge_txt.html">trivial-merge</a>
  
    <li><a href="../../git/Documentation/urls-remotes_txt.html">urls-remotes</a>
  
    <li><a href="../../git/Documentation/urls_txt.html">urls</a>
  
    <li><a href="../../git/Documentation/user-manual_conf.html">user-manual.conf</a>
  
    <li><a href="../../git/Documentation/user-manual_txt.html">user-manual</a>
  
    <li><a href="../../git/GIT-CFLAGS.html">GIT-CFLAGS</a>
  
    <li><a href="../../git/GIT-VERSION-FILE.html">GIT-VERSION-FILE</a>
  
    <li><a href="../../git/GIT-VERSION-GEN.html">GIT-VERSION-GEN</a>
  
    <li><a href="../../git/INSTALL.html">INSTALL</a>
  
    <li><a href="../../git/LGPL-2_1.html">LGPL-2.1</a>
  
    <li><a href="../../git/Makefile.html">Makefile</a>
  
    <li><a href="../../git/README.html">README</a>
  
    <li><a href="../../git/RelNotes.html">RelNotes</a>
  
    <li><a href="../../git/aclocal_m4.html">aclocal.m4</a>
  
    <li><a href="../../git/check-builtins_sh.html">check-builtins.sh</a>
  
    <li><a href="../../git/check_bindir.html">check_bindir</a>
  
    <li><a href="../../git/command-list_txt.html">command-list</a>
  
    <li><a href="../../git/compat/nedmalloc/License_txt.html">License</a>
  
    <li><a href="../../git/compat/nedmalloc/Readme_txt.html">Readme</a>
  
    <li><a href="../../git/compat/vcbuild/README.html">README</a>
  
    <li><a href="../../git/compat/vcbuild/scripts/clink_pl.html">clink.pl</a>
  
    <li><a href="../../git/compat/vcbuild/scripts/lib_pl.html">lib.pl</a>
  
    <li><a href="../../git/config_mak_in.html">config.mak.in</a>
  
    <li><a href="../../git/config_mak_uname.html">config.mak.uname</a>
  
    <li><a href="../../git/contrib/README.html">README</a>
  
    <li><a href="../../git/contrib/buildsystems/Generators_pm.html">Generators.pm</a>
  
    <li><a href="../../git/contrib/buildsystems/Generators/QMake_pm.html">QMake.pm</a>
  
    <li><a href="../../git/contrib/buildsystems/Generators/Vcproj_pm.html">Vcproj.pm</a>
  
    <li><a href="../../git/contrib/buildsystems/engine_pl.html">engine.pl</a>
  
    <li><a href="../../git/contrib/buildsystems/generate.html">generate</a>
  
    <li><a href="../../git/contrib/buildsystems/parse_pl.html">parse.pl</a>
  
    <li><a href="../../git/contrib/ciabot/INSTALL.html">INSTALL</a>
  
    <li><a href="../../git/contrib/ciabot/README.html">README</a>
  
    <li><a href="../../git/contrib/ciabot/ciabot_py.html">ciabot.py</a>
  
    <li><a href="../../git/contrib/ciabot/ciabot_sh.html">ciabot.sh</a>
  
    <li><a href="../../git/contrib/completion/git-completion_bash.html">git-completion.bash</a>
  
    <li><a href="../../git/contrib/completion/git-completion_tcsh.html">git-completion.tcsh</a>
  
    <li><a href="../../git/contrib/completion/git-completion_zsh.html">git-completion.zsh</a>
  
    <li><a href="../../git/contrib/completion/git-prompt_sh.html">git-prompt.sh</a>
  
    <li><a href="../../git/contrib/contacts/git-contacts.html">git-contacts</a>
  
    <li><a href="../../git/contrib/contacts/git-contacts_txt.html">git-contacts</a>
  
    <li><a href="../../git/contrib/convert-objects/git-convert-objects_txt.html">git-convert-objects</a>
  
    <li><a href="../../git/contrib/credential/gnome-keyring/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/credential/netrc/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/credential/netrc/git-credential-netrc.html">git-credential-netrc</a>
  
    <li><a href="../../git/contrib/credential/netrc/test_netrc.html">test.netrc</a>
  
    <li><a href="../../git/contrib/credential/netrc/test_pl.html">test.pl</a>
  
    <li><a href="../../git/contrib/credential/osxkeychain/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/credential/wincred/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/diff-highlight/README.html">README</a>
  
    <li><a href="../../git/contrib/diff-highlight/diff-highlight.html">diff-highlight</a>
  
    <li><a href="../../git/contrib/diffall/README.html">README</a>
  
    <li><a href="../../git/contrib/diffall/git-diffall.html">git-diffall</a>
  
    <li><a href="../../git/contrib/emacs/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/emacs/README.html">README</a>
  
    <li><a href="../../git/contrib/emacs/git-blame_el.html">git-blame.el</a>
  
    <li><a href="../../git/contrib/emacs/git_el.html">git.el</a>
  
    <li><a href="../../git/contrib/examples/README.html">README</a>
  
    <li><a href="../../git/contrib/examples/git-checkout_sh.html">git-checkout.sh</a>
  
    <li><a href="../../git/contrib/examples/git-clean_sh.html">git-clean.sh</a>
  
    <li><a href="../../git/contrib/examples/git-clone_sh.html">git-clone.sh</a>
  
    <li><a href="../../git/contrib/examples/git-commit_sh.html">git-commit.sh</a>
  
    <li><a href="../../git/contrib/examples/git-fetch_sh.html">git-fetch.sh</a>
  
    <li><a href="../../git/contrib/examples/git-gc_sh.html">git-gc.sh</a>
  
    <li><a href="../../git/contrib/examples/git-log_sh.html">git-log.sh</a>
  
    <li><a href="../../git/contrib/examples/git-ls-remote_sh.html">git-ls-remote.sh</a>
  
    <li><a href="../../git/contrib/examples/git-merge-ours_sh.html">git-merge-ours.sh</a>
  
    <li><a href="../../git/contrib/examples/git-merge_sh.html">git-merge.sh</a>
  
    <li><a href="../../git/contrib/examples/git-notes_sh.html">git-notes.sh</a>
  
    <li><a href="../../git/contrib/examples/git-remote_perl.html">git-remote.perl</a>
  
    <li><a href="../../git/contrib/examples/git-rerere_perl.html">git-rerere.perl</a>
  
    <li><a href="../../git/contrib/examples/git-reset_sh.html">git-reset.sh</a>
  
    <li><a href="../../git/contrib/examples/git-resolve_sh.html">git-resolve.sh</a>
  
    <li><a href="../../git/contrib/examples/git-revert_sh.html">git-revert.sh</a>
  
    <li><a href="../../git/contrib/examples/git-svnimport_perl.html">git-svnimport.perl</a>
  
    <li><a href="../../git/contrib/examples/git-svnimport_txt.html">git-svnimport</a>
  
    <li><a href="../../git/contrib/examples/git-tag_sh.html">git-tag.sh</a>
  
    <li><a href="../../git/contrib/examples/git-verify-tag_sh.html">git-verify-tag.sh</a>
  
    <li><a href="../../git/contrib/examples/git-whatchanged_sh.html">git-whatchanged.sh</a>
  
    <li><a href="../../git/contrib/fast-import/git-import_perl.html">git-import.perl</a>
  
    <li><a href="../../git/contrib/fast-import/git-import_sh.html">git-import.sh</a>
  
    <li><a href="../../git/contrib/fast-import/git-p4_README.html">git-p4.README</a>
  
    <li><a href="../../git/contrib/fast-import/import-directories_perl.html">import-directories.perl</a>
  
    <li><a href="../../git/contrib/fast-import/import-tars_perl.html">import-tars.perl</a>
  
    <li><a href="../../git/contrib/fast-import/import-zips_py.html">import-zips.py</a>
  
    <li><a href="../../git/contrib/git-jump/README.html">README</a>
  
    <li><a href="../../git/contrib/git-jump/git-jump.html">git-jump</a>
  
    <li><a href="../../git/contrib/git-resurrect_sh.html">git-resurrect.sh</a>
  
    <li><a href="../../git/contrib/git-shell-commands/README.html">README</a>
  
    <li><a href="../../git/contrib/git-shell-commands/help.html">help</a>
  
    <li><a href="../../git/contrib/git-shell-commands/list.html">list</a>
  
    <li><a href="../../git/contrib/gitview/gitview.html">gitview</a>
  
    <li><a href="../../git/contrib/gitview/gitview_txt.html">gitview</a>
  
    <li><a href="../../git/contrib/hg-to-git/hg-to-git_py.html">hg-to-git.py</a>
  
    <li><a href="../../git/contrib/hg-to-git/hg-to-git_txt.html">hg-to-git</a>
  
    <li><a href="../../git/contrib/hooks/multimail/README.html">README</a>
  
    <li><a href="../../git/contrib/hooks/multimail/README_Git.html">README.Git</a>
  
    <li><a href="../../git/contrib/hooks/multimail/README_migrate-from-post-receive-email.html">README.migrate-from-post-receive-email</a>
  
    <li><a href="../../git/contrib/hooks/multimail/git_multimail_py.html">git_multimail.py</a>
  
    <li><a href="../../git/contrib/hooks/multimail/migrate-mailhook-config.html">migrate-mailhook-config</a>
  
    <li><a href="../../git/contrib/hooks/multimail/post-receive.html">post-receive</a>
  
    <li><a href="../../git/contrib/hooks/post-receive-email.html">post-receive-email</a>
  
    <li><a href="../../git/contrib/hooks/pre-auto-gc-battery.html">pre-auto-gc-battery</a>
  
    <li><a href="../../git/contrib/hooks/setgitperms_perl.html">setgitperms.perl</a>
  
    <li><a href="../../git/contrib/hooks/update-paranoid.html">update-paranoid</a>
  
    <li><a href="../../git/contrib/mw-to-git/Git/Mediawiki_pm.html">Mediawiki.pm</a>
  
    <li><a href="../../git/contrib/mw-to-git/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/mw-to-git/bin-wrapper/git.html">git</a>
  
    <li><a href="../../git/contrib/mw-to-git/git-mw_perl.html">git-mw.perl</a>
  
    <li><a href="../../git/contrib/mw-to-git/git-remote-mediawiki_perl.html">git-remote-mediawiki.perl</a>
  
    <li><a href="../../git/contrib/mw-to-git/git-remote-mediawiki_txt.html">git-remote-mediawiki</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/README.html">README</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/install-wiki_sh.html">install-wiki.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/install-wiki/LocalSettings_php.html">LocalSettings.php</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/install-wiki/db_install_php.html">db_install.php</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/push-pull-tests_sh.html">push-pull-tests.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/t9360-mw-to-git-clone_sh.html">t9360-mw-to-git-clone.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/t9361-mw-to-git-push-pull_sh.html">t9361-mw-to-git-push-pull.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/t9362-mw-to-git-utf8_sh.html">t9362-mw-to-git-utf8.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/t9363-mw-to-git-export-import_sh.html">t9363-mw-to-git-export-import.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/t9364-pull-by-rev_sh.html">t9364-pull-by-rev.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/test-gitmw-lib_sh.html">test-gitmw-lib.sh</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/test-gitmw_pl.html">test-gitmw.pl</a>
  
    <li><a href="../../git/contrib/mw-to-git/t/test_config.html">test.config</a>
  
    <li><a href="../../git/contrib/p4import/README.html">README</a>
  
    <li><a href="../../git/contrib/p4import/git-p4import_py.html">git-p4import.py</a>
  
    <li><a href="../../git/contrib/p4import/git-p4import_txt.html">git-p4import</a>
  
    <li><a href="../../git/contrib/persistent-https/LICENSE.html">LICENSE</a>
  
    <li><a href="../../git/contrib/persistent-https/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/persistent-https/README.html">README</a>
  
    <li><a href="../../git/contrib/persistent-https/client_go.html">client.go</a>
  
    <li><a href="../../git/contrib/persistent-https/main_go.html">main.go</a>
  
    <li><a href="../../git/contrib/persistent-https/proxy_go.html">proxy.go</a>
  
    <li><a href="../../git/contrib/persistent-https/socket_go.html">socket.go</a>
  
    <li><a href="../../git/contrib/remote-helpers/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/remote-helpers/git-remote-bzr.html">git-remote-bzr</a>
  
    <li><a href="../../git/contrib/remote-helpers/git-remote-hg.html">git-remote-hg</a>
  
    <li><a href="../../git/contrib/remote-helpers/test-bzr_sh.html">test-bzr.sh</a>
  
    <li><a href="../../git/contrib/remote-helpers/test-hg-bidi_sh.html">test-hg-bidi.sh</a>
  
    <li><a href="../../git/contrib/remote-helpers/test-hg-hg-git_sh.html">test-hg-hg-git.sh</a>
  
    <li><a href="../../git/contrib/remote-helpers/test-hg_sh.html">test-hg.sh</a>
  
    <li><a href="../../git/contrib/remotes2config_sh.html">remotes2config.sh</a>
  
    <li><a href="../../git/contrib/rerere-train_sh.html">rerere-train.sh</a>
  
    <li><a href="../../git/contrib/stats/git-common-hash.html">git-common-hash</a>
  
    <li><a href="../../git/contrib/stats/mailmap_pl.html">mailmap.pl</a>
  
    <li><a href="../../git/contrib/stats/packinfo_pl.html">packinfo.pl</a>
  
    <li><a href="../../git/contrib/subtree/COPYING.html">COPYING</a>
  
    <li><a href="../../git/contrib/subtree/INSTALL.html">INSTALL</a>
  
    <li><a href="../../git/contrib/subtree/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/subtree/README.html">README</a>
  
    <li><a href="../../git/contrib/subtree/git-subtree_sh.html">git-subtree.sh</a>
  
    <li><a href="../../git/contrib/subtree/git-subtree_txt.html">git-subtree</a>
  
    <li><a href="../../git/contrib/subtree/t/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/subtree/t/t7900-subtree_sh.html">t7900-subtree.sh</a>
  
    <li><a href="../../git/contrib/subtree/todo.html">todo</a>
  
    <li><a href="../../git/contrib/svn-fe/Makefile.html">Makefile</a>
  
    <li><a href="../../git/contrib/svn-fe/svn-fe_txt.html">svn-fe</a>
  
    <li><a href="../../git/contrib/svn-fe/svnrdump_sim_py.html">svnrdump_sim.py</a>
  
    <li><a href="../../git/contrib/thunderbird-patch-inline/README.html">README</a>
  
    <li><a href="../../git/contrib/thunderbird-patch-inline/appp_sh.html">appp.sh</a>
  
    <li><a href="../../git/contrib/vim/README.html">README</a>
  
    <li><a href="../../git/contrib/workdir/git-new-workdir.html">git-new-workdir</a>
  
    <li><a href="../../git/generate-cmdlist_sh.html">generate-cmdlist.sh</a>
  
    <li><a href="../../git/git-add--interactive_perl.html">git-add--interactive.perl</a>
  
    <li><a href="../../git/git-am_sh.html">git-am.sh</a>
  
    <li><a href="../../git/git-archimport_perl.html">git-archimport.perl</a>
  
    <li><a href="../../git/git-bisect_sh.html">git-bisect.sh</a>
  
    <li><a href="../../git/git-cvsexportcommit_perl.html">git-cvsexportcommit.perl</a>
  
    <li><a href="../../git/git-cvsimport_perl.html">git-cvsimport.perl</a>
  
    <li><a href="../../git/git-cvsserver_perl.html">git-cvsserver.perl</a>
  
    <li><a href="../../git/git-difftool--helper_sh.html">git-difftool--helper.sh</a>
  
    <li><a href="../../git/git-difftool_perl.html">git-difftool.perl</a>
  
    <li><a href="../../git/git-filter-branch_sh.html">git-filter-branch.sh</a>
  
    <li><a href="../../git/git-gui/GIT-VERSION-GEN.html">GIT-VERSION-GEN</a>
  
    <li><a href="../../git/git-gui/Makefile.html">Makefile</a>
  
    <li><a href="../../git/git-gui/git-gui--askpass.html">git-gui--askpass</a>
  
    <li><a href="../../git/git-gui/git-gui_sh.html">git-gui.sh</a>
  
    <li><a href="../../git/git-gui/lib/about_tcl.html">about.tcl</a>
  
    <li><a href="../../git/git-gui/lib/blame_tcl.html">blame.tcl</a>
  
    <li><a href="../../git/git-gui/lib/branch_tcl.html">branch.tcl</a>
  
    <li><a href="../../git/git-gui/lib/branch_checkout_tcl.html">branch_checkout.tcl</a>
  
    <li><a href="../../git/git-gui/lib/branch_create_tcl.html">branch_create.tcl</a>
  
    <li><a href="../../git/git-gui/lib/branch_delete_tcl.html">branch_delete.tcl</a>
  
    <li><a href="../../git/git-gui/lib/branch_rename_tcl.html">branch_rename.tcl</a>
  
    <li><a href="../../git/git-gui/lib/browser_tcl.html">browser.tcl</a>
  
    <li><a href="../../git/git-gui/lib/checkout_op_tcl.html">checkout_op.tcl</a>
  
    <li><a href="../../git/git-gui/lib/choose_font_tcl.html">choose_font.tcl</a>
  
    <li><a href="../../git/git-gui/lib/choose_repository_tcl.html">choose_repository.tcl</a>
  
    <li><a href="../../git/git-gui/lib/choose_rev_tcl.html">choose_rev.tcl</a>
  
    <li><a href="../../git/git-gui/lib/class_tcl.html">class.tcl</a>
  
    <li><a href="../../git/git-gui/lib/commit_tcl.html">commit.tcl</a>
  
    <li><a href="../../git/git-gui/lib/console_tcl.html">console.tcl</a>
  
    <li><a href="../../git/git-gui/lib/database_tcl.html">database.tcl</a>
  
    <li><a href="../../git/git-gui/lib/date_tcl.html">date.tcl</a>
  
    <li><a href="../../git/git-gui/lib/diff_tcl.html">diff.tcl</a>
  
    <li><a href="../../git/git-gui/lib/encoding_tcl.html">encoding.tcl</a>
  
    <li><a href="../../git/git-gui/lib/error_tcl.html">error.tcl</a>
  
    <li><a href="../../git/git-gui/lib/index_tcl.html">index.tcl</a>
  
    <li><a href="../../git/git-gui/lib/line_tcl.html">line.tcl</a>
  
    <li><a href="../../git/git-gui/lib/logo_tcl.html">logo.tcl</a>
  
    <li><a href="../../git/git-gui/lib/merge_tcl.html">merge.tcl</a>
  
    <li><a href="../../git/git-gui/lib/mergetool_tcl.html">mergetool.tcl</a>
  
    <li><a href="../../git/git-gui/lib/option_tcl.html">option.tcl</a>
  
    <li><a href="../../git/git-gui/lib/remote_tcl.html">remote.tcl</a>
  
    <li><a href="../../git/git-gui/lib/remote_add_tcl.html">remote_add.tcl</a>
  
    <li><a href="../../git/git-gui/lib/remote_branch_delete_tcl.html">remote_branch_delete.tcl</a>
  
    <li><a href="../../git/git-gui/lib/search_tcl.html">search.tcl</a>
  
    <li><a href="../../git/git-gui/lib/shortcut_tcl.html">shortcut.tcl</a>
  
    <li><a href="../../git/git-gui/lib/spellcheck_tcl.html">spellcheck.tcl</a>
  
    <li><a href="../../git/git-gui/lib/sshkey_tcl.html">sshkey.tcl</a>
  
    <li><a href="../../git/git-gui/lib/status_bar_tcl.html">status_bar.tcl</a>
  
    <li><a href="../../git/git-gui/lib/themed_tcl.html">themed.tcl</a>
  
    <li><a href="../../git/git-gui/lib/tools_tcl.html">tools.tcl</a>
  
    <li><a href="../../git/git-gui/lib/tools_dlg_tcl.html">tools_dlg.tcl</a>
  
    <li><a href="../../git/git-gui/lib/transport_tcl.html">transport.tcl</a>
  
    <li><a href="../../git/git-gui/lib/win32_tcl.html">win32.tcl</a>
  
    <li><a href="../../git/git-gui/lib/win32_shortcut_js.html">win32_shortcut.js</a>
  
    <li><a href="../../git/git-gui/macosx/AppMain_tcl.html">AppMain.tcl</a>
  
    <li><a href="../../git/git-gui/macosx/Info_plist.html">Info.plist</a>
  
    <li><a href="../../git/git-gui/po/README.html">README</a>
  
    <li><a href="../../git/git-gui/po/de_po.html">de.po</a>
  
    <li><a href="../../git/git-gui/po/el_po.html">el.po</a>
  
    <li><a href="../../git/git-gui/po/fr_po.html">fr.po</a>
  
    <li><a href="../../git/git-gui/po/git-gui_pot.html">git-gui.pot</a>
  
    <li><a href="../../git/git-gui/po/glossary/Makefile.html">Makefile</a>
  
    <li><a href="../../git/git-gui/po/glossary/de_po.html">de.po</a>
  
    <li><a href="../../git/git-gui/po/glossary/el_po.html">el.po</a>
  
    <li><a href="../../git/git-gui/po/glossary/fr_po.html">fr.po</a>
  
    <li><a href="../../git/git-gui/po/glossary/git-gui-glossary_pot.html">git-gui-glossary.pot</a>
  
    <li><a href="../../git/git-gui/po/glossary/git-gui-glossary_txt.html">git-gui-glossary</a>
  
    <li><a href="../../git/git-gui/po/glossary/it_po.html">it.po</a>
  
    <li><a href="../../git/git-gui/po/glossary/pt_br_po.html">pt_br.po</a>
  
    <li><a href="../../git/git-gui/po/glossary/txt-to-pot_sh.html">txt-to-pot.sh</a>
  
    <li><a href="../../git/git-gui/po/glossary/zh_cn_po.html">zh_cn.po</a>
  
    <li><a href="../../git/git-gui/po/hu_po.html">hu.po</a>
  
    <li><a href="../../git/git-gui/po/it_po.html">it.po</a>
  
    <li><a href="../../git/git-gui/po/ja_po.html">ja.po</a>
  
    <li><a href="../../git/git-gui/po/nb_po.html">nb.po</a>
  
    <li><a href="../../git/git-gui/po/po2msg_sh.html">po2msg.sh</a>
  
    <li><a href="../../git/git-gui/po/pt_br_po.html">pt_br.po</a>
  
    <li><a href="../../git/git-gui/po/ru_po.html">ru.po</a>
  
    <li><a href="../../git/git-gui/po/sv_po.html">sv.po</a>
  
    <li><a href="../../git/git-gui/po/zh_cn_po.html">zh_cn.po</a>
  
    <li><a href="../../git/git-gui/windows/git-gui_sh.html">git-gui.sh</a>
  
    <li><a href="../../git/git-instaweb_sh.html">git-instaweb.sh</a>
  
    <li><a href="../../git/git-lost-found_sh.html">git-lost-found.sh</a>
  
    <li><a href="../../git/git-merge-octopus_sh.html">git-merge-octopus.sh</a>
  
    <li><a href="../../git/git-merge-one-file_sh.html">git-merge-one-file.sh</a>
  
    <li><a href="../../git/git-merge-resolve_sh.html">git-merge-resolve.sh</a>
  
    <li><a href="../../git/git-mergetool--lib_sh.html">git-mergetool--lib.sh</a>
  
    <li><a href="../../git/git-mergetool_sh.html">git-mergetool.sh</a>
  
    <li><a href="../../git/git-p4_py.html">git-p4.py</a>
  
    <li><a href="../../git/git-parse-remote_sh.html">git-parse-remote.sh</a>
  
    <li><a href="../../git/git-pull_sh.html">git-pull.sh</a>
  
    <li><a href="../../git/git-quiltimport_sh.html">git-quiltimport.sh</a>
  
    <li><a href="../../git/git-rebase--am_sh.html">git-rebase--am.sh</a>
  
    <li><a href="../../git/git-rebase--interactive_sh.html">git-rebase--interactive.sh</a>
  
    <li><a href="../../git/git-rebase--merge_sh.html">git-rebase--merge.sh</a>
  
    <li><a href="../../git/git-rebase_sh.html">git-rebase.sh</a>
  
    <li><a href="../../git/git-relink_perl.html">git-relink.perl</a>
  
    <li><a href="../../git/git-remote-testgit_sh.html">git-remote-testgit.sh</a>
  
    <li><a href="../../git/git-repack_sh.html">git-repack.sh</a>
  
    <li><a href="../../git/git-request-pull_sh.html">git-request-pull.sh</a>
  
    <li><a href="../../git/git-send-email_perl.html">git-send-email.perl</a>
  
    <li><a href="../../git/git-sh-i18n_sh.html">git-sh-i18n.sh</a>
  
    <li><a href="../../git/git-sh-setup_sh.html">git-sh-setup.sh</a>
  
    <li><a href="../../git/git-stash_sh.html">git-stash.sh</a>
  
    <li><a href="../../git/git-submodule_sh.html">git-submodule.sh</a>
  
    <li><a href="../../git/git-svn_perl.html">git-svn.perl</a>
  
    <li><a href="../../git/git-web--browse_sh.html">git-web--browse.sh</a>
  
    <li><a href="../../git/git_rc.html">git.rc</a>
  
    <li><a href="../../git/git_spec_in.html">git.spec.in</a>
  
    <li><a href="../../git/gitk-git/Makefile.html">Makefile</a>
  
    <li><a href="../../git/gitk-git/gitk.html">gitk</a>
  
    <li><a href="../../git/gitk-git/po/de_po.html">de.po</a>
  
    <li><a href="../../git/gitk-git/po/es_po.html">es.po</a>
  
    <li><a href="../../git/gitk-git/po/fr_po.html">fr.po</a>
  
    <li><a href="../../git/gitk-git/po/hu_po.html">hu.po</a>
  
    <li><a href="../../git/gitk-git/po/it_po.html">it.po</a>
  
    <li><a href="../../git/gitk-git/po/ja_po.html">ja.po</a>
  
    <li><a href="../../git/gitk-git/po/po2msg_sh.html">po2msg.sh</a>
  
    <li><a href="../../git/gitk-git/po/pt_br_po.html">pt_br.po</a>
  
    <li><a href="../../git/gitk-git/po/ru_po.html">ru.po</a>
  
    <li><a href="../../git/gitk-git/po/sv_po.html">sv.po</a>
  
    <li><a href="../../git/gitweb/INSTALL.html">INSTALL</a>
  
    <li><a href="../../git/gitweb/Makefile.html">Makefile</a>
  
    <li><a href="../../git/gitweb/README.html">README</a>
  
    <li><a href="../../git/gitweb/gitweb_perl.html">gitweb.perl</a>
  
    <li><a href="../../git/gitweb/static/gitweb_css.html">gitweb.css</a>
  
    <li><a href="../../git/gitweb/static/js/README.html">README</a>
  
    <li><a href="../../git/gitweb/static/js/adjust-timezone_js.html">adjust-timezone.js</a>
  
    <li><a href="../../git/gitweb/static/js/blame_incremental_js.html">blame_incremental.js</a>
  
    <li><a href="../../git/gitweb/static/js/javascript-detection_js.html">javascript-detection.js</a>
  
    <li><a href="../../git/gitweb/static/js/lib/common-lib_js.html">common-lib.js</a>
  
    <li><a href="../../git/gitweb/static/js/lib/cookies_js.html">cookies.js</a>
  
    <li><a href="../../git/gitweb/static/js/lib/datetime_js.html">datetime.js</a>
  
    <li><a href="../../git/mergetools/araxis.html">araxis</a>
  
    <li><a href="../../git/mergetools/bc3.html">bc3</a>
  
    <li><a href="../../git/mergetools/codecompare.html">codecompare</a>
  
    <li><a href="../../git/mergetools/deltawalker.html">deltawalker</a>
  
    <li><a href="../../git/mergetools/diffuse.html">diffuse</a>
  
    <li><a href="../../git/mergetools/ecmerge.html">ecmerge</a>
  
    <li><a href="../../git/mergetools/emerge.html">emerge</a>
  
    <li><a href="../../git/mergetools/gvimdiff.html">gvimdiff</a>
  
    <li><a href="../../git/mergetools/gvimdiff2.html">gvimdiff2</a>
  
    <li><a href="../../git/mergetools/kdiff3.html">kdiff3</a>
  
    <li><a href="../../git/mergetools/kompare.html">kompare</a>
  
    <li><a href="../../git/mergetools/meld.html">meld</a>
  
    <li><a href="../../git/mergetools/opendiff.html">opendiff</a>
  
    <li><a href="../../git/mergetools/p4merge.html">p4merge</a>
  
    <li><a href="../../git/mergetools/tkdiff.html">tkdiff</a>
  
    <li><a href="../../git/mergetools/tortoisemerge.html">tortoisemerge</a>
  
    <li><a href="../../git/mergetools/vimdiff.html">vimdiff</a>
  
    <li><a href="../../git/mergetools/vimdiff2.html">vimdiff2</a>
  
    <li><a href="../../git/mergetools/xxdiff.html">xxdiff</a>
  
    <li><a href="../../git/perl/Git_pm.html">Git.pm</a>
  
    <li><a href="../../git/perl/Git/I18N_pm.html">I18N.pm</a>
  
    <li><a href="../../git/perl/Git/IndexInfo_pm.html">IndexInfo.pm</a>
  
    <li><a href="../../git/perl/Git/SVN_pm.html">SVN.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Editor_pm.html">Editor.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Fetcher_pm.html">Fetcher.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/GlobSpec_pm.html">GlobSpec.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Log_pm.html">Log.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Memoize/YAML_pm.html">YAML.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Migration_pm.html">Migration.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Prompt_pm.html">Prompt.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Ra_pm.html">Ra.pm</a>
  
    <li><a href="../../git/perl/Git/SVN/Utils_pm.html">Utils.pm</a>
  
    <li><a href="../../git/perl/Makefile.html">Makefile</a>
  
    <li><a href="../../git/perl/Makefile_PL.html">Makefile.PL</a>
  
    <li><a href="../../git/perl/private-Error_pm.html">private-Error.pm</a>
  
    <li><a href="../../git/po/README.html">README</a>
  
    <li><a href="../../git/po/TEAMS.html">TEAMS</a>
  
    <li><a href="../../git/po/da_po.html">da.po</a>
  
    <li><a href="../../git/po/de_po.html">de.po</a>
  
    <li><a href="../../git/po/fr_po.html">fr.po</a>
  
    <li><a href="../../git/po/git_pot.html">git.pot</a>
  
    <li><a href="../../git/po/is_po.html">is.po</a>
  
    <li><a href="../../git/po/it_po.html">it.po</a>
  
    <li><a href="../../git/po/nl_po.html">nl.po</a>
  
    <li><a href="../../git/po/pt_PT_po.html">pt_PT.po</a>
  
    <li><a href="../../git/po/sv_po.html">sv.po</a>
  
    <li><a href="../../git/po/vi_po.html">vi.po</a>
  
    <li><a href="../../git/po/zh_CN_po.html">zh_CN.po</a>
  
    <li><a href="../../git/ppc/sha1ppc_S.html">sha1ppc.S</a>
  
    <li><a href="../../git/t/Git-SVN/00compile_t.html">00compile.t</a>
  
    <li><a href="../../git/t/Git-SVN/Utils/add_path_to_url_t.html">add_path_to_url.t</a>
  
    <li><a href="../../git/t/Git-SVN/Utils/can_compress_t.html">can_compress.t</a>
  
    <li><a href="../../git/t/Git-SVN/Utils/canonicalize_url_t.html">canonicalize_url.t</a>
  
    <li><a href="../../git/t/Git-SVN/Utils/collapse_dotdot_t.html">collapse_dotdot.t</a>
  
    <li><a href="../../git/t/Git-SVN/Utils/fatal_t.html">fatal.t</a>
  
    <li><a href="../../git/t/Git-SVN/Utils/join_paths_t.html">join_paths.t</a>
  
    <li><a href="../../git/t/Makefile.html">Makefile</a>
  
    <li><a href="../../git/t/README.html">README</a>
  
    <li><a href="../../git/t/aggregate-results_sh.html">aggregate-results.sh</a>
  
    <li><a href="../../git/t/annotate-tests_sh.html">annotate-tests.sh</a>
  
    <li><a href="../../git/t/check-non-portable-shell_pl.html">check-non-portable-shell.pl</a>
  
    <li><a href="../../git/t/diff-lib_sh.html">diff-lib.sh</a>
  
    <li><a href="../../git/t/gitweb-lib_sh.html">gitweb-lib.sh</a>
  
    <li><a href="../../git/t/lib-bash_sh.html">lib-bash.sh</a>
  
    <li><a href="../../git/t/lib-credential_sh.html">lib-credential.sh</a>
  
    <li><a href="../../git/t/lib-cvs_sh.html">lib-cvs.sh</a>
  
    <li><a href="../../git/t/lib-diff-alternative_sh.html">lib-diff-alternative.sh</a>
  
    <li><a href="../../git/t/lib-gettext_sh.html">lib-gettext.sh</a>
  
    <li><a href="../../git/t/lib-git-daemon_sh.html">lib-git-daemon.sh</a>
  
    <li><a href="../../git/t/lib-git-p4_sh.html">lib-git-p4.sh</a>
  
    <li><a href="../../git/t/lib-git-svn_sh.html">lib-git-svn.sh</a>
  
    <li><a href="../../git/t/lib-gpg_sh.html">lib-gpg.sh</a>
  
    <li><a href="../../git/t/lib-httpd_sh.html">lib-httpd.sh</a>
  
    <li><a href="../../git/t/lib-httpd/apache_conf.html">apache.conf</a>
  
    <li><a href="../../git/t/lib-httpd/broken-smart-http_sh.html">broken-smart-http.sh</a>
  
    <li><a href="../../git/t/lib-httpd/passwd.html">passwd</a>
  
    <li><a href="../../git/t/lib-httpd/ssl_cnf.html">ssl.cnf</a>
  
    <li><a href="../../git/t/lib-pack_sh.html">lib-pack.sh</a>
  
    <li><a href="../../git/t/lib-pager_sh.html">lib-pager.sh</a>
  
    <li><a href="../../git/t/lib-patch-mode_sh.html">lib-patch-mode.sh</a>
  
    <li><a href="../../git/t/lib-prereq-FILEMODE_sh.html">lib-prereq-FILEMODE.sh</a>
  
    <li><a href="../../git/t/lib-read-tree-m-3way_sh.html">lib-read-tree-m-3way.sh</a>
  
    <li><a href="../../git/t/lib-read-tree_sh.html">lib-read-tree.sh</a>
  
    <li><a href="../../git/t/lib-rebase_sh.html">lib-rebase.sh</a>
  
    <li><a href="../../git/t/lib-t6000_sh.html">lib-t6000.sh</a>
  
    <li><a href="../../git/t/lib-terminal_sh.html">lib-terminal.sh</a>
  
    <li><a href="../../git/t/perf/Makefile.html">Makefile</a>
  
    <li><a href="../../git/t/perf/README.html">README</a>
  
    <li><a href="../../git/t/perf/aggregate_perl.html">aggregate.perl</a>
  
    <li><a href="../../git/t/perf/min_time_perl.html">min_time.perl</a>
  
    <li><a href="../../git/t/perf/p0000-perf-lib-sanity_sh.html">p0000-perf-lib-sanity.sh</a>
  
    <li><a href="../../git/t/perf/p0001-rev-list_sh.html">p0001-rev-list.sh</a>
  
    <li><a href="../../git/t/perf/p0002-read-cache_sh.html">p0002-read-cache.sh</a>
  
    <li><a href="../../git/t/perf/p4000-diff-algorithms_sh.html">p4000-diff-algorithms.sh</a>
  
    <li><a href="../../git/t/perf/p4211-line-log_sh.html">p4211-line-log.sh</a>
  
    <li><a href="../../git/t/perf/p5302-pack-index_sh.html">p5302-pack-index.sh</a>
  
    <li><a href="../../git/t/perf/p7810-grep_sh.html">p7810-grep.sh</a>
  
    <li><a href="../../git/t/perf/perf-lib_sh.html">perf-lib.sh</a>
  
    <li><a href="../../git/t/perf/run.html">run</a>
  
    <li><a href="../../git/t/t0000-basic_sh.html">t0000-basic.sh</a>
  
    <li><a href="../../git/t/t0001-init_sh.html">t0001-init.sh</a>
  
    <li><a href="../../git/t/t0002-gitfile_sh.html">t0002-gitfile.sh</a>
  
    <li><a href="../../git/t/t0003-attributes_sh.html">t0003-attributes.sh</a>
  
    <li><a href="../../git/t/t0004-unwritable_sh.html">t0004-unwritable.sh</a>
  
    <li><a href="../../git/t/t0005-signals_sh.html">t0005-signals.sh</a>
  
    <li><a href="../../git/t/t0006-date_sh.html">t0006-date.sh</a>
  
    <li><a href="../../git/t/t0007-git-var_sh.html">t0007-git-var.sh</a>
  
    <li><a href="../../git/t/t0008-ignores_sh.html">t0008-ignores.sh</a>
  
    <li><a href="../../git/t/t0009-prio-queue_sh.html">t0009-prio-queue.sh</a>
  
    <li><a href="../../git/t/t0010-racy-git_sh.html">t0010-racy-git.sh</a>
  
    <li><a href="../../git/t/t0020-crlf_sh.html">t0020-crlf.sh</a>
  
    <li><a href="../../git/t/t0021-conversion_sh.html">t0021-conversion.sh</a>
  
    <li><a href="../../git/t/t0022-crlf-rename_sh.html">t0022-crlf-rename.sh</a>
  
    <li><a href="../../git/t/t0023-crlf-am_sh.html">t0023-crlf-am.sh</a>
  
    <li><a href="../../git/t/t0024-crlf-archive_sh.html">t0024-crlf-archive.sh</a>
  
    <li><a href="../../git/t/t0025-crlf-auto_sh.html">t0025-crlf-auto.sh</a>
  
    <li><a href="../../git/t/t0026-eol-config_sh.html">t0026-eol-config.sh</a>
  
    <li><a href="../../git/t/t0030-stripspace_sh.html">t0030-stripspace.sh</a>
  
    <li><a href="../../git/t/t0040-parse-options_sh.html">t0040-parse-options.sh</a>
  
    <li><a href="../../git/t/t0050-filesystem_sh.html">t0050-filesystem.sh</a>
  
    <li><a href="../../git/t/t0055-beyond-symlinks_sh.html">t0055-beyond-symlinks.sh</a>
  
    <li><a href="../../git/t/t0056-git-C_sh.html">t0056-git-C.sh</a>
  
    <li><a href="../../git/t/t0060-path-utils_sh.html">t0060-path-utils.sh</a>
  
    <li><a href="../../git/t/t0061-run-command_sh.html">t0061-run-command.sh</a>
  
    <li><a href="../../git/t/t0062-revision-walking_sh.html">t0062-revision-walking.sh</a>
  
    <li><a href="../../git/t/t0063-string-list_sh.html">t0063-string-list.sh</a>
  
    <li><a href="../../git/t/t0070-fundamental_sh.html">t0070-fundamental.sh</a>
  
    <li><a href="../../git/t/t0081-line-buffer_sh.html">t0081-line-buffer.sh</a>
  
    <li><a href="../../git/t/t0090-cache-tree_sh.html">t0090-cache-tree.sh</a>
  
    <li><a href="../../git/t/t0100-previous_sh.html">t0100-previous.sh</a>
  
    <li><a href="../../git/t/t0101-at-syntax_sh.html">t0101-at-syntax.sh</a>
  
    <li><a href="../../git/t/t0110-urlmatch-normalization_sh.html">t0110-urlmatch-normalization.sh</a>
  
    <li><a href="../../git/t/t0110/README.html">README</a>
  
    <li><a href="../../git/t/t0110/url-1.html">url-1</a>
  
    <li><a href="../../git/t/t0110/url-11.html">url-11</a>
  
    <li><a href="../../git/t/t0110/url-2.html">url-2</a>
  
    <li><a href="../../git/t/t0200-gettext-basic_sh.html">t0200-gettext-basic.sh</a>
  
    <li><a href="../../git/t/t0200/test_perl.html">test.perl</a>
  
    <li><a href="../../git/t/t0200/test_sh.html">test.sh</a>
  
    <li><a href="../../git/t/t0201-gettext-fallbacks_sh.html">t0201-gettext-fallbacks.sh</a>
  
    <li><a href="../../git/t/t0202-gettext-perl_sh.html">t0202-gettext-perl.sh</a>
  
    <li><a href="../../git/t/t0202/test_pl.html">test.pl</a>
  
    <li><a href="../../git/t/t0203-gettext-setlocale-sanity_sh.html">t0203-gettext-setlocale-sanity.sh</a>
  
    <li><a href="../../git/t/t0204-gettext-reencode-sanity_sh.html">t0204-gettext-reencode-sanity.sh</a>
  
    <li><a href="../../git/t/t0205-gettext-poison_sh.html">t0205-gettext-poison.sh</a>
  
    <li><a href="../../git/t/t0300-credentials_sh.html">t0300-credentials.sh</a>
  
    <li><a href="../../git/t/t0301-credential-cache_sh.html">t0301-credential-cache.sh</a>
  
    <li><a href="../../git/t/t0302-credential-store_sh.html">t0302-credential-store.sh</a>
  
    <li><a href="../../git/t/t0303-credential-external_sh.html">t0303-credential-external.sh</a>
  
    <li><a href="../../git/t/t1000-read-tree-m-3way_sh.html">t1000-read-tree-m-3way.sh</a>
  
    <li><a href="../../git/t/t1001-read-tree-m-2way_sh.html">t1001-read-tree-m-2way.sh</a>
  
    <li><a href="../../git/t/t1002-read-tree-m-u-2way_sh.html">t1002-read-tree-m-u-2way.sh</a>
  
    <li><a href="../../git/t/t1003-read-tree-prefix_sh.html">t1003-read-tree-prefix.sh</a>
  
    <li><a href="../../git/t/t1004-read-tree-m-u-wf_sh.html">t1004-read-tree-m-u-wf.sh</a>
  
    <li><a href="../../git/t/t1005-read-tree-reset_sh.html">t1005-read-tree-reset.sh</a>
  
    <li><a href="../../git/t/t1006-cat-file_sh.html">t1006-cat-file.sh</a>
  
    <li><a href="../../git/t/t1007-hash-object_sh.html">t1007-hash-object.sh</a>
  
    <li><a href="../../git/t/t1008-read-tree-overlay_sh.html">t1008-read-tree-overlay.sh</a>
  
    <li><a href="../../git/t/t1009-read-tree-new-index_sh.html">t1009-read-tree-new-index.sh</a>
  
    <li><a href="../../git/t/t1010-mktree_sh.html">t1010-mktree.sh</a>
  
    <li><a href="../../git/t/t1011-read-tree-sparse-checkout_sh.html">t1011-read-tree-sparse-checkout.sh</a>
  
    <li><a href="../../git/t/t1012-read-tree-df_sh.html">t1012-read-tree-df.sh</a>
  
    <li><a href="../../git/t/t1013-loose-object-format_sh.html">t1013-loose-object-format.sh</a>
  
    <li><a href="../../git/t/t1020-subdirectory_sh.html">t1020-subdirectory.sh</a>
  
    <li><a href="../../git/t/t1021-rerere-in-workdir_sh.html">t1021-rerere-in-workdir.sh</a>
  
    <li><a href="../../git/t/t1050-large_sh.html">t1050-large.sh</a>
  
    <li><a href="../../git/t/t1051-large-conversion_sh.html">t1051-large-conversion.sh</a>
  
    <li><a href="../../git/t/t1060-object-corruption_sh.html">t1060-object-corruption.sh</a>
  
    <li><a href="../../git/t/t1100-commit-tree-options_sh.html">t1100-commit-tree-options.sh</a>
  
    <li><a href="../../git/t/t1200-tutorial_sh.html">t1200-tutorial.sh</a>
  
    <li><a href="../../git/t/t1300-repo-config_sh.html">t1300-repo-config.sh</a>
  
    <li><a href="../../git/t/t1301-shared-repo_sh.html">t1301-shared-repo.sh</a>
  
    <li><a href="../../git/t/t1302-repo-version_sh.html">t1302-repo-version.sh</a>
  
    <li><a href="../../git/t/t1303-wacky-config_sh.html">t1303-wacky-config.sh</a>
  
    <li><a href="../../git/t/t1304-default-acl_sh.html">t1304-default-acl.sh</a>
  
    <li><a href="../../git/t/t1305-config-include_sh.html">t1305-config-include.sh</a>
  
    <li><a href="../../git/t/t1306-xdg-files_sh.html">t1306-xdg-files.sh</a>
  
    <li><a href="../../git/t/t1307-config-blob_sh.html">t1307-config-blob.sh</a>
  
    <li><a href="../../git/t/t1400-update-ref_sh.html">t1400-update-ref.sh</a>
  
    <li><a href="../../git/t/t1401-symbolic-ref_sh.html">t1401-symbolic-ref.sh</a>
  
    <li><a href="../../git/t/t1402-check-ref-format_sh.html">t1402-check-ref-format.sh</a>
  
    <li><a href="../../git/t/t1403-show-ref_sh.html">t1403-show-ref.sh</a>
  
    <li><a href="../../git/t/t1410-reflog_sh.html">t1410-reflog.sh</a>
  
    <li><a href="../../git/t/t1411-reflog-show_sh.html">t1411-reflog-show.sh</a>
  
    <li><a href="../../git/t/t1412-reflog-loop_sh.html">t1412-reflog-loop.sh</a>
  
    <li><a href="../../git/t/t1420-lost-found_sh.html">t1420-lost-found.sh</a>
  
    <li><a href="../../git/t/t1450-fsck_sh.html">t1450-fsck.sh</a>
  
    <li><a href="../../git/t/t1500-rev-parse_sh.html">t1500-rev-parse.sh</a>
  
    <li><a href="../../git/t/t1501-worktree_sh.html">t1501-worktree.sh</a>
  
    <li><a href="../../git/t/t1502-rev-parse-parseopt_sh.html">t1502-rev-parse-parseopt.sh</a>
  
    <li><a href="../../git/t/t1503-rev-parse-verify_sh.html">t1503-rev-parse-verify.sh</a>
  
    <li><a href="../../git/t/t1504-ceiling-dirs_sh.html">t1504-ceiling-dirs.sh</a>
  
    <li><a href="../../git/t/t1505-rev-parse-last_sh.html">t1505-rev-parse-last.sh</a>
  
    <li><a href="../../git/t/t1506-rev-parse-diagnosis_sh.html">t1506-rev-parse-diagnosis.sh</a>
  
    <li><a href="../../git/t/t1507-rev-parse-upstream_sh.html">t1507-rev-parse-upstream.sh</a>
  
    <li><a href="../../git/t/t1508-at-combinations_sh.html">t1508-at-combinations.sh</a>
  
    <li><a href="../../git/t/t1509-root-worktree_sh.html">t1509-root-worktree.sh</a>
  
    <li><a href="../../git/t/t1509/excludes.html">excludes</a>
  
    <li><a href="../../git/t/t1509/prepare-chroot_sh.html">prepare-chroot.sh</a>
  
    <li><a href="../../git/t/t1510-repo-setup_sh.html">t1510-repo-setup.sh</a>
  
    <li><a href="../../git/t/t1511-rev-parse-caret_sh.html">t1511-rev-parse-caret.sh</a>
  
    <li><a href="../../git/t/t1512-rev-parse-disambiguation_sh.html">t1512-rev-parse-disambiguation.sh</a>
  
    <li><a href="../../git/t/t1513-rev-parse-prefix_sh.html">t1513-rev-parse-prefix.sh</a>
  
    <li><a href="../../git/t/t2000-checkout-cache-clash_sh.html">t2000-checkout-cache-clash.sh</a>
  
    <li><a href="../../git/t/t2001-checkout-cache-clash_sh.html">t2001-checkout-cache-clash.sh</a>
  
    <li><a href="../../git/t/t2002-checkout-cache-u_sh.html">t2002-checkout-cache-u.sh</a>
  
    <li><a href="../../git/t/t2003-checkout-cache-mkdir_sh.html">t2003-checkout-cache-mkdir.sh</a>
  
    <li><a href="../../git/t/t2004-checkout-cache-temp_sh.html">t2004-checkout-cache-temp.sh</a>
  
    <li><a href="../../git/t/t2005-checkout-index-symlinks_sh.html">t2005-checkout-index-symlinks.sh</a>
  
    <li><a href="../../git/t/t2006-checkout-index-basic_sh.html">t2006-checkout-index-basic.sh</a>
  
    <li><a href="../../git/t/t2007-checkout-symlink_sh.html">t2007-checkout-symlink.sh</a>
  
    <li><a href="../../git/t/t2008-checkout-subdir_sh.html">t2008-checkout-subdir.sh</a>
  
    <li><a href="../../git/t/t2009-checkout-statinfo_sh.html">t2009-checkout-statinfo.sh</a>
  
    <li><a href="../../git/t/t2010-checkout-ambiguous_sh.html">t2010-checkout-ambiguous.sh</a>
  
    <li><a href="../../git/t/t2011-checkout-invalid-head_sh.html">t2011-checkout-invalid-head.sh</a>
  
    <li><a href="../../git/t/t2012-checkout-last_sh.html">t2012-checkout-last.sh</a>
  
    <li><a href="../../git/t/t2013-checkout-submodule_sh.html">t2013-checkout-submodule.sh</a>
  
    <li><a href="../../git/t/t2014-switch_sh.html">t2014-switch.sh</a>
  
    <li><a href="../../git/t/t2015-checkout-unborn_sh.html">t2015-checkout-unborn.sh</a>
  
    <li><a href="../../git/t/t2016-checkout-patch_sh.html">t2016-checkout-patch.sh</a>
  
    <li><a href="../../git/t/t2017-checkout-orphan_sh.html">t2017-checkout-orphan.sh</a>
  
    <li><a href="../../git/t/t2018-checkout-branch_sh.html">t2018-checkout-branch.sh</a>
  
    <li><a href="../../git/t/t2019-checkout-ambiguous-ref_sh.html">t2019-checkout-ambiguous-ref.sh</a>
  
    <li><a href="../../git/t/t2020-checkout-detach_sh.html">t2020-checkout-detach.sh</a>
  
    <li><a href="../../git/t/t2021-checkout-overwrite_sh.html">t2021-checkout-overwrite.sh</a>
  
    <li><a href="../../git/t/t2022-checkout-paths_sh.html">t2022-checkout-paths.sh</a>
  
    <li><a href="../../git/t/t2023-checkout-m_sh.html">t2023-checkout-m.sh</a>
  
    <li><a href="../../git/t/t2024-checkout-dwim_sh.html">t2024-checkout-dwim.sh</a>
  
    <li><a href="../../git/t/t2030-unresolve-info_sh.html">t2030-unresolve-info.sh</a>
  
    <li><a href="../../git/t/t2050-git-dir-relative_sh.html">t2050-git-dir-relative.sh</a>
  
    <li><a href="../../git/t/t2100-update-cache-badpath_sh.html">t2100-update-cache-badpath.sh</a>
  
    <li><a href="../../git/t/t2101-update-index-reupdate_sh.html">t2101-update-index-reupdate.sh</a>
  
    <li><a href="../../git/t/t2102-update-index-symlinks_sh.html">t2102-update-index-symlinks.sh</a>
  
    <li><a href="../../git/t/t2103-update-index-ignore-missing_sh.html">t2103-update-index-ignore-missing.sh</a>
  
    <li><a href="../../git/t/t2104-update-index-skip-worktree_sh.html">t2104-update-index-skip-worktree.sh</a>
  
    <li><a href="../../git/t/t2105-update-index-gitfile_sh.html">t2105-update-index-gitfile.sh</a>
  
    <li><a href="../../git/t/t2106-update-index-assume-unchanged_sh.html">t2106-update-index-assume-unchanged.sh</a>
  
    <li><a href="../../git/t/t2107-update-index-basic_sh.html">t2107-update-index-basic.sh</a>
  
    <li><a href="../../git/t/t2200-add-update_sh.html">t2200-add-update.sh</a>
  
    <li><a href="../../git/t/t2201-add-update-typechange_sh.html">t2201-add-update-typechange.sh</a>
  
    <li><a href="../../git/t/t2202-add-addremove_sh.html">t2202-add-addremove.sh</a>
  
    <li><a href="../../git/t/t2203-add-intent_sh.html">t2203-add-intent.sh</a>
  
    <li><a href="../../git/t/t2204-add-ignored_sh.html">t2204-add-ignored.sh</a>
  
    <li><a href="../../git/t/t2300-cd-to-toplevel_sh.html">t2300-cd-to-toplevel.sh</a>
  
    <li><a href="../../git/t/t3000-ls-files-others_sh.html">t3000-ls-files-others.sh</a>
  
    <li><a href="../../git/t/t3001-ls-files-others-exclude_sh.html">t3001-ls-files-others-exclude.sh</a>
  
    <li><a href="../../git/t/t3002-ls-files-dashpath_sh.html">t3002-ls-files-dashpath.sh</a>
  
    <li><a href="../../git/t/t3003-ls-files-exclude_sh.html">t3003-ls-files-exclude.sh</a>
  
    <li><a href="../../git/t/t3004-ls-files-basic_sh.html">t3004-ls-files-basic.sh</a>
  
    <li><a href="../../git/t/t3005-ls-files-relative_sh.html">t3005-ls-files-relative.sh</a>
  
    <li><a href="../../git/t/t3006-ls-files-long_sh.html">t3006-ls-files-long.sh</a>
  
    <li><a href="../../git/t/t3010-ls-files-killed-modified_sh.html">t3010-ls-files-killed-modified.sh</a>
  
    <li><a href="../../git/t/t3020-ls-files-error-unmatch_sh.html">t3020-ls-files-error-unmatch.sh</a>
  
    <li><a href="../../git/t/t3030-merge-recursive_sh.html">t3030-merge-recursive.sh</a>
  
    <li><a href="../../git/t/t3031-merge-criscross_sh.html">t3031-merge-criscross.sh</a>
  
    <li><a href="../../git/t/t3032-merge-recursive-options_sh.html">t3032-merge-recursive-options.sh</a>
  
    <li><a href="../../git/t/t3040-subprojects-basic_sh.html">t3040-subprojects-basic.sh</a>
  
    <li><a href="../../git/t/t3050-subprojects-fetch_sh.html">t3050-subprojects-fetch.sh</a>
  
    <li><a href="../../git/t/t3060-ls-files-with-tree_sh.html">t3060-ls-files-with-tree.sh</a>
  
    <li><a href="../../git/t/t3070-wildmatch_sh.html">t3070-wildmatch.sh</a>
  
    <li><a href="../../git/t/t3100-ls-tree-restrict_sh.html">t3100-ls-tree-restrict.sh</a>
  
    <li><a href="../../git/t/t3101-ls-tree-dirname_sh.html">t3101-ls-tree-dirname.sh</a>
  
    <li><a href="../../git/t/t3102-ls-tree-wildcards_sh.html">t3102-ls-tree-wildcards.sh</a>
  
    <li><a href="../../git/t/t3103-ls-tree-misc_sh.html">t3103-ls-tree-misc.sh</a>
  
    <li><a href="../../git/t/t3200-branch_sh.html">t3200-branch.sh</a>
  
    <li><a href="../../git/t/t3201-branch-contains_sh.html">t3201-branch-contains.sh</a>
  
    <li><a href="../../git/t/t3202-show-branch-octopus_sh.html">t3202-show-branch-octopus.sh</a>
  
    <li><a href="../../git/t/t3203-branch-output_sh.html">t3203-branch-output.sh</a>
  
    <li><a href="../../git/t/t3210-pack-refs_sh.html">t3210-pack-refs.sh</a>
  
    <li><a href="../../git/t/t3211-peel-ref_sh.html">t3211-peel-ref.sh</a>
  
    <li><a href="../../git/t/t3300-funny-names_sh.html">t3300-funny-names.sh</a>
  
    <li><a href="../../git/t/t3301-notes_sh.html">t3301-notes.sh</a>
  
    <li><a href="../../git/t/t3302-notes-index-expensive_sh.html">t3302-notes-index-expensive.sh</a>
  
    <li><a href="../../git/t/t3303-notes-subtrees_sh.html">t3303-notes-subtrees.sh</a>
  
    <li><a href="../../git/t/t3304-notes-mixed_sh.html">t3304-notes-mixed.sh</a>
  
    <li><a href="../../git/t/t3305-notes-fanout_sh.html">t3305-notes-fanout.sh</a>
  
    <li><a href="../../git/t/t3306-notes-prune_sh.html">t3306-notes-prune.sh</a>
  
    <li><a href="../../git/t/t3307-notes-man_sh.html">t3307-notes-man.sh</a>
  
    <li><a href="../../git/t/t3308-notes-merge_sh.html">t3308-notes-merge.sh</a>
  
    <li><a href="../../git/t/t3309-notes-merge-auto-resolve_sh.html">t3309-notes-merge-auto-resolve.sh</a>
  
    <li><a href="../../git/t/t3310-notes-merge-manual-resolve_sh.html">t3310-notes-merge-manual-resolve.sh</a>
  
    <li><a href="../../git/t/t3311-notes-merge-fanout_sh.html">t3311-notes-merge-fanout.sh</a>
  
    <li><a href="../../git/t/t3400-rebase_sh.html">t3400-rebase.sh</a>
  
    <li><a href="../../git/t/t3402-rebase-merge_sh.html">t3402-rebase-merge.sh</a>
  
    <li><a href="../../git/t/t3403-rebase-skip_sh.html">t3403-rebase-skip.sh</a>
  
    <li><a href="../../git/t/t3404-rebase-interactive_sh.html">t3404-rebase-interactive.sh</a>
  
    <li><a href="../../git/t/t3405-rebase-malformed_sh.html">t3405-rebase-malformed.sh</a>
  
    <li><a href="../../git/t/t3406-rebase-message_sh.html">t3406-rebase-message.sh</a>
  
    <li><a href="../../git/t/t3407-rebase-abort_sh.html">t3407-rebase-abort.sh</a>
  
    <li><a href="../../git/t/t3408-rebase-multi-line_sh.html">t3408-rebase-multi-line.sh</a>
  
    <li><a href="../../git/t/t3409-rebase-preserve-merges_sh.html">t3409-rebase-preserve-merges.sh</a>
  
    <li><a href="../../git/t/t3410-rebase-preserve-dropped-merges_sh.html">t3410-rebase-preserve-dropped-merges.sh</a>
  
    <li><a href="../../git/t/t3411-rebase-preserve-around-merges_sh.html">t3411-rebase-preserve-around-merges.sh</a>
  
    <li><a href="../../git/t/t3412-rebase-root_sh.html">t3412-rebase-root.sh</a>
  
    <li><a href="../../git/t/t3413-rebase-hook_sh.html">t3413-rebase-hook.sh</a>
  
    <li><a href="../../git/t/t3414-rebase-preserve-onto_sh.html">t3414-rebase-preserve-onto.sh</a>
  
    <li><a href="../../git/t/t3415-rebase-autosquash_sh.html">t3415-rebase-autosquash.sh</a>
  
    <li><a href="../../git/t/t3416-rebase-onto-threedots_sh.html">t3416-rebase-onto-threedots.sh</a>
  
    <li><a href="../../git/t/t3417-rebase-whitespace-fix_sh.html">t3417-rebase-whitespace-fix.sh</a>
  
    <li><a href="../../git/t/t3418-rebase-continue_sh.html">t3418-rebase-continue.sh</a>
  
    <li><a href="../../git/t/t3419-rebase-patch-id_sh.html">t3419-rebase-patch-id.sh</a>
  
    <li><a href="../../git/t/t3420-rebase-autostash_sh.html">t3420-rebase-autostash.sh</a>
  
    <li><a href="../../git/t/t3421-rebase-topology-linear_sh.html">t3421-rebase-topology-linear.sh</a>
  
    <li><a href="../../git/t/t3425-rebase-topology-merges_sh.html">t3425-rebase-topology-merges.sh</a>
  
    <li><a href="../../git/t/t3500-cherry_sh.html">t3500-cherry.sh</a>
  
    <li><a href="../../git/t/t3501-revert-cherry-pick_sh.html">t3501-revert-cherry-pick.sh</a>
  
    <li><a href="../../git/t/t3502-cherry-pick-merge_sh.html">t3502-cherry-pick-merge.sh</a>
  
    <li><a href="../../git/t/t3503-cherry-pick-root_sh.html">t3503-cherry-pick-root.sh</a>
  
    <li><a href="../../git/t/t3504-cherry-pick-rerere_sh.html">t3504-cherry-pick-rerere.sh</a>
  
    <li><a href="../../git/t/t3505-cherry-pick-empty_sh.html">t3505-cherry-pick-empty.sh</a>
  
    <li><a href="../../git/t/t3506-cherry-pick-ff_sh.html">t3506-cherry-pick-ff.sh</a>
  
    <li><a href="../../git/t/t3507-cherry-pick-conflict_sh.html">t3507-cherry-pick-conflict.sh</a>
  
    <li><a href="../../git/t/t3508-cherry-pick-many-commits_sh.html">t3508-cherry-pick-many-commits.sh</a>
  
    <li><a href="../../git/t/t3509-cherry-pick-merge-df_sh.html">t3509-cherry-pick-merge-df.sh</a>
  
    <li><a href="../../git/t/t3510-cherry-pick-sequence_sh.html">t3510-cherry-pick-sequence.sh</a>
  
    <li><a href="../../git/t/t3511-cherry-pick-x_sh.html">t3511-cherry-pick-x.sh</a>
  
    <li><a href="../../git/t/t3600-rm_sh.html">t3600-rm.sh</a>
  
    <li><a href="../../git/t/t3700-add_sh.html">t3700-add.sh</a>
  
    <li><a href="../../git/t/t3701-add-interactive_sh.html">t3701-add-interactive.sh</a>
  
    <li><a href="../../git/t/t3702-add-edit_sh.html">t3702-add-edit.sh</a>
  
    <li><a href="../../git/t/t3703-add-magic-pathspec_sh.html">t3703-add-magic-pathspec.sh</a>
  
    <li><a href="../../git/t/t3800-mktag_sh.html">t3800-mktag.sh</a>
  
    <li><a href="../../git/t/t3900-i18n-commit_sh.html">t3900-i18n-commit.sh</a>
  
    <li><a href="../../git/t/t3900/1-UTF-8_txt.html">1-UTF-8</a>
  
    <li><a href="../../git/t/t3900/2-UTF-8_txt.html">2-UTF-8</a>
  
    <li><a href="../../git/t/t3900/ISO-2022-JP_txt.html">ISO-2022-JP</a>
  
    <li><a href="../../git/t/t3901-i18n-patch_sh.html">t3901-i18n-patch.sh</a>
  
    <li><a href="../../git/t/t3901-utf8_txt.html">t3901-utf8</a>
  
    <li><a href="../../git/t/t3902-quoted_sh.html">t3902-quoted.sh</a>
  
    <li><a href="../../git/t/t3903-stash_sh.html">t3903-stash.sh</a>
  
    <li><a href="../../git/t/t3904-stash-patch_sh.html">t3904-stash-patch.sh</a>
  
    <li><a href="../../git/t/t3905-stash-include-untracked_sh.html">t3905-stash-include-untracked.sh</a>
  
    <li><a href="../../git/t/t3910-mac-os-precompose_sh.html">t3910-mac-os-precompose.sh</a>
  
    <li><a href="../../git/t/t4000-diff-format_sh.html">t4000-diff-format.sh</a>
  
    <li><a href="../../git/t/t4001-diff-rename_sh.html">t4001-diff-rename.sh</a>
  
    <li><a href="../../git/t/t4002-diff-basic_sh.html">t4002-diff-basic.sh</a>
  
    <li><a href="../../git/t/t4003-diff-rename-1_sh.html">t4003-diff-rename-1.sh</a>
  
    <li><a href="../../git/t/t4004-diff-rename-symlink_sh.html">t4004-diff-rename-symlink.sh</a>
  
    <li><a href="../../git/t/t4005-diff-rename-2_sh.html">t4005-diff-rename-2.sh</a>
  
    <li><a href="../../git/t/t4006-diff-mode_sh.html">t4006-diff-mode.sh</a>
  
    <li><a href="../../git/t/t4007-rename-3_sh.html">t4007-rename-3.sh</a>
  
    <li><a href="../../git/t/t4008-diff-break-rewrite_sh.html">t4008-diff-break-rewrite.sh</a>
  
    <li><a href="../../git/t/t4009-diff-rename-4_sh.html">t4009-diff-rename-4.sh</a>
  
    <li><a href="../../git/t/t4010-diff-pathspec_sh.html">t4010-diff-pathspec.sh</a>
  
    <li><a href="../../git/t/t4011-diff-symlink_sh.html">t4011-diff-symlink.sh</a>
  
    <li><a href="../../git/t/t4012-diff-binary_sh.html">t4012-diff-binary.sh</a>
  
    <li><a href="../../git/t/t4013-diff-various_sh.html">t4013-diff-various.sh</a>
  
    <li><a href="../../git/t/t4013/diff_config_format_subjectprefix_DIFFERENT_PREFIX.html">diff.config_format.subjectprefix_DIFFERENT_PREFIX</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--cc_--patch-with-stat_--summary_master.html">diff.diff-tree_--cc_--patch-with-stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--cc_--patch-with-stat_--summary_side.html">diff.diff-tree_--cc_--patch-with-stat_--summary_side</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--cc_--patch-with-stat_master.html">diff.diff-tree_--cc_--patch-with-stat_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--cc_--stat_--summary_master.html">diff.diff-tree_--cc_--stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--cc_--stat_--summary_side.html">diff.diff-tree_--cc_--stat_--summary_side</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--cc_--stat_master.html">diff.diff-tree_--cc_--stat_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--cc_master.html">diff.diff-tree_--cc_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--patch-with-raw_initial.html">diff.diff-tree_--patch-with-raw_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--patch-with-stat_initial.html">diff.diff-tree_--patch-with-stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_--patch-with-raw_initial.html">diff.diff-tree_--pretty=oneline_--patch-with-raw_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_--patch-with-stat_initial.html">diff.diff-tree_--pretty=oneline_--patch-with-stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_--root_--patch-with-raw_initial.html">diff.diff-tree_--pretty=oneline_--root_--patch-with-raw_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_--root_--patch-with-stat_initial.html">diff.diff-tree_--pretty=oneline_--root_--patch-with-stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_--root_-p_initial.html">diff.diff-tree_--pretty=oneline_--root_-p_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_--root_initial.html">diff.diff-tree_--pretty=oneline_--root_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_-p_initial.html">diff.diff-tree_--pretty=oneline_-p_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty=oneline_initial.html">diff.diff-tree_--pretty=oneline_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--patch-with-raw_initial.html">diff.diff-tree_--pretty_--patch-with-raw_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--patch-with-stat_initial.html">diff.diff-tree_--pretty_--patch-with-stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--patch-with-stat_side.html">diff.diff-tree_--pretty_--patch-with-stat_side</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_--patch-with-raw_initial.html">diff.diff-tree_--pretty_--root_--patch-with-raw_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_--patch-with-stat_initial.html">diff.diff-tree_--pretty_--root_--patch-with-stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_--stat_--summary_initial.html">diff.diff-tree_--pretty_--root_--stat_--summary_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_--stat_initial.html">diff.diff-tree_--pretty_--root_--stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_--summary_-r_initial.html">diff.diff-tree_--pretty_--root_--summary_-r_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_--summary_initial.html">diff.diff-tree_--pretty_--root_--summary_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_-p_initial.html">diff.diff-tree_--pretty_--root_-p_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--root_initial.html">diff.diff-tree_--pretty_--root_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--stat_--summary_initial.html">diff.diff-tree_--pretty_--stat_--summary_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--stat_initial.html">diff.diff-tree_--pretty_--stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_--summary_initial.html">diff.diff-tree_--pretty_--summary_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_-p_initial.html">diff.diff-tree_--pretty_-p_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_-p_side.html">diff.diff-tree_--pretty_-p_side</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_initial.html">diff.diff-tree_--pretty_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--pretty_side.html">diff.diff-tree_--pretty_side</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_--abbrev_initial.html">diff.diff-tree_--root_--abbrev_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_--patch-with-raw_initial.html">diff.diff-tree_--root_--patch-with-raw_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_--patch-with-stat_initial.html">diff.diff-tree_--root_--patch-with-stat_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_-p_initial.html">diff.diff-tree_--root_-p_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_-r_--abbrev=4_initial.html">diff.diff-tree_--root_-r_--abbrev=4_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_-r_--abbrev_initial.html">diff.diff-tree_--root_-r_--abbrev_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_-r_initial.html">diff.diff-tree_--root_-r_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_--root_initial.html">diff.diff-tree_--root_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-c_--abbrev_master.html">diff.diff-tree_-c_--abbrev_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-c_--stat_--summary_master.html">diff.diff-tree_-c_--stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-c_--stat_--summary_side.html">diff.diff-tree_-c_--stat_--summary_side</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-c_--stat_master.html">diff.diff-tree_-c_--stat_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-c_master.html">diff.diff-tree_-c_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-p_-m_master.html">diff.diff-tree_-p_-m_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-p_initial.html">diff.diff-tree_-p_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-p_master.html">diff.diff-tree_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-r_--abbrev=4_initial.html">diff.diff-tree_-r_--abbrev=4_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-r_--abbrev_initial.html">diff.diff-tree_-r_--abbrev_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_-r_initial.html">diff.diff-tree_-r_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_initial.html">diff.diff-tree_initial</a>
  
    <li><a href="../../git/t/t4013/diff_diff-tree_master.html">diff.diff-tree_master</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--abbrev_initial__side.html">diff.diff_--abbrev_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--cached.html">diff.diff_--cached</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--cached_--_file0.html">diff.diff_--cached_--_file0</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--dirstat-by-file_initial_rearrange.html">diff.diff_--dirstat-by-file_initial_rearrange</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--dirstat_initial_rearrange.html">diff.diff_--dirstat_initial_rearrange</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--dirstat_master~1_master~2.html">diff.diff_--dirstat_master~1_master~2</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--name-status_dir2_dir.html">diff.diff_--name-status_dir2_dir</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--no-index_--name-status_--_dir2_dir.html">diff.diff_--no-index_--name-status_--_dir2_dir</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--no-index_--name-status_dir2_dir.html">diff.diff_--no-index_--name-status_dir2_dir</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--no-index_dir_dir3.html">diff.diff_--no-index_dir_dir3</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--patch-with-raw_-r_initial__side.html">diff.diff_--patch-with-raw_-r_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--patch-with-raw_initial__side.html">diff.diff_--patch-with-raw_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--patch-with-stat_-r_initial__side.html">diff.diff_--patch-with-stat_-r_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--patch-with-stat_initial__side.html">diff.diff_--patch-with-stat_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_--stat_initial__side.html">diff.diff_--stat_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_-r_--stat_initial__side.html">diff.diff_-r_--stat_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_-r_initial__side.html">diff.diff_-r_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_initial__side.html">diff.diff_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_diff_master_master^_side.html">diff.diff_master_master^_side</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--attach_--stdout_--suffix=_diff_initial__side.html">diff.format-patch_--attach_--stdout_--suffix=.diff_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--attach_--stdout_initial__master.html">diff.format-patch_--attach_--stdout_initial..master</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--attach_--stdout_initial__master^.html">diff.format-patch_--attach_--stdout_initial..master^</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--attach_--stdout_initial__side.html">diff.format-patch_--attach_--stdout_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--inline_--stdout_--numbered-files_initial__master.html">diff.format-patch_--inline_--stdout_--numbered-files_initial..master</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--inline_--stdout_--subject-prefix=TESTCASE_initial__master.html">diff.format-patch_--inline_--stdout_--subject-prefix=TESTCASE_initial..master</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--inline_--stdout_initial__master.html">diff.format-patch_--inline_--stdout_initial..master</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--inline_--stdout_initial__master^.html">diff.format-patch_--inline_--stdout_initial..master^</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--inline_--stdout_initial__master^^.html">diff.format-patch_--inline_--stdout_initial..master^^</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--inline_--stdout_initial__side.html">diff.format-patch_--inline_--stdout_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--stdout_--cover-letter_-n_initial__master^.html">diff.format-patch_--stdout_--cover-letter_-n_initial..master^</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--stdout_--no-numbered_initial__master.html">diff.format-patch_--stdout_--no-numbered_initial..master</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--stdout_--numbered_initial__master.html">diff.format-patch_--stdout_--numbered_initial..master</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--stdout_initial__master.html">diff.format-patch_--stdout_initial..master</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--stdout_initial__master^.html">diff.format-patch_--stdout_initial..master^</a>
  
    <li><a href="../../git/t/t4013/diff_format-patch_--stdout_initial__side.html">diff.format-patch_--stdout_initial..side</a>
  
    <li><a href="../../git/t/t4013/diff_log_--decorate=full_--all.html">diff.log_--decorate=full_--all</a>
  
    <li><a href="../../git/t/t4013/diff_log_--decorate_--all.html">diff.log_--decorate_--all</a>
  
    <li><a href="../../git/t/t4013/diff_log_--patch-with-stat_--summary_master_--_dir_.html">diff.log_--patch-with-stat_--summary_master_--_dir_</a>
  
    <li><a href="../../git/t/t4013/diff_log_--patch-with-stat_master.html">diff.log_--patch-with-stat_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_--patch-with-stat_master_--_dir_.html">diff.log_--patch-with-stat_master_--_dir_</a>
  
    <li><a href="../../git/t/t4013/diff_log_--root_--cc_--patch-with-stat_--summary_master.html">diff.log_--root_--cc_--patch-with-stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_--root_--patch-with-stat_--summary_master.html">diff.log_--root_--patch-with-stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_--root_--patch-with-stat_master.html">diff.log_--root_--patch-with-stat_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_--root_-c_--patch-with-stat_--summary_master.html">diff.log_--root_-c_--patch-with-stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_--root_-p_master.html">diff.log_--root_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_--root_master.html">diff.log_--root_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-GF_-p_--pickaxe-all_master.html">diff.log_-GF_-p_--pickaxe-all_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-GF_-p_master.html">diff.log_-GF_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-GF_master.html">diff.log_-GF_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-SF_-p_master.html">diff.log_-SF_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-SF_master.html">diff.log_-SF_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-SF_master_--max-count=0.html">diff.log_-SF_master_--max-count=0</a>
  
    <li><a href="../../git/t/t4013/diff_log_-SF_master_--max-count=1.html">diff.log_-SF_master_--max-count=1</a>
  
    <li><a href="../../git/t/t4013/diff_log_-SF_master_--max-count=2.html">diff.log_-SF_master_--max-count=2</a>
  
    <li><a href="../../git/t/t4013/diff_log_-S_F_master.html">diff.log_-S_F_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-m_-p_--first-parent_master.html">diff.log_-m_-p_--first-parent_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-m_-p_master.html">diff.log_-m_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-p_--first-parent_master.html">diff.log_-p_--first-parent_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_-p_master.html">diff.log_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_log_master.html">diff.log_master</a>
  
    <li><a href="../../git/t/t4013/diff_rev-list_--children_HEAD.html">diff.rev-list_--children_HEAD</a>
  
    <li><a href="../../git/t/t4013/diff_rev-list_--parents_HEAD.html">diff.rev-list_--parents_HEAD</a>
  
    <li><a href="../../git/t/t4013/diff_show_--first-parent_master.html">diff.show_--first-parent_master</a>
  
    <li><a href="../../git/t/t4013/diff_show_--patch-with-raw_side.html">diff.show_--patch-with-raw_side</a>
  
    <li><a href="../../git/t/t4013/diff_show_--patch-with-stat_--summary_side.html">diff.show_--patch-with-stat_--summary_side</a>
  
    <li><a href="../../git/t/t4013/diff_show_--patch-with-stat_side.html">diff.show_--patch-with-stat_side</a>
  
    <li><a href="../../git/t/t4013/diff_show_--root_initial.html">diff.show_--root_initial</a>
  
    <li><a href="../../git/t/t4013/diff_show_--stat_--summary_side.html">diff.show_--stat_--summary_side</a>
  
    <li><a href="../../git/t/t4013/diff_show_--stat_side.html">diff.show_--stat_side</a>
  
    <li><a href="../../git/t/t4013/diff_show_-c_master.html">diff.show_-c_master</a>
  
    <li><a href="../../git/t/t4013/diff_show_-m_master.html">diff.show_-m_master</a>
  
    <li><a href="../../git/t/t4013/diff_show_initial.html">diff.show_initial</a>
  
    <li><a href="../../git/t/t4013/diff_show_master.html">diff.show_master</a>
  
    <li><a href="../../git/t/t4013/diff_show_side.html">diff.show_side</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--patch-with-stat_--summary_master_--_dir_.html">diff.whatchanged_--patch-with-stat_--summary_master_--_dir_</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--patch-with-stat_master.html">diff.whatchanged_--patch-with-stat_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--patch-with-stat_master_--_dir_.html">diff.whatchanged_--patch-with-stat_master_--_dir_</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--root_--cc_--patch-with-stat_--summary_master.html">diff.whatchanged_--root_--cc_--patch-with-stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--root_--patch-with-stat_--summary_master.html">diff.whatchanged_--root_--patch-with-stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--root_--patch-with-stat_master.html">diff.whatchanged_--root_--patch-with-stat_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--root_-c_--patch-with-stat_--summary_master.html">diff.whatchanged_--root_-c_--patch-with-stat_--summary_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--root_-p_master.html">diff.whatchanged_--root_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_--root_master.html">diff.whatchanged_--root_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_-SF_-p_master.html">diff.whatchanged_-SF_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_-SF_master.html">diff.whatchanged_-SF_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_-p_master.html">diff.whatchanged_-p_master</a>
  
    <li><a href="../../git/t/t4013/diff_whatchanged_master.html">diff.whatchanged_master</a>
  
    <li><a href="../../git/t/t4014-format-patch_sh.html">t4014-format-patch.sh</a>
  
    <li><a href="../../git/t/t4015-diff-whitespace_sh.html">t4015-diff-whitespace.sh</a>
  
    <li><a href="../../git/t/t4016-diff-quote_sh.html">t4016-diff-quote.sh</a>
  
    <li><a href="../../git/t/t4017-diff-retval_sh.html">t4017-diff-retval.sh</a>
  
    <li><a href="../../git/t/t4018-diff-funcname_sh.html">t4018-diff-funcname.sh</a>
  
    <li><a href="../../git/t/t4019-diff-wserror_sh.html">t4019-diff-wserror.sh</a>
  
    <li><a href="../../git/t/t4020-diff-external_sh.html">t4020-diff-external.sh</a>
  
    <li><a href="../../git/t/t4021-format-patch-numbered_sh.html">t4021-format-patch-numbered.sh</a>
  
    <li><a href="../../git/t/t4022-diff-rewrite_sh.html">t4022-diff-rewrite.sh</a>
  
    <li><a href="../../git/t/t4023-diff-rename-typechange_sh.html">t4023-diff-rename-typechange.sh</a>
  
    <li><a href="../../git/t/t4024-diff-optimize-common_sh.html">t4024-diff-optimize-common.sh</a>
  
    <li><a href="../../git/t/t4025-hunk-header_sh.html">t4025-hunk-header.sh</a>
  
    <li><a href="../../git/t/t4026-color_sh.html">t4026-color.sh</a>
  
    <li><a href="../../git/t/t4027-diff-submodule_sh.html">t4027-diff-submodule.sh</a>
  
    <li><a href="../../git/t/t4028-format-patch-mime-headers_sh.html">t4028-format-patch-mime-headers.sh</a>
  
    <li><a href="../../git/t/t4029-diff-trailing-space_sh.html">t4029-diff-trailing-space.sh</a>
  
    <li><a href="../../git/t/t4030-diff-textconv_sh.html">t4030-diff-textconv.sh</a>
  
    <li><a href="../../git/t/t4031-diff-rewrite-binary_sh.html">t4031-diff-rewrite-binary.sh</a>
  
    <li><a href="../../git/t/t4032-diff-inter-hunk-context_sh.html">t4032-diff-inter-hunk-context.sh</a>
  
    <li><a href="../../git/t/t4033-diff-patience_sh.html">t4033-diff-patience.sh</a>
  
    <li><a href="../../git/t/t4034-diff-words_sh.html">t4034-diff-words.sh</a>
  
    <li><a href="../../git/t/t4034/ada/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/ada/post.html">post</a>
  
    <li><a href="../../git/t/t4034/ada/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/bibtex/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/bibtex/post.html">post</a>
  
    <li><a href="../../git/t/t4034/bibtex/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/cpp/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/cpp/post.html">post</a>
  
    <li><a href="../../git/t/t4034/cpp/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/csharp/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/csharp/post.html">post</a>
  
    <li><a href="../../git/t/t4034/csharp/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/fortran/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/fortran/post.html">post</a>
  
    <li><a href="../../git/t/t4034/fortran/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/html/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/html/post.html">post</a>
  
    <li><a href="../../git/t/t4034/html/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/java/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/java/post.html">post</a>
  
    <li><a href="../../git/t/t4034/java/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/matlab/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/matlab/post.html">post</a>
  
    <li><a href="../../git/t/t4034/matlab/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/objc/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/objc/post.html">post</a>
  
    <li><a href="../../git/t/t4034/objc/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/pascal/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/pascal/post.html">post</a>
  
    <li><a href="../../git/t/t4034/pascal/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/perl/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/perl/post.html">post</a>
  
    <li><a href="../../git/t/t4034/perl/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/php/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/php/post.html">post</a>
  
    <li><a href="../../git/t/t4034/php/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/python/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/python/post.html">post</a>
  
    <li><a href="../../git/t/t4034/python/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/ruby/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/ruby/post.html">post</a>
  
    <li><a href="../../git/t/t4034/ruby/pre.html">pre</a>
  
    <li><a href="../../git/t/t4034/tex/expect.html">expect</a>
  
    <li><a href="../../git/t/t4034/tex/post.html">post</a>
  
    <li><a href="../../git/t/t4034/tex/pre.html">pre</a>
  
    <li><a href="../../git/t/t4035-diff-quiet_sh.html">t4035-diff-quiet.sh</a>
  
    <li><a href="../../git/t/t4036-format-patch-signer-mime_sh.html">t4036-format-patch-signer-mime.sh</a>
  
    <li><a href="../../git/t/t4037-diff-r-t-dirs_sh.html">t4037-diff-r-t-dirs.sh</a>
  
    <li><a href="../../git/t/t4038-diff-combined_sh.html">t4038-diff-combined.sh</a>
  
    <li><a href="../../git/t/t4039-diff-assume-unchanged_sh.html">t4039-diff-assume-unchanged.sh</a>
  
    <li><a href="../../git/t/t4040-whitespace-status_sh.html">t4040-whitespace-status.sh</a>
  
    <li><a href="../../git/t/t4041-diff-submodule-option_sh.html">t4041-diff-submodule-option.sh</a>
  
    <li><a href="../../git/t/t4042-diff-textconv-caching_sh.html">t4042-diff-textconv-caching.sh</a>
  
    <li><a href="../../git/t/t4043-diff-rename-binary_sh.html">t4043-diff-rename-binary.sh</a>
  
    <li><a href="../../git/t/t4044-diff-index-unique-abbrev_sh.html">t4044-diff-index-unique-abbrev.sh</a>
  
    <li><a href="../../git/t/t4045-diff-relative_sh.html">t4045-diff-relative.sh</a>
  
    <li><a href="../../git/t/t4046-diff-unmerged_sh.html">t4046-diff-unmerged.sh</a>
  
    <li><a href="../../git/t/t4047-diff-dirstat_sh.html">t4047-diff-dirstat.sh</a>
  
    <li><a href="../../git/t/t4048-diff-combined-binary_sh.html">t4048-diff-combined-binary.sh</a>
  
    <li><a href="../../git/t/t4049-diff-stat-count_sh.html">t4049-diff-stat-count.sh</a>
  
    <li><a href="../../git/t/t4050-diff-histogram_sh.html">t4050-diff-histogram.sh</a>
  
    <li><a href="../../git/t/t4051-diff-function-context_sh.html">t4051-diff-function-context.sh</a>
  
    <li><a href="../../git/t/t4052-stat-output_sh.html">t4052-stat-output.sh</a>
  
    <li><a href="../../git/t/t4053-diff-no-index_sh.html">t4053-diff-no-index.sh</a>
  
    <li><a href="../../git/t/t4054-diff-bogus-tree_sh.html">t4054-diff-bogus-tree.sh</a>
  
    <li><a href="../../git/t/t4055-diff-context_sh.html">t4055-diff-context.sh</a>
  
    <li><a href="../../git/t/t4100-apply-stat_sh.html">t4100-apply-stat.sh</a>
  
    <li><a href="../../git/t/t4100/t-apply-1_expect.html">t-apply-1.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-1_patch.html">t-apply-1.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-2_expect.html">t-apply-2.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-2_patch.html">t-apply-2.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-3_expect.html">t-apply-3.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-3_patch.html">t-apply-3.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-4_expect.html">t-apply-4.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-4_patch.html">t-apply-4.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-5_expect.html">t-apply-5.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-5_patch.html">t-apply-5.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-6_expect.html">t-apply-6.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-6_patch.html">t-apply-6.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-7_expect.html">t-apply-7.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-7_patch.html">t-apply-7.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-8_expect.html">t-apply-8.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-8_patch.html">t-apply-8.patch</a>
  
    <li><a href="../../git/t/t4100/t-apply-9_expect.html">t-apply-9.expect</a>
  
    <li><a href="../../git/t/t4100/t-apply-9_patch.html">t-apply-9.patch</a>
  
    <li><a href="../../git/t/t4101-apply-nonl_sh.html">t4101-apply-nonl.sh</a>
  
    <li><a href="../../git/t/t4101/diff_0-1.html">diff.0-1</a>
  
    <li><a href="../../git/t/t4101/diff_0-2.html">diff.0-2</a>
  
    <li><a href="../../git/t/t4101/diff_0-3.html">diff.0-3</a>
  
    <li><a href="../../git/t/t4101/diff_1-0.html">diff.1-0</a>
  
    <li><a href="../../git/t/t4101/diff_1-2.html">diff.1-2</a>
  
    <li><a href="../../git/t/t4101/diff_1-3.html">diff.1-3</a>
  
    <li><a href="../../git/t/t4101/diff_2-0.html">diff.2-0</a>
  
    <li><a href="../../git/t/t4101/diff_2-1.html">diff.2-1</a>
  
    <li><a href="../../git/t/t4101/diff_2-3.html">diff.2-3</a>
  
    <li><a href="../../git/t/t4101/diff_3-0.html">diff.3-0</a>
  
    <li><a href="../../git/t/t4101/diff_3-1.html">diff.3-1</a>
  
    <li><a href="../../git/t/t4101/diff_3-2.html">diff.3-2</a>
  
    <li><a href="../../git/t/t4102-apply-rename_sh.html">t4102-apply-rename.sh</a>
  
    <li><a href="../../git/t/t4103-apply-binary_sh.html">t4103-apply-binary.sh</a>
  
    <li><a href="../../git/t/t4104-apply-boundary_sh.html">t4104-apply-boundary.sh</a>
  
    <li><a href="../../git/t/t4105-apply-fuzz_sh.html">t4105-apply-fuzz.sh</a>
  
    <li><a href="../../git/t/t4106-apply-stdin_sh.html">t4106-apply-stdin.sh</a>
  
    <li><a href="../../git/t/t4107-apply-ignore-whitespace_sh.html">t4107-apply-ignore-whitespace.sh</a>
  
    <li><a href="../../git/t/t4108-apply-threeway_sh.html">t4108-apply-threeway.sh</a>
  
    <li><a href="../../git/t/t4109-apply-multifrag_sh.html">t4109-apply-multifrag.sh</a>
  
    <li><a href="../../git/t/t4109/expect-1.html">expect-1</a>
  
    <li><a href="../../git/t/t4109/expect-2.html">expect-2</a>
  
    <li><a href="../../git/t/t4109/expect-3.html">expect-3</a>
  
    <li><a href="../../git/t/t4109/patch1_patch.html">patch1.patch</a>
  
    <li><a href="../../git/t/t4109/patch2_patch.html">patch2.patch</a>
  
    <li><a href="../../git/t/t4109/patch3_patch.html">patch3.patch</a>
  
    <li><a href="../../git/t/t4109/patch4_patch.html">patch4.patch</a>
  
    <li><a href="../../git/t/t4110-apply-scan_sh.html">t4110-apply-scan.sh</a>
  
    <li><a href="../../git/t/t4110/expect.html">expect</a>
  
    <li><a href="../../git/t/t4110/patch1_patch.html">patch1.patch</a>
  
    <li><a href="../../git/t/t4110/patch2_patch.html">patch2.patch</a>
  
    <li><a href="../../git/t/t4110/patch3_patch.html">patch3.patch</a>
  
    <li><a href="../../git/t/t4110/patch4_patch.html">patch4.patch</a>
  
    <li><a href="../../git/t/t4110/patch5_patch.html">patch5.patch</a>
  
    <li><a href="../../git/t/t4111-apply-subdir_sh.html">t4111-apply-subdir.sh</a>
  
    <li><a href="../../git/t/t4112-apply-renames_sh.html">t4112-apply-renames.sh</a>
  
    <li><a href="../../git/t/t4113-apply-ending_sh.html">t4113-apply-ending.sh</a>
  
    <li><a href="../../git/t/t4114-apply-typechange_sh.html">t4114-apply-typechange.sh</a>
  
    <li><a href="../../git/t/t4115-apply-symlink_sh.html">t4115-apply-symlink.sh</a>
  
    <li><a href="../../git/t/t4116-apply-reverse_sh.html">t4116-apply-reverse.sh</a>
  
    <li><a href="../../git/t/t4117-apply-reject_sh.html">t4117-apply-reject.sh</a>
  
    <li><a href="../../git/t/t4118-apply-empty-context_sh.html">t4118-apply-empty-context.sh</a>
  
    <li><a href="../../git/t/t4119-apply-config_sh.html">t4119-apply-config.sh</a>
  
    <li><a href="../../git/t/t4120-apply-popt_sh.html">t4120-apply-popt.sh</a>
  
    <li><a href="../../git/t/t4121-apply-diffs_sh.html">t4121-apply-diffs.sh</a>
  
    <li><a href="../../git/t/t4122-apply-symlink-inside_sh.html">t4122-apply-symlink-inside.sh</a>
  
    <li><a href="../../git/t/t4123-apply-shrink_sh.html">t4123-apply-shrink.sh</a>
  
    <li><a href="../../git/t/t4124-apply-ws-rule_sh.html">t4124-apply-ws-rule.sh</a>
  
    <li><a href="../../git/t/t4125-apply-ws-fuzz_sh.html">t4125-apply-ws-fuzz.sh</a>
  
    <li><a href="../../git/t/t4126-apply-empty_sh.html">t4126-apply-empty.sh</a>
  
    <li><a href="../../git/t/t4127-apply-same-fn_sh.html">t4127-apply-same-fn.sh</a>
  
    <li><a href="../../git/t/t4128-apply-root_sh.html">t4128-apply-root.sh</a>
  
    <li><a href="../../git/t/t4129-apply-samemode_sh.html">t4129-apply-samemode.sh</a>
  
    <li><a href="../../git/t/t4130-apply-criss-cross-rename_sh.html">t4130-apply-criss-cross-rename.sh</a>
  
    <li><a href="../../git/t/t4131-apply-fake-ancestor_sh.html">t4131-apply-fake-ancestor.sh</a>
  
    <li><a href="../../git/t/t4132-apply-removal_sh.html">t4132-apply-removal.sh</a>
  
    <li><a href="../../git/t/t4133-apply-filenames_sh.html">t4133-apply-filenames.sh</a>
  
    <li><a href="../../git/t/t4134-apply-submodule_sh.html">t4134-apply-submodule.sh</a>
  
    <li><a href="../../git/t/t4135-apply-weird-filenames_sh.html">t4135-apply-weird-filenames.sh</a>
  
    <li><a href="../../git/t/t4135/add-plain_diff.html">add-plain.diff</a>
  
    <li><a href="../../git/t/t4135/add-with backslash_diff.html">add-with backslash.diff</a>
  
    <li><a href="../../git/t/t4135/add-with quote_diff.html">add-with quote.diff</a>
  
    <li><a href="../../git/t/t4135/add-with spaces_diff.html">add-with spaces.diff</a>
  
    <li><a href="../../git/t/t4135/add-with tab_diff.html">add-with tab.diff</a>
  
    <li><a href="../../git/t/t4135/damaged-tz_diff.html">damaged-tz.diff</a>
  
    <li><a href="../../git/t/t4135/damaged_diff.html">damaged.diff</a>
  
    <li><a href="../../git/t/t4135/diff-plain_diff.html">diff-plain.diff</a>
  
    <li><a href="../../git/t/t4135/diff-with backslash_diff.html">diff-with backslash.diff</a>
  
    <li><a href="../../git/t/t4135/diff-with quote_diff.html">diff-with quote.diff</a>
  
    <li><a href="../../git/t/t4135/diff-with spaces_diff.html">diff-with spaces.diff</a>
  
    <li><a href="../../git/t/t4135/diff-with tab_diff.html">diff-with tab.diff</a>
  
    <li><a href="../../git/t/t4135/funny-tz_diff.html">funny-tz.diff</a>
  
    <li><a href="../../git/t/t4135/git-plain_diff.html">git-plain.diff</a>
  
    <li><a href="../../git/t/t4135/git-with backslash_diff.html">git-with backslash.diff</a>
  
    <li><a href="../../git/t/t4135/git-with quote_diff.html">git-with quote.diff</a>
  
    <li><a href="../../git/t/t4135/git-with spaces_diff.html">git-with spaces.diff</a>
  
    <li><a href="../../git/t/t4135/git-with tab_diff.html">git-with tab.diff</a>
  
    <li><a href="../../git/t/t4135/make-patches.html">make-patches</a>
  
    <li><a href="../../git/t/t4136-apply-check_sh.html">t4136-apply-check.sh</a>
  
    <li><a href="../../git/t/t4150-am_sh.html">t4150-am.sh</a>
  
    <li><a href="../../git/t/t4151-am-abort_sh.html">t4151-am-abort.sh</a>
  
    <li><a href="../../git/t/t4152-am-subjects_sh.html">t4152-am-subjects.sh</a>
  
    <li><a href="../../git/t/t4200-rerere_sh.html">t4200-rerere.sh</a>
  
    <li><a href="../../git/t/t4202-log_sh.html">t4202-log.sh</a>
  
    <li><a href="../../git/t/t4203-mailmap_sh.html">t4203-mailmap.sh</a>
  
    <li><a href="../../git/t/t4204-patch-id_sh.html">t4204-patch-id.sh</a>
  
    <li><a href="../../git/t/t4205-log-pretty-formats_sh.html">t4205-log-pretty-formats.sh</a>
  
    <li><a href="../../git/t/t4206-log-follow-harder-copies_sh.html">t4206-log-follow-harder-copies.sh</a>
  
    <li><a href="../../git/t/t4207-log-decoration-colors_sh.html">t4207-log-decoration-colors.sh</a>
  
    <li><a href="../../git/t/t4208-log-magic-pathspec_sh.html">t4208-log-magic-pathspec.sh</a>
  
    <li><a href="../../git/t/t4209-log-pickaxe_sh.html">t4209-log-pickaxe.sh</a>
  
    <li><a href="../../git/t/t4210-log-i18n_sh.html">t4210-log-i18n.sh</a>
  
    <li><a href="../../git/t/t4211-line-log_sh.html">t4211-line-log.sh</a>
  
    <li><a href="../../git/t/t4211/expect_beginning-of-file.html">expect.beginning-of-file</a>
  
    <li><a href="../../git/t/t4211/expect_end-of-file.html">expect.end-of-file</a>
  
    <li><a href="../../git/t/t4211/expect_move-support-f.html">expect.move-support-f</a>
  
    <li><a href="../../git/t/t4211/expect_multiple.html">expect.multiple</a>
  
    <li><a href="../../git/t/t4211/expect_multiple-overlapping.html">expect.multiple-overlapping</a>
  
    <li><a href="../../git/t/t4211/expect_multiple-superset.html">expect.multiple-superset</a>
  
    <li><a href="../../git/t/t4211/expect_parallel-change-f-to-main.html">expect.parallel-change-f-to-main</a>
  
    <li><a href="../../git/t/t4211/expect_simple-f.html">expect.simple-f</a>
  
    <li><a href="../../git/t/t4211/expect_simple-f-to-main.html">expect.simple-f-to-main</a>
  
    <li><a href="../../git/t/t4211/expect_simple-main.html">expect.simple-main</a>
  
    <li><a href="../../git/t/t4211/expect_simple-main-to-end.html">expect.simple-main-to-end</a>
  
    <li><a href="../../git/t/t4211/expect_two-ranges.html">expect.two-ranges</a>
  
    <li><a href="../../git/t/t4211/expect_vanishes-early.html">expect.vanishes-early</a>
  
    <li><a href="../../git/t/t4211/history_export.html">history.export</a>
  
    <li><a href="../../git/t/t4212-log-corrupt_sh.html">t4212-log-corrupt.sh</a>
  
    <li><a href="../../git/t/t4252-am-options_sh.html">t4252-am-options.sh</a>
  
    <li><a href="../../git/t/t4252/am-test-1-1.html">am-test-1-1</a>
  
    <li><a href="../../git/t/t4252/am-test-1-2.html">am-test-1-2</a>
  
    <li><a href="../../git/t/t4252/am-test-2-1.html">am-test-2-1</a>
  
    <li><a href="../../git/t/t4252/am-test-2-2.html">am-test-2-2</a>
  
    <li><a href="../../git/t/t4252/am-test-3-1.html">am-test-3-1</a>
  
    <li><a href="../../git/t/t4252/am-test-3-2.html">am-test-3-2</a>
  
    <li><a href="../../git/t/t4252/am-test-4-1.html">am-test-4-1</a>
  
    <li><a href="../../git/t/t4252/am-test-4-2.html">am-test-4-2</a>
  
    <li><a href="../../git/t/t4252/am-test-5-1.html">am-test-5-1</a>
  
    <li><a href="../../git/t/t4252/am-test-5-2.html">am-test-5-2</a>
  
    <li><a href="../../git/t/t4252/am-test-6-1.html">am-test-6-1</a>
  
    <li><a href="../../git/t/t4252/file-1-0.html">file-1-0</a>
  
    <li><a href="../../git/t/t4252/file-2-0.html">file-2-0</a>
  
    <li><a href="../../git/t/t4253-am-keep-cr-dos_sh.html">t4253-am-keep-cr-dos.sh</a>
  
    <li><a href="../../git/t/t4254-am-corrupt_sh.html">t4254-am-corrupt.sh</a>
  
    <li><a href="../../git/t/t4300-merge-tree_sh.html">t4300-merge-tree.sh</a>
  
    <li><a href="../../git/t/t5000-tar-tree_sh.html">t5000-tar-tree.sh</a>
  
    <li><a href="../../git/t/t5001-archive-attr_sh.html">t5001-archive-attr.sh</a>
  
    <li><a href="../../git/t/t5002-archive-attr-pattern_sh.html">t5002-archive-attr-pattern.sh</a>
  
    <li><a href="../../git/t/t5003-archive-zip_sh.html">t5003-archive-zip.sh</a>
  
    <li><a href="../../git/t/t5004-archive-corner-cases_sh.html">t5004-archive-corner-cases.sh</a>
  
    <li><a href="../../git/t/t5100-mailinfo_sh.html">t5100-mailinfo.sh</a>
  
    <li><a href="../../git/t/t5100/empty.html">empty</a>
  
    <li><a href="../../git/t/t5100/info-from_expect.html">info-from.expect</a>
  
    <li><a href="../../git/t/t5100/info-from_in.html">info-from.in</a>
  
    <li><a href="../../git/t/t5100/info0001.html">info0001</a>
  
    <li><a href="../../git/t/t5100/info0002.html">info0002</a>
  
    <li><a href="../../git/t/t5100/info0003.html">info0003</a>
  
    <li><a href="../../git/t/t5100/info0004.html">info0004</a>
  
    <li><a href="../../git/t/t5100/info0005.html">info0005</a>
  
    <li><a href="../../git/t/t5100/info0006.html">info0006</a>
  
    <li><a href="../../git/t/t5100/info0007.html">info0007</a>
  
    <li><a href="../../git/t/t5100/info0008.html">info0008</a>
  
    <li><a href="../../git/t/t5100/info0009.html">info0009</a>
  
    <li><a href="../../git/t/t5100/info0010.html">info0010</a>
  
    <li><a href="../../git/t/t5100/info0011.html">info0011</a>
  
    <li><a href="../../git/t/t5100/info0012.html">info0012</a>
  
    <li><a href="../../git/t/t5100/info0013.html">info0013</a>
  
    <li><a href="../../git/t/t5100/info0014.html">info0014</a>
  
    <li><a href="../../git/t/t5100/info0014--scissors.html">info0014--scissors</a>
  
    <li><a href="../../git/t/t5100/info0015.html">info0015</a>
  
    <li><a href="../../git/t/t5100/info0015--no-inbody-headers.html">info0015--no-inbody-headers</a>
  
    <li><a href="../../git/t/t5100/info0016.html">info0016</a>
  
    <li><a href="../../git/t/t5100/info0016--no-inbody-headers.html">info0016--no-inbody-headers</a>
  
    <li><a href="../../git/t/t5100/info0017.html">info0017</a>
  
    <li><a href="../../git/t/t5100/msg0001.html">msg0001</a>
  
    <li><a href="../../git/t/t5100/msg0002.html">msg0002</a>
  
    <li><a href="../../git/t/t5100/msg0003.html">msg0003</a>
  
    <li><a href="../../git/t/t5100/msg0004.html">msg0004</a>
  
    <li><a href="../../git/t/t5100/msg0005.html">msg0005</a>
  
    <li><a href="../../git/t/t5100/msg0006.html">msg0006</a>
  
    <li><a href="../../git/t/t5100/msg0007.html">msg0007</a>
  
    <li><a href="../../git/t/t5100/msg0008.html">msg0008</a>
  
    <li><a href="../../git/t/t5100/msg0009.html">msg0009</a>
  
    <li><a href="../../git/t/t5100/msg0010.html">msg0010</a>
  
    <li><a href="../../git/t/t5100/msg0011.html">msg0011</a>
  
    <li><a href="../../git/t/t5100/msg0012.html">msg0012</a>
  
    <li><a href="../../git/t/t5100/msg0013.html">msg0013</a>
  
    <li><a href="../../git/t/t5100/msg0014.html">msg0014</a>
  
    <li><a href="../../git/t/t5100/msg0014--scissors.html">msg0014--scissors</a>
  
    <li><a href="../../git/t/t5100/msg0015.html">msg0015</a>
  
    <li><a href="../../git/t/t5100/msg0015--no-inbody-headers.html">msg0015--no-inbody-headers</a>
  
    <li><a href="../../git/t/t5100/msg0016.html">msg0016</a>
  
    <li><a href="../../git/t/t5100/msg0016--no-inbody-headers.html">msg0016--no-inbody-headers</a>
  
    <li><a href="../../git/t/t5100/msg0017.html">msg0017</a>
  
    <li><a href="../../git/t/t5100/nul-b64_in.html">nul-b64.in</a>
  
    <li><a href="../../git/t/t5100/patch0001.html">patch0001</a>
  
    <li><a href="../../git/t/t5100/patch0002.html">patch0002</a>
  
    <li><a href="../../git/t/t5100/patch0003.html">patch0003</a>
  
    <li><a href="../../git/t/t5100/patch0004.html">patch0004</a>
  
    <li><a href="../../git/t/t5100/patch0006.html">patch0006</a>
  
    <li><a href="../../git/t/t5100/patch0007.html">patch0007</a>
  
    <li><a href="../../git/t/t5100/patch0008.html">patch0008</a>
  
    <li><a href="../../git/t/t5100/patch0009.html">patch0009</a>
  
    <li><a href="../../git/t/t5100/patch0010.html">patch0010</a>
  
    <li><a href="../../git/t/t5100/patch0011.html">patch0011</a>
  
    <li><a href="../../git/t/t5100/patch0012.html">patch0012</a>
  
    <li><a href="../../git/t/t5100/patch0013.html">patch0013</a>
  
    <li><a href="../../git/t/t5100/patch0014.html">patch0014</a>
  
    <li><a href="../../git/t/t5100/patch0014--scissors.html">patch0014--scissors</a>
  
    <li><a href="../../git/t/t5100/patch0015.html">patch0015</a>
  
    <li><a href="../../git/t/t5100/patch0015--no-inbody-headers.html">patch0015--no-inbody-headers</a>
  
    <li><a href="../../git/t/t5100/patch0016.html">patch0016</a>
  
    <li><a href="../../git/t/t5100/patch0016--no-inbody-headers.html">patch0016--no-inbody-headers</a>
  
    <li><a href="../../git/t/t5100/patch0017.html">patch0017</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0001.html">rfc2047-info-0001</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0002.html">rfc2047-info-0002</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0003.html">rfc2047-info-0003</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0004.html">rfc2047-info-0004</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0005.html">rfc2047-info-0005</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0006.html">rfc2047-info-0006</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0007.html">rfc2047-info-0007</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0008.html">rfc2047-info-0008</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0009.html">rfc2047-info-0009</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0010.html">rfc2047-info-0010</a>
  
    <li><a href="../../git/t/t5100/rfc2047-info-0011.html">rfc2047-info-0011</a>
  
    <li><a href="../../git/t/t5100/rfc2047-samples_mbox.html">rfc2047-samples.mbox</a>
  
    <li><a href="../../git/t/t5100/sample_mbox.html">sample.mbox</a>
  
    <li><a href="../../git/t/t5150-request-pull_sh.html">t5150-request-pull.sh</a>
  
    <li><a href="../../git/t/t5300-pack-object_sh.html">t5300-pack-object.sh</a>
  
    <li><a href="../../git/t/t5301-sliding-window_sh.html">t5301-sliding-window.sh</a>
  
    <li><a href="../../git/t/t5302-pack-index_sh.html">t5302-pack-index.sh</a>
  
    <li><a href="../../git/t/t5303-pack-corruption-resilience_sh.html">t5303-pack-corruption-resilience.sh</a>
  
    <li><a href="../../git/t/t5304-prune_sh.html">t5304-prune.sh</a>
  
    <li><a href="../../git/t/t5305-include-tag_sh.html">t5305-include-tag.sh</a>
  
    <li><a href="../../git/t/t5306-pack-nobase_sh.html">t5306-pack-nobase.sh</a>
  
    <li><a href="../../git/t/t5307-pack-missing-commit_sh.html">t5307-pack-missing-commit.sh</a>
  
    <li><a href="../../git/t/t5308-pack-detect-duplicates_sh.html">t5308-pack-detect-duplicates.sh</a>
  
    <li><a href="../../git/t/t5309-pack-delta-cycles_sh.html">t5309-pack-delta-cycles.sh</a>
  
    <li><a href="../../git/t/t5400-send-pack_sh.html">t5400-send-pack.sh</a>
  
    <li><a href="../../git/t/t5401-update-hooks_sh.html">t5401-update-hooks.sh</a>
  
    <li><a href="../../git/t/t5402-post-merge-hook_sh.html">t5402-post-merge-hook.sh</a>
  
    <li><a href="../../git/t/t5403-post-checkout-hook_sh.html">t5403-post-checkout-hook.sh</a>
  
    <li><a href="../../git/t/t5404-tracking-branches_sh.html">t5404-tracking-branches.sh</a>
  
    <li><a href="../../git/t/t5405-send-pack-rewind_sh.html">t5405-send-pack-rewind.sh</a>
  
    <li><a href="../../git/t/t5406-remote-rejects_sh.html">t5406-remote-rejects.sh</a>
  
    <li><a href="../../git/t/t5407-post-rewrite-hook_sh.html">t5407-post-rewrite-hook.sh</a>
  
    <li><a href="../../git/t/t5500-fetch-pack_sh.html">t5500-fetch-pack.sh</a>
  
    <li><a href="../../git/t/t5501-fetch-push-alternates_sh.html">t5501-fetch-push-alternates.sh</a>
  
    <li><a href="../../git/t/t5502-quickfetch_sh.html">t5502-quickfetch.sh</a>
  
    <li><a href="../../git/t/t5503-tagfollow_sh.html">t5503-tagfollow.sh</a>
  
    <li><a href="../../git/t/t5504-fetch-receive-strict_sh.html">t5504-fetch-receive-strict.sh</a>
  
    <li><a href="../../git/t/t5505-remote_sh.html">t5505-remote.sh</a>
  
    <li><a href="../../git/t/t5506-remote-groups_sh.html">t5506-remote-groups.sh</a>
  
    <li><a href="../../git/t/t5509-fetch-push-namespaces_sh.html">t5509-fetch-push-namespaces.sh</a>
  
    <li><a href="../../git/t/t5510-fetch_sh.html">t5510-fetch.sh</a>
  
    <li><a href="../../git/t/t5511-refspec_sh.html">t5511-refspec.sh</a>
  
    <li><a href="../../git/t/t5512-ls-remote_sh.html">t5512-ls-remote.sh</a>
  
    <li><a href="../../git/t/t5513-fetch-track_sh.html">t5513-fetch-track.sh</a>
  
    <li><a href="../../git/t/t5514-fetch-multiple_sh.html">t5514-fetch-multiple.sh</a>
  
    <li><a href="../../git/t/t5515-fetch-merge-logic_sh.html">t5515-fetch-merge-logic.sh</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-default.html">fetch.br-branches-default</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-default-merge.html">fetch.br-branches-default-merge</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-default-merge_branches-default.html">fetch.br-branches-default-merge_branches-default</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-default-octopus.html">fetch.br-branches-default-octopus</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-default-octopus_branches-default.html">fetch.br-branches-default-octopus_branches-default</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-default_branches-default.html">fetch.br-branches-default_branches-default</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-one.html">fetch.br-branches-one</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-one-merge.html">fetch.br-branches-one-merge</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-one-merge_branches-one.html">fetch.br-branches-one-merge_branches-one</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-one-octopus.html">fetch.br-branches-one-octopus</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-one-octopus_branches-one.html">fetch.br-branches-one-octopus_branches-one</a>
  
    <li><a href="../../git/t/t5515/fetch_br-branches-one_branches-one.html">fetch.br-branches-one_branches-one</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-explicit.html">fetch.br-config-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-explicit-merge.html">fetch.br-config-explicit-merge</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-explicit-merge_config-explicit.html">fetch.br-config-explicit-merge_config-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-explicit-octopus.html">fetch.br-config-explicit-octopus</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-explicit-octopus_config-explicit.html">fetch.br-config-explicit-octopus_config-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-explicit_config-explicit.html">fetch.br-config-explicit_config-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-glob.html">fetch.br-config-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-glob-merge.html">fetch.br-config-glob-merge</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-glob-merge_config-glob.html">fetch.br-config-glob-merge_config-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-glob-octopus.html">fetch.br-config-glob-octopus</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-glob-octopus_config-glob.html">fetch.br-config-glob-octopus_config-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-config-glob_config-glob.html">fetch.br-config-glob_config-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-explicit.html">fetch.br-remote-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-explicit-merge.html">fetch.br-remote-explicit-merge</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-explicit-merge_remote-explicit.html">fetch.br-remote-explicit-merge_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-explicit-octopus.html">fetch.br-remote-explicit-octopus</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-explicit-octopus_remote-explicit.html">fetch.br-remote-explicit-octopus_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-explicit_remote-explicit.html">fetch.br-remote-explicit_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-glob.html">fetch.br-remote-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-glob-merge.html">fetch.br-remote-glob-merge</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-glob-merge_remote-glob.html">fetch.br-remote-glob-merge_remote-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-glob-octopus.html">fetch.br-remote-glob-octopus</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-glob-octopus_remote-glob.html">fetch.br-remote-glob-octopus_remote-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-remote-glob_remote-glob.html">fetch.br-remote-glob_remote-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig.html">fetch.br-unconfig</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_--tags_____git.html">fetch.br-unconfig_--tags_.._.git</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_____git.html">fetch.br-unconfig_.._.git</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_____git_one.html">fetch.br-unconfig_.._.git_one</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_____git_one_tag_tag-one_tag_tag-three-file.html">fetch.br-unconfig_.._.git_one_tag_tag-one_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_____git_one_two.html">fetch.br-unconfig_.._.git_one_two</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_____git_tag_tag-one-tree_tag_tag-three-file.html">fetch.br-unconfig_.._.git_tag_tag-one-tree_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_____git_tag_tag-one_tag_tag-three.html">fetch.br-unconfig_.._.git_tag_tag-one_tag_tag-three</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_branches-default.html">fetch.br-unconfig_branches-default</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_branches-one.html">fetch.br-unconfig_branches-one</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_config-explicit.html">fetch.br-unconfig_config-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_config-glob.html">fetch.br-unconfig_config-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_remote-explicit.html">fetch.br-unconfig_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_br-unconfig_remote-glob.html">fetch.br-unconfig_remote-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_master.html">fetch.master</a>
  
    <li><a href="../../git/t/t5515/fetch_master_--tags_____git.html">fetch.master_--tags_.._.git</a>
  
    <li><a href="../../git/t/t5515/fetch_master_____git.html">fetch.master_.._.git</a>
  
    <li><a href="../../git/t/t5515/fetch_master_____git_one.html">fetch.master_.._.git_one</a>
  
    <li><a href="../../git/t/t5515/fetch_master_____git_one_tag_tag-one_tag_tag-three-file.html">fetch.master_.._.git_one_tag_tag-one_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/fetch_master_____git_one_two.html">fetch.master_.._.git_one_two</a>
  
    <li><a href="../../git/t/t5515/fetch_master_____git_tag_tag-one-tree_tag_tag-three-file.html">fetch.master_.._.git_tag_tag-one-tree_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/fetch_master_____git_tag_tag-one_tag_tag-three.html">fetch.master_.._.git_tag_tag-one_tag_tag-three</a>
  
    <li><a href="../../git/t/t5515/fetch_master_branches-default.html">fetch.master_branches-default</a>
  
    <li><a href="../../git/t/t5515/fetch_master_branches-one.html">fetch.master_branches-one</a>
  
    <li><a href="../../git/t/t5515/fetch_master_config-explicit.html">fetch.master_config-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_master_config-glob.html">fetch.master_config-glob</a>
  
    <li><a href="../../git/t/t5515/fetch_master_remote-explicit.html">fetch.master_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/fetch_master_remote-glob.html">fetch.master_remote-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-default.html">refs.br-branches-default</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-default-merge.html">refs.br-branches-default-merge</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-default-merge_branches-default.html">refs.br-branches-default-merge_branches-default</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-default-octopus.html">refs.br-branches-default-octopus</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-default-octopus_branches-default.html">refs.br-branches-default-octopus_branches-default</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-default_branches-default.html">refs.br-branches-default_branches-default</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-one.html">refs.br-branches-one</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-one-merge.html">refs.br-branches-one-merge</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-one-merge_branches-one.html">refs.br-branches-one-merge_branches-one</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-one-octopus.html">refs.br-branches-one-octopus</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-one-octopus_branches-one.html">refs.br-branches-one-octopus_branches-one</a>
  
    <li><a href="../../git/t/t5515/refs_br-branches-one_branches-one.html">refs.br-branches-one_branches-one</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-explicit.html">refs.br-config-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-explicit-merge.html">refs.br-config-explicit-merge</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-explicit-merge_config-explicit.html">refs.br-config-explicit-merge_config-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-explicit-octopus.html">refs.br-config-explicit-octopus</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-explicit-octopus_config-explicit.html">refs.br-config-explicit-octopus_config-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-explicit_config-explicit.html">refs.br-config-explicit_config-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-glob.html">refs.br-config-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-glob-merge.html">refs.br-config-glob-merge</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-glob-merge_config-glob.html">refs.br-config-glob-merge_config-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-glob-octopus.html">refs.br-config-glob-octopus</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-glob-octopus_config-glob.html">refs.br-config-glob-octopus_config-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-config-glob_config-glob.html">refs.br-config-glob_config-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-explicit.html">refs.br-remote-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-explicit-merge.html">refs.br-remote-explicit-merge</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-explicit-merge_remote-explicit.html">refs.br-remote-explicit-merge_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-explicit-octopus.html">refs.br-remote-explicit-octopus</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-explicit-octopus_remote-explicit.html">refs.br-remote-explicit-octopus_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-explicit_remote-explicit.html">refs.br-remote-explicit_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-glob.html">refs.br-remote-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-glob-merge.html">refs.br-remote-glob-merge</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-glob-merge_remote-glob.html">refs.br-remote-glob-merge_remote-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-glob-octopus.html">refs.br-remote-glob-octopus</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-glob-octopus_remote-glob.html">refs.br-remote-glob-octopus_remote-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-remote-glob_remote-glob.html">refs.br-remote-glob_remote-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig.html">refs.br-unconfig</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_--tags_____git.html">refs.br-unconfig_--tags_.._.git</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_____git.html">refs.br-unconfig_.._.git</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_____git_one.html">refs.br-unconfig_.._.git_one</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_____git_one_tag_tag-one_tag_tag-three-file.html">refs.br-unconfig_.._.git_one_tag_tag-one_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_____git_one_two.html">refs.br-unconfig_.._.git_one_two</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_____git_tag_tag-one-tree_tag_tag-three-file.html">refs.br-unconfig_.._.git_tag_tag-one-tree_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_____git_tag_tag-one_tag_tag-three.html">refs.br-unconfig_.._.git_tag_tag-one_tag_tag-three</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_branches-default.html">refs.br-unconfig_branches-default</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_branches-one.html">refs.br-unconfig_branches-one</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_config-explicit.html">refs.br-unconfig_config-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_config-glob.html">refs.br-unconfig_config-glob</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_remote-explicit.html">refs.br-unconfig_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_br-unconfig_remote-glob.html">refs.br-unconfig_remote-glob</a>
  
    <li><a href="../../git/t/t5515/refs_master.html">refs.master</a>
  
    <li><a href="../../git/t/t5515/refs_master_--tags_____git.html">refs.master_--tags_.._.git</a>
  
    <li><a href="../../git/t/t5515/refs_master_____git.html">refs.master_.._.git</a>
  
    <li><a href="../../git/t/t5515/refs_master_____git_one.html">refs.master_.._.git_one</a>
  
    <li><a href="../../git/t/t5515/refs_master_____git_one_tag_tag-one_tag_tag-three-file.html">refs.master_.._.git_one_tag_tag-one_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/refs_master_____git_one_two.html">refs.master_.._.git_one_two</a>
  
    <li><a href="../../git/t/t5515/refs_master_____git_tag_tag-one-tree_tag_tag-three-file.html">refs.master_.._.git_tag_tag-one-tree_tag_tag-three-file</a>
  
    <li><a href="../../git/t/t5515/refs_master_____git_tag_tag-one_tag_tag-three.html">refs.master_.._.git_tag_tag-one_tag_tag-three</a>
  
    <li><a href="../../git/t/t5515/refs_master_branches-default.html">refs.master_branches-default</a>
  
    <li><a href="../../git/t/t5515/refs_master_branches-one.html">refs.master_branches-one</a>
  
    <li><a href="../../git/t/t5515/refs_master_config-explicit.html">refs.master_config-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_master_config-glob.html">refs.master_config-glob</a>
  
    <li><a href="../../git/t/t5515/refs_master_remote-explicit.html">refs.master_remote-explicit</a>
  
    <li><a href="../../git/t/t5515/refs_master_remote-glob.html">refs.master_remote-glob</a>
  
    <li><a href="../../git/t/t5516-fetch-push_sh.html">t5516-fetch-push.sh</a>
  
    <li><a href="../../git/t/t5517-push-mirror_sh.html">t5517-push-mirror.sh</a>
  
    <li><a href="../../git/t/t5518-fetch-exit-status_sh.html">t5518-fetch-exit-status.sh</a>
  
    <li><a href="../../git/t/t5519-push-alternates_sh.html">t5519-push-alternates.sh</a>
  
    <li><a href="../../git/t/t5520-pull_sh.html">t5520-pull.sh</a>
  
    <li><a href="../../git/t/t5521-pull-options_sh.html">t5521-pull-options.sh</a>
  
    <li><a href="../../git/t/t5522-pull-symlink_sh.html">t5522-pull-symlink.sh</a>
  
    <li><a href="../../git/t/t5523-push-upstream_sh.html">t5523-push-upstream.sh</a>
  
    <li><a href="../../git/t/t5524-pull-msg_sh.html">t5524-pull-msg.sh</a>
  
    <li><a href="../../git/t/t5525-fetch-tagopt_sh.html">t5525-fetch-tagopt.sh</a>
  
    <li><a href="../../git/t/t5526-fetch-submodules_sh.html">t5526-fetch-submodules.sh</a>
  
    <li><a href="../../git/t/t5527-fetch-odd-refs_sh.html">t5527-fetch-odd-refs.sh</a>
  
    <li><a href="../../git/t/t5528-push-default_sh.html">t5528-push-default.sh</a>
  
    <li><a href="../../git/t/t5530-upload-pack-error_sh.html">t5530-upload-pack-error.sh</a>
  
    <li><a href="../../git/t/t5531-deep-submodule-push_sh.html">t5531-deep-submodule-push.sh</a>
  
    <li><a href="../../git/t/t5532-fetch-proxy_sh.html">t5532-fetch-proxy.sh</a>
  
    <li><a href="../../git/t/t5533-push-cas_sh.html">t5533-push-cas.sh</a>
  
    <li><a href="../../git/t/t5535-fetch-push-symref_sh.html">t5535-fetch-push-symref.sh</a>
  
    <li><a href="../../git/t/t5540-http-push_sh.html">t5540-http-push.sh</a>
  
    <li><a href="../../git/t/t5541-http-push_sh.html">t5541-http-push.sh</a>
  
    <li><a href="../../git/t/t5550-http-fetch_sh.html">t5550-http-fetch.sh</a>
  
    <li><a href="../../git/t/t5551-http-fetch_sh.html">t5551-http-fetch.sh</a>
  
    <li><a href="../../git/t/t5560-http-backend-noserver_sh.html">t5560-http-backend-noserver.sh</a>
  
    <li><a href="../../git/t/t5561-http-backend_sh.html">t5561-http-backend.sh</a>
  
    <li><a href="../../git/t/t556x_common.html">t556x_common</a>
  
    <li><a href="../../git/t/t5570-git-daemon_sh.html">t5570-git-daemon.sh</a>
  
    <li><a href="../../git/t/t5571-pre-push-hook_sh.html">t5571-pre-push-hook.sh</a>
  
    <li><a href="../../git/t/t5600-clone-fail-cleanup_sh.html">t5600-clone-fail-cleanup.sh</a>
  
    <li><a href="../../git/t/t5601-clone_sh.html">t5601-clone.sh</a>
  
    <li><a href="../../git/t/t5602-clone-remote-exec_sh.html">t5602-clone-remote-exec.sh</a>
  
    <li><a href="../../git/t/t5700-clone-reference_sh.html">t5700-clone-reference.sh</a>
  
    <li><a href="../../git/t/t5701-clone-local_sh.html">t5701-clone-local.sh</a>
  
    <li><a href="../../git/t/t5702-clone-options_sh.html">t5702-clone-options.sh</a>
  
    <li><a href="../../git/t/t5704-bundle_sh.html">t5704-bundle.sh</a>
  
    <li><a href="../../git/t/t5705-clone-2gb_sh.html">t5705-clone-2gb.sh</a>
  
    <li><a href="../../git/t/t5706-clone-branch_sh.html">t5706-clone-branch.sh</a>
  
    <li><a href="../../git/t/t5707-clone-detached_sh.html">t5707-clone-detached.sh</a>
  
    <li><a href="../../git/t/t5708-clone-config_sh.html">t5708-clone-config.sh</a>
  
    <li><a href="../../git/t/t5709-clone-refspec_sh.html">t5709-clone-refspec.sh</a>
  
    <li><a href="../../git/t/t5710-info-alternate_sh.html">t5710-info-alternate.sh</a>
  
    <li><a href="../../git/t/t5801-remote-helpers_sh.html">t5801-remote-helpers.sh</a>
  
    <li><a href="../../git/t/t5802-connect-helper_sh.html">t5802-connect-helper.sh</a>
  
    <li><a href="../../git/t/t5900-repo-selection_sh.html">t5900-repo-selection.sh</a>
  
    <li><a href="../../git/t/t6000-rev-list-misc_sh.html">t6000-rev-list-misc.sh</a>
  
    <li><a href="../../git/t/t6001-rev-list-graft_sh.html">t6001-rev-list-graft.sh</a>
  
    <li><a href="../../git/t/t6002-rev-list-bisect_sh.html">t6002-rev-list-bisect.sh</a>
  
    <li><a href="../../git/t/t6003-rev-list-topo-order_sh.html">t6003-rev-list-topo-order.sh</a>
  
    <li><a href="../../git/t/t6004-rev-list-path-optim_sh.html">t6004-rev-list-path-optim.sh</a>
  
    <li><a href="../../git/t/t6005-rev-list-count_sh.html">t6005-rev-list-count.sh</a>
  
    <li><a href="../../git/t/t6006-rev-list-format_sh.html">t6006-rev-list-format.sh</a>
  
    <li><a href="../../git/t/t6007-rev-list-cherry-pick-file_sh.html">t6007-rev-list-cherry-pick-file.sh</a>
  
    <li><a href="../../git/t/t6008-rev-list-submodule_sh.html">t6008-rev-list-submodule.sh</a>
  
    <li><a href="../../git/t/t6009-rev-list-parent_sh.html">t6009-rev-list-parent.sh</a>
  
    <li><a href="../../git/t/t6010-merge-base_sh.html">t6010-merge-base.sh</a>
  
    <li><a href="../../git/t/t6011-rev-list-with-bad-commit_sh.html">t6011-rev-list-with-bad-commit.sh</a>
  
    <li><a href="../../git/t/t6012-rev-list-simplify_sh.html">t6012-rev-list-simplify.sh</a>
  
    <li><a href="../../git/t/t6013-rev-list-reverse-parents_sh.html">t6013-rev-list-reverse-parents.sh</a>
  
    <li><a href="../../git/t/t6014-rev-list-all_sh.html">t6014-rev-list-all.sh</a>
  
    <li><a href="../../git/t/t6015-rev-list-show-all-parents_sh.html">t6015-rev-list-show-all-parents.sh</a>
  
    <li><a href="../../git/t/t6016-rev-list-graph-simplify-history_sh.html">t6016-rev-list-graph-simplify-history.sh</a>
  
    <li><a href="../../git/t/t6017-rev-list-stdin_sh.html">t6017-rev-list-stdin.sh</a>
  
    <li><a href="../../git/t/t6018-rev-list-glob_sh.html">t6018-rev-list-glob.sh</a>
  
    <li><a href="../../git/t/t6019-rev-list-ancestry-path_sh.html">t6019-rev-list-ancestry-path.sh</a>
  
    <li><a href="../../git/t/t6020-merge-df_sh.html">t6020-merge-df.sh</a>
  
    <li><a href="../../git/t/t6021-merge-criss-cross_sh.html">t6021-merge-criss-cross.sh</a>
  
    <li><a href="../../git/t/t6022-merge-rename_sh.html">t6022-merge-rename.sh</a>
  
    <li><a href="../../git/t/t6023-merge-file_sh.html">t6023-merge-file.sh</a>
  
    <li><a href="../../git/t/t6024-recursive-merge_sh.html">t6024-recursive-merge.sh</a>
  
    <li><a href="../../git/t/t6025-merge-symlinks_sh.html">t6025-merge-symlinks.sh</a>
  
    <li><a href="../../git/t/t6026-merge-attr_sh.html">t6026-merge-attr.sh</a>
  
    <li><a href="../../git/t/t6027-merge-binary_sh.html">t6027-merge-binary.sh</a>
  
    <li><a href="../../git/t/t6028-merge-up-to-date_sh.html">t6028-merge-up-to-date.sh</a>
  
    <li><a href="../../git/t/t6029-merge-subtree_sh.html">t6029-merge-subtree.sh</a>
  
    <li><a href="../../git/t/t6030-bisect-porcelain_sh.html">t6030-bisect-porcelain.sh</a>
  
    <li><a href="../../git/t/t6031-merge-recursive_sh.html">t6031-merge-recursive.sh</a>
  
    <li><a href="../../git/t/t6032-merge-large-rename_sh.html">t6032-merge-large-rename.sh</a>
  
    <li><a href="../../git/t/t6033-merge-crlf_sh.html">t6033-merge-crlf.sh</a>
  
    <li><a href="../../git/t/t6034-merge-rename-nocruft_sh.html">t6034-merge-rename-nocruft.sh</a>
  
    <li><a href="../../git/t/t6035-merge-dir-to-symlink_sh.html">t6035-merge-dir-to-symlink.sh</a>
  
    <li><a href="../../git/t/t6036-recursive-corner-cases_sh.html">t6036-recursive-corner-cases.sh</a>
  
    <li><a href="../../git/t/t6037-merge-ours-theirs_sh.html">t6037-merge-ours-theirs.sh</a>
  
    <li><a href="../../git/t/t6038-merge-text-auto_sh.html">t6038-merge-text-auto.sh</a>
  
    <li><a href="../../git/t/t6040-tracking-info_sh.html">t6040-tracking-info.sh</a>
  
    <li><a href="../../git/t/t6042-merge-rename-corner-cases_sh.html">t6042-merge-rename-corner-cases.sh</a>
  
    <li><a href="../../git/t/t6050-replace_sh.html">t6050-replace.sh</a>
  
    <li><a href="../../git/t/t6060-merge-index_sh.html">t6060-merge-index.sh</a>
  
    <li><a href="../../git/t/t6101-rev-parse-parents_sh.html">t6101-rev-parse-parents.sh</a>
  
    <li><a href="../../git/t/t6110-rev-list-sparse_sh.html">t6110-rev-list-sparse.sh</a>
  
    <li><a href="../../git/t/t6111-rev-list-treesame_sh.html">t6111-rev-list-treesame.sh</a>
  
    <li><a href="../../git/t/t6120-describe_sh.html">t6120-describe.sh</a>
  
    <li><a href="../../git/t/t6130-pathspec-noglob_sh.html">t6130-pathspec-noglob.sh</a>
  
    <li><a href="../../git/t/t6131-pathspec-icase_sh.html">t6131-pathspec-icase.sh</a>
  
    <li><a href="../../git/t/t6200-fmt-merge-msg_sh.html">t6200-fmt-merge-msg.sh</a>
  
    <li><a href="../../git/t/t6300-for-each-ref_sh.html">t6300-for-each-ref.sh</a>
  
    <li><a href="../../git/t/t6500-gc_sh.html">t6500-gc.sh</a>
  
    <li><a href="../../git/t/t7001-mv_sh.html">t7001-mv.sh</a>
  
    <li><a href="../../git/t/t7003-filter-branch_sh.html">t7003-filter-branch.sh</a>
  
    <li><a href="../../git/t/t7004-tag_sh.html">t7004-tag.sh</a>
  
    <li><a href="../../git/t/t7005-editor_sh.html">t7005-editor.sh</a>
  
    <li><a href="../../git/t/t7006-pager_sh.html">t7006-pager.sh</a>
  
    <li><a href="../../git/t/t7007-show_sh.html">t7007-show.sh</a>
  
    <li><a href="../../git/t/t7008-grep-binary_sh.html">t7008-grep-binary.sh</a>
  
    <li><a href="../../git/t/t7009-filter-branch-null-sha1_sh.html">t7009-filter-branch-null-sha1.sh</a>
  
    <li><a href="../../git/t/t7010-setup_sh.html">t7010-setup.sh</a>
  
    <li><a href="../../git/t/t7011-skip-worktree-reading_sh.html">t7011-skip-worktree-reading.sh</a>
  
    <li><a href="../../git/t/t7012-skip-worktree-writing_sh.html">t7012-skip-worktree-writing.sh</a>
  
    <li><a href="../../git/t/t7060-wtstatus_sh.html">t7060-wtstatus.sh</a>
  
    <li><a href="../../git/t/t7061-wtstatus-ignore_sh.html">t7061-wtstatus-ignore.sh</a>
  
    <li><a href="../../git/t/t7062-wtstatus-ignorecase_sh.html">t7062-wtstatus-ignorecase.sh</a>
  
    <li><a href="../../git/t/t7101-reset_sh.html">t7101-reset.sh</a>
  
    <li><a href="../../git/t/t7102-reset_sh.html">t7102-reset.sh</a>
  
    <li><a href="../../git/t/t7103-reset-bare_sh.html">t7103-reset-bare.sh</a>
  
    <li><a href="../../git/t/t7104-reset_sh.html">t7104-reset.sh</a>
  
    <li><a href="../../git/t/t7105-reset-patch_sh.html">t7105-reset-patch.sh</a>
  
    <li><a href="../../git/t/t7106-reset-unborn-branch_sh.html">t7106-reset-unborn-branch.sh</a>
  
    <li><a href="../../git/t/t7110-reset-merge_sh.html">t7110-reset-merge.sh</a>
  
    <li><a href="../../git/t/t7111-reset-table_sh.html">t7111-reset-table.sh</a>
  
    <li><a href="../../git/t/t7201-co_sh.html">t7201-co.sh</a>
  
    <li><a href="../../git/t/t7300-clean_sh.html">t7300-clean.sh</a>
  
    <li><a href="../../git/t/t7301-clean-interactive_sh.html">t7301-clean-interactive.sh</a>
  
    <li><a href="../../git/t/t7400-submodule-basic_sh.html">t7400-submodule-basic.sh</a>
  
    <li><a href="../../git/t/t7401-submodule-summary_sh.html">t7401-submodule-summary.sh</a>
  
    <li><a href="../../git/t/t7402-submodule-rebase_sh.html">t7402-submodule-rebase.sh</a>
  
    <li><a href="../../git/t/t7403-submodule-sync_sh.html">t7403-submodule-sync.sh</a>
  
    <li><a href="../../git/t/t7405-submodule-merge_sh.html">t7405-submodule-merge.sh</a>
  
    <li><a href="../../git/t/t7406-submodule-update_sh.html">t7406-submodule-update.sh</a>
  
    <li><a href="../../git/t/t7407-submodule-foreach_sh.html">t7407-submodule-foreach.sh</a>
  
    <li><a href="../../git/t/t7408-submodule-reference_sh.html">t7408-submodule-reference.sh</a>
  
    <li><a href="../../git/t/t7409-submodule-detached-worktree_sh.html">t7409-submodule-detached-worktree.sh</a>
  
    <li><a href="../../git/t/t7500-commit_sh.html">t7500-commit.sh</a>
  
    <li><a href="../../git/t/t7500/add-comments.html">add-comments</a>
  
    <li><a href="../../git/t/t7500/add-content.html">add-content</a>
  
    <li><a href="../../git/t/t7500/add-content-and-comment.html">add-content-and-comment</a>
  
    <li><a href="../../git/t/t7500/add-signed-off.html">add-signed-off</a>
  
    <li><a href="../../git/t/t7500/add-whitespaced-content.html">add-whitespaced-content</a>
  
    <li><a href="../../git/t/t7500/edit-content.html">edit-content</a>
  
    <li><a href="../../git/t/t7501-commit_sh.html">t7501-commit.sh</a>
  
    <li><a href="../../git/t/t7502-commit_sh.html">t7502-commit.sh</a>
  
    <li><a href="../../git/t/t7503-pre-commit-hook_sh.html">t7503-pre-commit-hook.sh</a>
  
    <li><a href="../../git/t/t7504-commit-msg-hook_sh.html">t7504-commit-msg-hook.sh</a>
  
    <li><a href="../../git/t/t7505-prepare-commit-msg-hook_sh.html">t7505-prepare-commit-msg-hook.sh</a>
  
    <li><a href="../../git/t/t7506-status-submodule_sh.html">t7506-status-submodule.sh</a>
  
    <li><a href="../../git/t/t7507-commit-verbose_sh.html">t7507-commit-verbose.sh</a>
  
    <li><a href="../../git/t/t7508-status_sh.html">t7508-status.sh</a>
  
    <li><a href="../../git/t/t7509-commit_sh.html">t7509-commit.sh</a>
  
    <li><a href="../../git/t/t7510-signed-commit_sh.html">t7510-signed-commit.sh</a>
  
    <li><a href="../../git/t/t7511-status-index_sh.html">t7511-status-index.sh</a>
  
    <li><a href="../../git/t/t7512-status-help_sh.html">t7512-status-help.sh</a>
  
    <li><a href="../../git/t/t7600-merge_sh.html">t7600-merge.sh</a>
  
    <li><a href="../../git/t/t7601-merge-pull-config_sh.html">t7601-merge-pull-config.sh</a>
  
    <li><a href="../../git/t/t7602-merge-octopus-many_sh.html">t7602-merge-octopus-many.sh</a>
  
    <li><a href="../../git/t/t7603-merge-reduce-heads_sh.html">t7603-merge-reduce-heads.sh</a>
  
    <li><a href="../../git/t/t7604-merge-custom-message_sh.html">t7604-merge-custom-message.sh</a>
  
    <li><a href="../../git/t/t7605-merge-resolve_sh.html">t7605-merge-resolve.sh</a>
  
    <li><a href="../../git/t/t7606-merge-custom_sh.html">t7606-merge-custom.sh</a>
  
    <li><a href="../../git/t/t7607-merge-overwrite_sh.html">t7607-merge-overwrite.sh</a>
  
    <li><a href="../../git/t/t7608-merge-messages_sh.html">t7608-merge-messages.sh</a>
  
    <li><a href="../../git/t/t7609-merge-co-error-msgs_sh.html">t7609-merge-co-error-msgs.sh</a>
  
    <li><a href="../../git/t/t7610-mergetool_sh.html">t7610-mergetool.sh</a>
  
    <li><a href="../../git/t/t7611-merge-abort_sh.html">t7611-merge-abort.sh</a>
  
    <li><a href="../../git/t/t7612-merge-verify-signatures_sh.html">t7612-merge-verify-signatures.sh</a>
  
    <li><a href="../../git/t/t7700-repack_sh.html">t7700-repack.sh</a>
  
    <li><a href="../../git/t/t7701-repack-unpack-unreachable_sh.html">t7701-repack-unpack-unreachable.sh</a>
  
    <li><a href="../../git/t/t7800-difftool_sh.html">t7800-difftool.sh</a>
  
    <li><a href="../../git/t/t7810-grep_sh.html">t7810-grep.sh</a>
  
    <li><a href="../../git/t/t7811-grep-open_sh.html">t7811-grep-open.sh</a>
  
    <li><a href="../../git/t/t8001-annotate_sh.html">t8001-annotate.sh</a>
  
    <li><a href="../../git/t/t8002-blame_sh.html">t8002-blame.sh</a>
  
    <li><a href="../../git/t/t8003-blame-corner-cases_sh.html">t8003-blame-corner-cases.sh</a>
  
    <li><a href="../../git/t/t8004-blame-with-conflicts_sh.html">t8004-blame-with-conflicts.sh</a>
  
    <li><a href="../../git/t/t8005-blame-i18n_sh.html">t8005-blame-i18n.sh</a>
  
    <li><a href="../../git/t/t8005/utf8_txt.html">utf8</a>
  
    <li><a href="../../git/t/t8006-blame-textconv_sh.html">t8006-blame-textconv.sh</a>
  
    <li><a href="../../git/t/t8007-cat-file-textconv_sh.html">t8007-cat-file-textconv.sh</a>
  
    <li><a href="../../git/t/t8008-blame-formats_sh.html">t8008-blame-formats.sh</a>
  
    <li><a href="../../git/t/t9001-send-email_sh.html">t9001-send-email.sh</a>
  
    <li><a href="../../git/t/t9002-column_sh.html">t9002-column.sh</a>
  
    <li><a href="../../git/t/t9010-svn-fe_sh.html">t9010-svn-fe.sh</a>
  
    <li><a href="../../git/t/t9011-svn-da_sh.html">t9011-svn-da.sh</a>
  
    <li><a href="../../git/t/t9020-remote-svn_sh.html">t9020-remote-svn.sh</a>
  
    <li><a href="../../git/t/t9100-git-svn-basic_sh.html">t9100-git-svn-basic.sh</a>
  
    <li><a href="../../git/t/t9101-git-svn-props_sh.html">t9101-git-svn-props.sh</a>
  
    <li><a href="../../git/t/t9102-git-svn-deep-rmdir_sh.html">t9102-git-svn-deep-rmdir.sh</a>
  
    <li><a href="../../git/t/t9103-git-svn-tracked-directory-removed_sh.html">t9103-git-svn-tracked-directory-removed.sh</a>
  
    <li><a href="../../git/t/t9104-git-svn-follow-parent_sh.html">t9104-git-svn-follow-parent.sh</a>
  
    <li><a href="../../git/t/t9105-git-svn-commit-diff_sh.html">t9105-git-svn-commit-diff.sh</a>
  
    <li><a href="../../git/t/t9106-git-svn-commit-diff-clobber_sh.html">t9106-git-svn-commit-diff-clobber.sh</a>
  
    <li><a href="../../git/t/t9107-git-svn-migrate_sh.html">t9107-git-svn-migrate.sh</a>
  
    <li><a href="../../git/t/t9108-git-svn-glob_sh.html">t9108-git-svn-glob.sh</a>
  
    <li><a href="../../git/t/t9109-git-svn-multi-glob_sh.html">t9109-git-svn-multi-glob.sh</a>
  
    <li><a href="../../git/t/t9110-git-svn-use-svm-props_sh.html">t9110-git-svn-use-svm-props.sh</a>
  
    <li><a href="../../git/t/t9110/svm_dump.html">svm.dump</a>
  
    <li><a href="../../git/t/t9111-git-svn-use-svnsync-props_sh.html">t9111-git-svn-use-svnsync-props.sh</a>
  
    <li><a href="../../git/t/t9111/svnsync_dump.html">svnsync.dump</a>
  
    <li><a href="../../git/t/t9112-git-svn-md5less-file_sh.html">t9112-git-svn-md5less-file.sh</a>
  
    <li><a href="../../git/t/t9113-git-svn-dcommit-new-file_sh.html">t9113-git-svn-dcommit-new-file.sh</a>
  
    <li><a href="../../git/t/t9114-git-svn-dcommit-merge_sh.html">t9114-git-svn-dcommit-merge.sh</a>
  
    <li><a href="../../git/t/t9115-git-svn-dcommit-funky-renames_sh.html">t9115-git-svn-dcommit-funky-renames.sh</a>
  
    <li><a href="../../git/t/t9115/funky-names_dump.html">funky-names.dump</a>
  
    <li><a href="../../git/t/t9116-git-svn-log_sh.html">t9116-git-svn-log.sh</a>
  
    <li><a href="../../git/t/t9117-git-svn-init-clone_sh.html">t9117-git-svn-init-clone.sh</a>
  
    <li><a href="../../git/t/t9118-git-svn-funky-branch-names_sh.html">t9118-git-svn-funky-branch-names.sh</a>
  
    <li><a href="../../git/t/t9119-git-svn-info_sh.html">t9119-git-svn-info.sh</a>
  
    <li><a href="../../git/t/t9120-git-svn-clone-with-percent-escapes_sh.html">t9120-git-svn-clone-with-percent-escapes.sh</a>
  
    <li><a href="../../git/t/t9121-git-svn-fetch-renamed-dir_sh.html">t9121-git-svn-fetch-renamed-dir.sh</a>
  
    <li><a href="../../git/t/t9121/renamed-dir_dump.html">renamed-dir.dump</a>
  
    <li><a href="../../git/t/t9122-git-svn-author_sh.html">t9122-git-svn-author.sh</a>
  
    <li><a href="../../git/t/t9123-git-svn-rebuild-with-rewriteroot_sh.html">t9123-git-svn-rebuild-with-rewriteroot.sh</a>
  
    <li><a href="../../git/t/t9124-git-svn-dcommit-auto-props_sh.html">t9124-git-svn-dcommit-auto-props.sh</a>
  
    <li><a href="../../git/t/t9125-git-svn-multi-glob-branch-names_sh.html">t9125-git-svn-multi-glob-branch-names.sh</a>
  
    <li><a href="../../git/t/t9126-git-svn-follow-deleted-readded-directory_sh.html">t9126-git-svn-follow-deleted-readded-directory.sh</a>
  
    <li><a href="../../git/t/t9126/follow-deleted-readded_dump.html">follow-deleted-readded.dump</a>
  
    <li><a href="../../git/t/t9127-git-svn-partial-rebuild_sh.html">t9127-git-svn-partial-rebuild.sh</a>
  
    <li><a href="../../git/t/t9128-git-svn-cmd-branch_sh.html">t9128-git-svn-cmd-branch.sh</a>
  
    <li><a href="../../git/t/t9129-git-svn-i18n-commitencoding_sh.html">t9129-git-svn-i18n-commitencoding.sh</a>
  
    <li><a href="../../git/t/t9130-git-svn-authors-file_sh.html">t9130-git-svn-authors-file.sh</a>
  
    <li><a href="../../git/t/t9131-git-svn-empty-symlink_sh.html">t9131-git-svn-empty-symlink.sh</a>
  
    <li><a href="../../git/t/t9132-git-svn-broken-symlink_sh.html">t9132-git-svn-broken-symlink.sh</a>
  
    <li><a href="../../git/t/t9133-git-svn-nested-git-repo_sh.html">t9133-git-svn-nested-git-repo.sh</a>
  
    <li><a href="../../git/t/t9134-git-svn-ignore-paths_sh.html">t9134-git-svn-ignore-paths.sh</a>
  
    <li><a href="../../git/t/t9135-git-svn-moved-branch-empty-file_sh.html">t9135-git-svn-moved-branch-empty-file.sh</a>
  
    <li><a href="../../git/t/t9135/svn_dump.html">svn.dump</a>
  
    <li><a href="../../git/t/t9136-git-svn-recreated-branch-empty-file_sh.html">t9136-git-svn-recreated-branch-empty-file.sh</a>
  
    <li><a href="../../git/t/t9136/svn_dump.html">svn.dump</a>
  
    <li><a href="../../git/t/t9137-git-svn-dcommit-clobber-series_sh.html">t9137-git-svn-dcommit-clobber-series.sh</a>
  
    <li><a href="../../git/t/t9138-git-svn-authors-prog_sh.html">t9138-git-svn-authors-prog.sh</a>
  
    <li><a href="../../git/t/t9139-git-svn-non-utf8-commitencoding_sh.html">t9139-git-svn-non-utf8-commitencoding.sh</a>
  
    <li><a href="../../git/t/t9140-git-svn-reset_sh.html">t9140-git-svn-reset.sh</a>
  
    <li><a href="../../git/t/t9141-git-svn-multiple-branches_sh.html">t9141-git-svn-multiple-branches.sh</a>
  
    <li><a href="../../git/t/t9142-git-svn-shallow-clone_sh.html">t9142-git-svn-shallow-clone.sh</a>
  
    <li><a href="../../git/t/t9143-git-svn-gc_sh.html">t9143-git-svn-gc.sh</a>
  
    <li><a href="../../git/t/t9144-git-svn-old-rev_map_sh.html">t9144-git-svn-old-rev_map.sh</a>
  
    <li><a href="../../git/t/t9145-git-svn-master-branch_sh.html">t9145-git-svn-master-branch.sh</a>
  
    <li><a href="../../git/t/t9146-git-svn-empty-dirs_sh.html">t9146-git-svn-empty-dirs.sh</a>
  
    <li><a href="../../git/t/t9147-git-svn-include-paths_sh.html">t9147-git-svn-include-paths.sh</a>
  
    <li><a href="../../git/t/t9150-svk-mergetickets_sh.html">t9150-svk-mergetickets.sh</a>
  
    <li><a href="../../git/t/t9150/make-svk-dump.html">make-svk-dump</a>
  
    <li><a href="../../git/t/t9150/svk-merge_dump.html">svk-merge.dump</a>
  
    <li><a href="../../git/t/t9151-svn-mergeinfo_sh.html">t9151-svn-mergeinfo.sh</a>
  
    <li><a href="../../git/t/t9151/make-svnmerge-dump.html">make-svnmerge-dump</a>
  
    <li><a href="../../git/t/t9151/svn-mergeinfo_dump.html">svn-mergeinfo.dump</a>
  
    <li><a href="../../git/t/t9152-svn-empty-dirs-after-gc_sh.html">t9152-svn-empty-dirs-after-gc.sh</a>
  
    <li><a href="../../git/t/t9153-git-svn-rewrite-uuid_sh.html">t9153-git-svn-rewrite-uuid.sh</a>
  
    <li><a href="../../git/t/t9153/svn_dump.html">svn.dump</a>
  
    <li><a href="../../git/t/t9154-git-svn-fancy-glob_sh.html">t9154-git-svn-fancy-glob.sh</a>
  
    <li><a href="../../git/t/t9154/svn_dump.html">svn.dump</a>
  
    <li><a href="../../git/t/t9155-git-svn-fetch-deleted-tag_sh.html">t9155-git-svn-fetch-deleted-tag.sh</a>
  
    <li><a href="../../git/t/t9156-git-svn-fetch-deleted-tag-2_sh.html">t9156-git-svn-fetch-deleted-tag-2.sh</a>
  
    <li><a href="../../git/t/t9157-git-svn-fetch-merge_sh.html">t9157-git-svn-fetch-merge.sh</a>
  
    <li><a href="../../git/t/t9158-git-svn-mergeinfo_sh.html">t9158-git-svn-mergeinfo.sh</a>
  
    <li><a href="../../git/t/t9159-git-svn-no-parent-mergeinfo_sh.html">t9159-git-svn-no-parent-mergeinfo.sh</a>
  
    <li><a href="../../git/t/t9160-git-svn-preserve-empty-dirs_sh.html">t9160-git-svn-preserve-empty-dirs.sh</a>
  
    <li><a href="../../git/t/t9161-git-svn-mergeinfo-push_sh.html">t9161-git-svn-mergeinfo-push.sh</a>
  
    <li><a href="../../git/t/t9161/branches_dump.html">branches.dump</a>
  
    <li><a href="../../git/t/t9162-git-svn-dcommit-interactive_sh.html">t9162-git-svn-dcommit-interactive.sh</a>
  
    <li><a href="../../git/t/t9163-git-svn-reset-clears-caches_sh.html">t9163-git-svn-reset-clears-caches.sh</a>
  
    <li><a href="../../git/t/t9164-git-svn-dcommit-concurrent_sh.html">t9164-git-svn-dcommit-concurrent.sh</a>
  
    <li><a href="../../git/t/t9165-git-svn-fetch-merge-branch-of-branch_sh.html">t9165-git-svn-fetch-merge-branch-of-branch.sh</a>
  
    <li><a href="../../git/t/t9166-git-svn-fetch-merge-branch-of-branch2_sh.html">t9166-git-svn-fetch-merge-branch-of-branch2.sh</a>
  
    <li><a href="../../git/t/t9167-git-svn-cmd-branch-subproject_sh.html">t9167-git-svn-cmd-branch-subproject.sh</a>
  
    <li><a href="../../git/t/t9200-git-cvsexportcommit_sh.html">t9200-git-cvsexportcommit.sh</a>
  
    <li><a href="../../git/t/t9300-fast-import_sh.html">t9300-fast-import.sh</a>
  
    <li><a href="../../git/t/t9301-fast-import-notes_sh.html">t9301-fast-import-notes.sh</a>
  
    <li><a href="../../git/t/t9350-fast-export_sh.html">t9350-fast-export.sh</a>
  
    <li><a href="../../git/t/t9400-git-cvsserver-server_sh.html">t9400-git-cvsserver-server.sh</a>
  
    <li><a href="../../git/t/t9401-git-cvsserver-crlf_sh.html">t9401-git-cvsserver-crlf.sh</a>
  
    <li><a href="../../git/t/t9402-git-cvsserver-refs_sh.html">t9402-git-cvsserver-refs.sh</a>
  
    <li><a href="../../git/t/t9500-gitweb-standalone-no-errors_sh.html">t9500-gitweb-standalone-no-errors.sh</a>
  
    <li><a href="../../git/t/t9501-gitweb-standalone-http-status_sh.html">t9501-gitweb-standalone-http-status.sh</a>
  
    <li><a href="../../git/t/t9502-gitweb-standalone-parse-output_sh.html">t9502-gitweb-standalone-parse-output.sh</a>
  
    <li><a href="../../git/t/t9600-cvsimport_sh.html">t9600-cvsimport.sh</a>
  
    <li><a href="../../git/t/t9601-cvsimport-vendor-branch_sh.html">t9601-cvsimport-vendor-branch.sh</a>
  
    <li><a href="../../git/t/t9601/cvsroot/module/added-imported_txt,v.html">added-imported.txt,v</a>
  
    <li><a href="../../git/t/t9601/cvsroot/module/imported-anonymously_txt,v.html">imported-anonymously.txt,v</a>
  
    <li><a href="../../git/t/t9601/cvsroot/module/imported-modified-imported_txt,v.html">imported-modified-imported.txt,v</a>
  
    <li><a href="../../git/t/t9601/cvsroot/module/imported-modified_txt,v.html">imported-modified.txt,v</a>
  
    <li><a href="../../git/t/t9601/cvsroot/module/imported-once_txt,v.html">imported-once.txt,v</a>
  
    <li><a href="../../git/t/t9601/cvsroot/module/imported-twice_txt,v.html">imported-twice.txt,v</a>
  
    <li><a href="../../git/t/t9602-cvsimport-branches-tags_sh.html">t9602-cvsimport-branches-tags.sh</a>
  
    <li><a href="../../git/t/t9602/README.html">README</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/default,v.html">default,v</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/sub1/default,v.html">default,v</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/sub1/subsubA/default,v.html">default,v</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/sub1/subsubB/default,v.html">default,v</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/sub2/Attic/branch_B_MIXED_only,v.html">branch_B_MIXED_only,v</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/sub2/default,v.html">default,v</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/sub2/subsubA/default,v.html">default,v</a>
  
    <li><a href="../../git/t/t9602/cvsroot/module/sub3/default,v.html">default,v</a>
  
    <li><a href="../../git/t/t9603-cvsimport-patchsets_sh.html">t9603-cvsimport-patchsets.sh</a>
  
    <li><a href="../../git/t/t9603/cvsroot/module/a,v.html">a,v</a>
  
    <li><a href="../../git/t/t9603/cvsroot/module/b,v.html">b,v</a>
  
    <li><a href="../../git/t/t9604-cvsimport-timestamps_sh.html">t9604-cvsimport-timestamps.sh</a>
  
    <li><a href="../../git/t/t9604/cvsroot/module/a,v.html">a,v</a>
  
    <li><a href="../../git/t/t9700-perl-git_sh.html">t9700-perl-git.sh</a>
  
    <li><a href="../../git/t/t9700/test_pl.html">test.pl</a>
  
    <li><a href="../../git/t/t9800-git-p4-basic_sh.html">t9800-git-p4-basic.sh</a>
  
    <li><a href="../../git/t/t9801-git-p4-branch_sh.html">t9801-git-p4-branch.sh</a>
  
    <li><a href="../../git/t/t9802-git-p4-filetype_sh.html">t9802-git-p4-filetype.sh</a>
  
    <li><a href="../../git/t/t9803-git-p4-shell-metachars_sh.html">t9803-git-p4-shell-metachars.sh</a>
  
    <li><a href="../../git/t/t9804-git-p4-label_sh.html">t9804-git-p4-label.sh</a>
  
    <li><a href="../../git/t/t9805-git-p4-skip-submit-edit_sh.html">t9805-git-p4-skip-submit-edit.sh</a>
  
    <li><a href="../../git/t/t9806-git-p4-options_sh.html">t9806-git-p4-options.sh</a>
  
    <li><a href="../../git/t/t9807-git-p4-submit_sh.html">t9807-git-p4-submit.sh</a>
  
    <li><a href="../../git/t/t9808-git-p4-chdir_sh.html">t9808-git-p4-chdir.sh</a>
  
    <li><a href="../../git/t/t9809-git-p4-client-view_sh.html">t9809-git-p4-client-view.sh</a>
  
    <li><a href="../../git/t/t9810-git-p4-rcs_sh.html">t9810-git-p4-rcs.sh</a>
  
    <li><a href="../../git/t/t9811-git-p4-label-import_sh.html">t9811-git-p4-label-import.sh</a>
  
    <li><a href="../../git/t/t9812-git-p4-wildcards_sh.html">t9812-git-p4-wildcards.sh</a>
  
    <li><a href="../../git/t/t9813-git-p4-preserve-users_sh.html">t9813-git-p4-preserve-users.sh</a>
  
    <li><a href="../../git/t/t9814-git-p4-rename_sh.html">t9814-git-p4-rename.sh</a>
  
    <li><a href="../../git/t/t9815-git-p4-submit-fail_sh.html">t9815-git-p4-submit-fail.sh</a>
  
    <li><a href="../../git/t/t9901-git-web--browse_sh.html">t9901-git-web--browse.sh</a>
  
    <li><a href="../../git/t/t9902-completion_sh.html">t9902-completion.sh</a>
  
    <li><a href="../../git/t/t9903-bash-prompt_sh.html">t9903-bash-prompt.sh</a>
  
    <li><a href="../../git/t/test-lib-functions_sh.html">test-lib-functions.sh</a>
  
    <li><a href="../../git/t/test-lib_sh.html">test-lib.sh</a>
  
    <li><a href="../../git/t/test-terminal_perl.html">test-terminal.perl</a>
  
    <li><a href="../../git/t/valgrind/analyze_sh.html">analyze.sh</a>
  
    <li><a href="../../git/t/valgrind/default_supp.html">default.supp</a>
  
    <li><a href="../../git/t/valgrind/valgrind_sh.html">valgrind.sh</a>
  
    <li><a href="../../git/templates/Makefile.html">Makefile</a>
  
    <li><a href="../../git/templates/branches--.html">branches--</a>
  
    <li><a href="../../git/templates/hooks--applypatch-msg_sample.html">hooks--applypatch-msg.sample</a>
  
    <li><a href="../../git/templates/hooks--commit-msg_sample.html">hooks--commit-msg.sample</a>
  
    <li><a href="../../git/templates/hooks--post-update_sample.html">hooks--post-update.sample</a>
  
    <li><a href="../../git/templates/hooks--pre-applypatch_sample.html">hooks--pre-applypatch.sample</a>
  
    <li><a href="../../git/templates/hooks--pre-commit_sample.html">hooks--pre-commit.sample</a>
  
    <li><a href="../../git/templates/hooks--pre-push_sample.html">hooks--pre-push.sample</a>
  
    <li><a href="../../git/templates/hooks--pre-rebase_sample.html">hooks--pre-rebase.sample</a>
  
    <li><a href="../../git/templates/hooks--prepare-commit-msg_sample.html">hooks--prepare-commit-msg.sample</a>
  
    <li><a href="../../git/templates/hooks--update_sample.html">hooks--update.sample</a>
  
    <li><a href="../../git/templates/info--exclude.html">info--exclude</a>
  
    <li><a href="../../git/templates/this--description.html">this--description</a>
  
    <li><a href="../../git/test-sha1_sh.html">test-sha1.sh</a>
  
    <li><a href="../../git/unimplemented_sh.html">unimplemented.sh</a>
  
    <li><a href="../../git/vcs-svn/LICENSE.html">LICENSE</a>
  
    <li><a href="../../git/vcs-svn/line_buffer_txt.html">line_buffer</a>
  
    <li><a href="../../git/wrap-for-bin_sh.html">wrap-for-bin.sh</a>
  
    <li><a href="../../log/development_log.html">development.log</a>
  
    <li><a href="../../public/404_html.html">404.html</a>
  
    <li><a href="../../public/422_html.html">422.html</a>
  
    <li><a href="../../public/500_html.html">500.html</a>
  
    <li><a href="../../public/favicon_ico.html">favicon.ico</a>
  
    <li><a href="../../public/robots_txt.html">robots</a>
  
    <li><a href="../../tmp/pids/server_pid.html">server.pid</a>
  
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page git/gitk-git/gitk">

<p>#!/bin/sh # Tcl ignores the next line -*- tcl -*- \ exec wish “$0” – “$@”</p>

<p># Copyright © 2005-2011 Paul Mackerras.  All rights reserved. # This
program is free software; it may be used, copied, modified # and
distributed under the terms of the GNU General Public Licence, # either
version 2, or (at your option) any later version.</p>

<p>package require Tk</p>

<p>proc hasworktree {} {</p>

<pre>return [expr {[exec git rev-parse --is-bare-repository] == &quot;false&quot; &amp;&amp;
              [exec git rev-parse --is-inside-git-dir] == &quot;false&quot;}]</pre>

<p>}</p>

<p>proc reponame {} {</p>

<pre>global gitdir
set n [file normalize $gitdir]
if {[string match &quot;  .git&quot; $n]} {
    set n [string range $n 0 end-5]
}
return [file tail $n]</pre>

<p>}</p>

<p>proc gitworktree {} {</p>

<pre>variable _gitworktree
if {[info exists _gitworktree]} {
    return $_gitworktree
}
# v1.7.0 introduced --show-toplevel to return the canonical work-tree
if {[catch {set _gitworktree [exec git rev-parse --show-toplevel]}]} {
    # try to set work tree from environment, core.worktree or use
    # cdup to obtain a relative path to the top of the worktree. If
    # run from the top, the ./ prefix ensures normalize expands pwd.
    if {[catch { set _gitworktree $env(GIT_WORK_TREE) }]} {
        catch {set _gitworktree [exec git config --get core.worktree]}
        if {$_gitworktree eq &quot;&quot;} {
            set _gitworktree [file normalize ./[exec git rev-parse --show-cdup]]
        }
    }
}
return $_gitworktree</pre>

<p>}</p>

<p># A simple scheduler for compute-intensive stuff. # The aim is to make sure
that event handlers for GUI actions can # run at least every 50-100 ms. 
Unfortunately fileevent handlers are # run before X event handlers, so
reading from a fast source can # make the GUI completely unresponsive. proc
run args {</p>

<pre>global isonrunq runq currunq

set script $args
if {[info exists isonrunq($script)]} return
if {$runq eq {} &amp;&amp; ![info exists currunq]} {
    after idle dorunq
}
lappend runq [list {} $script]
set isonrunq($script) 1</pre>

<p>}</p>

<p>proc filerun {fd script} {</p>

<pre>fileevent $fd readable [list filereadable $fd $script]</pre>

<p>}</p>

<p>proc filereadable {fd script} {</p>

<pre>global runq currunq

fileevent $fd readable {}
if {$runq eq {} &amp;&amp; ![info exists currunq]} {
    after idle dorunq
}
lappend runq [list $fd $script]</pre>

<p>}</p>

<p>proc nukefile {fd} {</p>

<pre>global runq

for {set i 0} {$i &lt; [llength $runq]} {} {
    if {[lindex $runq $i 0] eq $fd} {
        set runq [lreplace $runq $i $i]
    } else {
        incr i
    }
}</pre>

<p>}</p>

<p>proc dorunq {} {</p>

<pre>global isonrunq runq currunq

set tstart [clock clicks -milliseconds]
set t0 $tstart
while {[llength $runq] &gt; 0} {
    set fd [lindex $runq 0 0]
    set script [lindex $runq 0 1]
    set currunq [lindex $runq 0]
    set runq [lrange $runq 1 end]
    set repeat [eval $script]
    unset currunq
    set t1 [clock clicks -milliseconds]
    set t [expr {$t1 - $t0}]
    if {$repeat ne {} &amp;&amp; $repeat} {
        if {$fd eq {} || $repeat == 2} {
            # script returns 1 if it wants to be readded
            # file readers return 2 if they could do more straight away
            lappend runq [list $fd $script]
        } else {
            fileevent $fd readable [list filereadable $fd $script]
        }
    } elseif {$fd eq {}} {
        unset isonrunq($script)
    }
    set t0 $t1
    if {$t1 - $tstart &gt;= 80} break
}
if {$runq ne {}} {
    after idle dorunq
}</pre>

<p>}</p>

<p>proc reg_instance {fd} {</p>

<pre>global commfd leftover loginstance

set i [incr loginstance]
set commfd($i) $fd
set leftover($i) {}
return $i</pre>

<p>}</p>

<p>proc unmerged_files {files} {</p>

<pre>global nr_unmerged

# find the list of unmerged files
set mlist {}
set nr_unmerged 0
if {[catch {
    set fd [open &quot;| git ls-files -u&quot; r]
} err]} {
    show_error {} . &quot;[mc &quot;Couldn&#39;t get list of unmerged files:&quot;] $err&quot;
    exit 1
}
while {[gets $fd line] &gt;= 0} {
    set i [string first &quot;\t&quot; $line]
    if {$i &lt; 0} continue
    set fname [string range $line [expr {$i+1}] end]
    if {[lsearch -exact $mlist $fname] &gt;= 0} continue
    incr nr_unmerged
    if {$files eq {} || [path_filter $files $fname]} {
        lappend mlist $fname
    }
}
catch {close $fd}
return $mlist</pre>

<p>}</p>

<p>proc parseviewargs {n arglist} {</p>

<pre>global vdatemode vmergeonly vflags vdflags vrevs vfiltered vorigargs env
global worddiff git_version

set vdatemode($n) 0
set vmergeonly($n) 0
set glflags {}
set diffargs {}
set nextisval 0
set revargs {}
set origargs $arglist
set allknown 1
set filtered 0
set i -1
foreach arg $arglist {
    incr i
    if {$nextisval} {
        lappend glflags $arg
        set nextisval 0
        continue
    }
    switch -glob -- $arg {
        &quot;-d&quot; -
        &quot;--date-order&quot; {
            set vdatemode($n) 1
            # remove from origargs in case we hit an unknown option
            set origargs [lreplace $origargs $i $i]
            incr i -1
        }
        &quot;-[puabwcrRBMC]&quot; -
        &quot;--no-renames&quot; - &quot;--full-index&quot; - &quot;--binary&quot; - &quot;--abbrev=*&quot; -
        &quot;--find-copies-harder&quot; - &quot;-l*&quot; - &quot;--ext-diff&quot; - &quot;--no-ext-diff&quot; -
        &quot;--src-prefix=*&quot; - &quot;--dst-prefix=*&quot; - &quot;--no-prefix&quot; -
        &quot;-O*&quot; - &quot;--text&quot; - &quot;--full-diff&quot; - &quot;--ignore-space-at-eol&quot; -
        &quot;--ignore-space-change&quot; - &quot;-U*&quot; - &quot;--unified=*&quot; {
            # These request or affect diff output, which we don&#39;t want.
            # Some could be used to set our defaults for diff display.
            lappend diffargs $arg
        }
        &quot;--raw&quot; - &quot;--patch-with-raw&quot; - &quot;--patch-with-stat&quot; -
        &quot;--name-only&quot; - &quot;--name-status&quot; - &quot;--color&quot; -
        &quot;--log-size&quot; - &quot;--pretty=*&quot; - &quot;--decorate&quot; - &quot;--abbrev-commit&quot; -
        &quot;--cc&quot; - &quot;-z&quot; - &quot;--header&quot; - &quot;--parents&quot; - &quot;--boundary&quot; -
        &quot;--no-color&quot; - &quot;-g&quot; - &quot;--walk-reflogs&quot; - &quot;--no-walk&quot; -
        &quot;--timestamp&quot; - &quot;relative-date&quot; - &quot;--date=*&quot; - &quot;--stdin&quot; -
        &quot;--objects&quot; - &quot;--objects-edge&quot; - &quot;--reverse&quot; {
            # These cause our parsing of git log&#39;s output to fail, or else
            # they&#39;re options we want to set ourselves, so ignore them.
        }
        &quot;--color-words*&quot; - &quot;--word-diff=color&quot; {
            # These trigger a word diff in the console interface,
            # so help the user by enabling our own support
            if {[package vcompare $git_version &quot;1.7.2&quot;] &gt;= 0} {
                set worddiff [mc &quot;Color words&quot;]
            }
        }
        &quot;--word-diff*&quot; {
            if {[package vcompare $git_version &quot;1.7.2&quot;] &gt;= 0} {
                set worddiff [mc &quot;Markup words&quot;]
            }
        }
        &quot;--stat=*&quot; - &quot;--numstat&quot; - &quot;--shortstat&quot; - &quot;--summary&quot; -
        &quot;--check&quot; - &quot;--exit-code&quot; - &quot;--quiet&quot; - &quot;--topo-order&quot; -
        &quot;--full-history&quot; - &quot;--dense&quot; - &quot;--sparse&quot; -
        &quot;--follow&quot; - &quot;--left-right&quot; - &quot;--encoding=*&quot; {
            # These are harmless, and some are even useful
            lappend glflags $arg
        }
        &quot;--diff-filter=*&quot; - &quot;--no-merges&quot; - &quot;--unpacked&quot; -
        &quot;--max-count=*&quot; - &quot;--skip=*&quot; - &quot;--since=*&quot; - &quot;--after=*&quot; -
        &quot;--until=*&quot; - &quot;--before=*&quot; - &quot;--max-age=*&quot; - &quot;--min-age=*&quot; -
        &quot;--author=*&quot; - &quot;--committer=*&quot; - &quot;--grep=*&quot; - &quot;-[iE]&quot; -
        &quot;--remove-empty&quot; - &quot;--first-parent&quot; - &quot;--cherry-pick&quot; -
        &quot;-S*&quot; - &quot;--pickaxe-all&quot; - &quot;--pickaxe-regex&quot; -
        &quot;--simplify-by-decoration&quot; {
            # These mean that we get a subset of the commits
            set filtered 1
            lappend glflags $arg
        }
        &quot;-n&quot; {
            # This appears to be the only one that has a value as a
            # separate word following it
            set filtered 1
            set nextisval 1
            lappend glflags $arg
        }
        &quot;--not&quot; - &quot;--all&quot; {
            lappend revargs $arg
        }
        &quot;--merge&quot; {
            set vmergeonly($n) 1
            # git rev-parse doesn&#39;t understand --merge
            lappend revargs --gitk-symmetric-diff-marker MERGE_HEAD...HEAD
        }
        &quot;--no-replace-objects&quot; {
            set env(GIT_NO_REPLACE_OBJECTS) &quot;1&quot;
        }
        &quot;-*&quot; {
            # Other flag arguments including -&lt;n&gt;
            if {[string is digit -strict [string range $arg 1 end]]} {
                set filtered 1
            } else {
                # a flag argument that we don&#39;t recognize;
                # that means we can&#39;t optimize
                set allknown 0
            }
            lappend glflags $arg
        }
        default {
            # Non-flag arguments specify commits or ranges of commits
            if {[string match &quot;*...*&quot; $arg]} {
                lappend revargs --gitk-symmetric-diff-marker
            }
            lappend revargs $arg
        }
    }
}
set vdflags($n) $diffargs
set vflags($n) $glflags
set vrevs($n) $revargs
set vfiltered($n) $filtered
set vorigargs($n) $origargs
return $allknown</pre>

<p>}</p>

<p>proc parseviewrevs {view revs} {</p>

<pre>global vposids vnegids

if {$revs eq {}} {
    set revs HEAD
}
if {[catch {set ids [eval exec git rev-parse $revs]} err]} {
    # we get stdout followed by stderr in $err
    # for an unknown rev, git rev-parse echoes it and then errors out
    set errlines [split $err &quot;\n&quot;]
    set badrev {}
    for {set l 0} {$l &lt; [llength $errlines]} {incr l} {
        set line [lindex $errlines $l]
        if {!([string length $line] == 40 &amp;&amp; [string is xdigit $line])} {
            if {[string match &quot;fatal:*&quot; $line]} {
                if {[string match &quot;fatal: ambiguous argument*&quot; $line]
                    &amp;&amp; $badrev ne {}} {
                    if {[llength $badrev] == 1} {
                        set err &quot;unknown revision $badrev&quot;
                    } else {
                        set err &quot;unknown revisions: [join $badrev &quot;, &quot;]&quot;
                    }
                } else {
                    set err [join [lrange $errlines $l end] &quot;\n&quot;]
                }
                break
            }
            lappend badrev $line
        }
    }
    error_popup &quot;[mc &quot;Error parsing revisions:&quot;] $err&quot;
    return {}
}
set ret {}
set pos {}
set neg {}
set sdm 0
foreach id [split $ids &quot;\n&quot;] {
    if {$id eq &quot;--gitk-symmetric-diff-marker&quot;} {
        set sdm 4
    } elseif {[string match &quot;^*&quot; $id]} {
        if {$sdm != 1} {
            lappend ret $id
            if {$sdm == 3} {
                set sdm 0
            }
        }
        lappend neg [string range $id 1 end]
    } else {
        if {$sdm != 2} {
            lappend ret $id
        } else {
            lset ret end $id...[lindex $ret end]
        }
        lappend pos $id
    }
    incr sdm -1
}
set vposids($view) $pos
set vnegids($view) $neg
return $ret</pre>

<p>}</p>

<p># Start off a git log process and arrange to read its output proc
start_rev_list {view} {</p>

<pre>global startmsecs commitidx viewcomplete curview
global tclencoding
global viewargs viewargscmd viewfiles vfilelimit
global showlocalchanges
global viewactive viewinstances vmergeonly
global mainheadid viewmainheadid viewmainheadid_orig
global vcanopt vflags vrevs vorigargs
global show_notes

set startmsecs [clock clicks -milliseconds]
set commitidx($view) 0
# these are set this way for the error exits
set viewcomplete($view) 1
set viewactive($view) 0
varcinit $view

set args $viewargs($view)
if {$viewargscmd($view) ne {}} {
    if {[catch {
        set str [exec sh -c $viewargscmd($view)]
    } err]} {
        error_popup &quot;[mc &quot;Error executing --argscmd command:&quot;] $err&quot;
        return 0
    }
    set args [concat $args [split $str &quot;\n&quot;]]
}
set vcanopt($view) [parseviewargs $view $args]

set files $viewfiles($view)
if {$vmergeonly($view)} {
    set files [unmerged_files $files]
    if {$files eq {}} {
        global nr_unmerged
        if {$nr_unmerged == 0} {
            error_popup [mc &quot;No files selected: --merge specified but\
                         no files are unmerged.&quot;]
        } else {
            error_popup [mc &quot;No files selected: --merge specified but\
                         no unmerged files are within file limit.&quot;]
        }
        return 0
    }
}
set vfilelimit($view) $files

if {$vcanopt($view)} {
    set revs [parseviewrevs $view $vrevs($view)]
    if {$revs eq {}} {
        return 0
    }
    set args [concat $vflags($view) $revs]
} else {
    set args $vorigargs($view)
}

if {[catch {
    set fd [open [concat | git log --no-color -z --pretty=raw $show_notes \
                    --parents --boundary $args &quot;--&quot; $files] r]
} err]} {
    error_popup &quot;[mc &quot;Error executing git log:&quot;] $err&quot;
    return 0
}
set i [reg_instance $fd]
set viewinstances($view) [list $i]
set viewmainheadid($view) $mainheadid
set viewmainheadid_orig($view) $mainheadid
if {$files ne {} &amp;&amp; $mainheadid ne {}} {
    get_viewmainhead $view
}
if {$showlocalchanges &amp;&amp; $viewmainheadid($view) ne {}} {
    interestedin $viewmainheadid($view) dodiffindex
}
fconfigure $fd -blocking 0 -translation lf -eofchar {}
if {$tclencoding != {}} {
    fconfigure $fd -encoding $tclencoding
}
filerun $fd [list getcommitlines $fd $i $view 0]
nowbusy $view [mc &quot;Reading&quot;]
set viewcomplete($view) 0
set viewactive($view) 1
return 1</pre>

<p>}</p>

<p>proc stop_instance {inst} {</p>

<pre>global commfd leftover

set fd $commfd($inst)
catch {
    set pid [pid $fd]

    if {$::tcl_platform(platform) eq {windows}} {
        exec kill -f $pid
    } else {
        exec kill $pid
    }
}
catch {close $fd}
nukefile $fd
unset commfd($inst)
unset leftover($inst)</pre>

<p>}</p>

<p>proc stop_backends {} {</p>

<pre>global commfd

foreach inst [array names commfd] {
    stop_instance $inst
}</pre>

<p>}</p>

<p>proc stop_rev_list {view} {</p>

<pre>global viewinstances

foreach inst $viewinstances($view) {
    stop_instance $inst
}
set viewinstances($view) {}</pre>

<p>}</p>

<p>proc reset_pending_select {selid} {</p>

<pre>global pending_select mainheadid selectheadid

if {$selid ne {}} {
    set pending_select $selid
} elseif {$selectheadid ne {}} {
    set pending_select $selectheadid
} else {
    set pending_select $mainheadid
}</pre>

<p>}</p>

<p>proc getcommits {selid} {</p>

<pre>global canv curview need_redisplay viewactive

initlayout
if {[start_rev_list $curview]} {
    reset_pending_select $selid
    show_status [mc &quot;Reading commits...&quot;]
    set need_redisplay 1
} else {
    show_status [mc &quot;No commits selected&quot;]
}</pre>

<p>}</p>

<p>proc updatecommits {} {</p>

<pre class="ruby"><span class="ruby-identifier">global</span> <span class="ruby-identifier">curview</span> <span class="ruby-identifier">vcanopt</span> <span class="ruby-identifier">vorigargs</span> <span class="ruby-identifier">vfilelimit</span> <span class="ruby-identifier">viewinstances</span>
<span class="ruby-identifier">global</span> <span class="ruby-identifier">viewactive</span> <span class="ruby-identifier">viewcomplete</span> <span class="ruby-identifier">tclencoding</span>
<span class="ruby-identifier">global</span> <span class="ruby-identifier">startmsecs</span> <span class="ruby-identifier">showneartags</span> <span class="ruby-identifier">showlocalchanges</span>
<span class="ruby-identifier">global</span> <span class="ruby-identifier">mainheadid</span> <span class="ruby-identifier">viewmainheadid</span> <span class="ruby-identifier">viewmainheadid_orig</span> <span class="ruby-identifier">pending_select</span>
<span class="ruby-identifier">global</span> <span class="ruby-identifier">hasworktree</span>
<span class="ruby-identifier">global</span> <span class="ruby-identifier">varcid</span> <span class="ruby-identifier">vposids</span> <span class="ruby-identifier">vnegids</span> <span class="ruby-identifier">vflags</span> <span class="ruby-identifier">vrevs</span>
<span class="ruby-identifier">global</span> <span class="ruby-identifier">show_notes</span>

<span class="ruby-identifier">set</span> <span class="ruby-identifier">hasworktree</span> [<span class="ruby-identifier">hasworktree</span>]
<span class="ruby-identifier">rereadrefs</span>
<span class="ruby-identifier">set</span> <span class="ruby-identifier">view</span> <span class="ruby-identifier">$curview</span>
<span class="ruby-keyword">if</span> {<span class="ruby-identifier">$mainheadid</span> <span class="ruby-identifier">ne</span> <span class="ruby-identifier">$viewmainheadid_orig</span>(<span class="ruby-identifier">$view</span>)} {
    <span class="ruby-keyword">if</span> {<span class="ruby-identifier">$showlocalchanges</span>} {
        <span class="ruby-identifier">dohidelocalchanges</span>
    }
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">viewmainheadid</span>(<span class="ruby-identifier">$view</span>) <span class="ruby-identifier">$mainheadid</span>
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">viewmainheadid_orig</span>(<span class="ruby-identifier">$view</span>) <span class="ruby-identifier">$mainheadid</span>
    <span class="ruby-keyword">if</span> {<span class="ruby-identifier">$vfilelimit</span>(<span class="ruby-identifier">$view</span>) <span class="ruby-identifier">ne</span> {}} {
        <span class="ruby-identifier">get_viewmainhead</span> <span class="ruby-identifier">$view</span>
    }
}
<span class="ruby-keyword">if</span> {<span class="ruby-identifier">$showlocalchanges</span>} {
    <span class="ruby-identifier">doshowlocalchanges</span>
}
<span class="ruby-keyword">if</span> {<span class="ruby-identifier">$vcanopt</span>(<span class="ruby-identifier">$view</span>)} {
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">oldpos</span> <span class="ruby-identifier">$vposids</span>(<span class="ruby-identifier">$view</span>)
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">oldneg</span> <span class="ruby-identifier">$vnegids</span>(<span class="ruby-identifier">$view</span>)
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">revs</span> [<span class="ruby-identifier">parseviewrevs</span> <span class="ruby-identifier">$view</span> <span class="ruby-identifier">$vrevs</span>(<span class="ruby-identifier">$view</span>)]
    <span class="ruby-keyword">if</span> {<span class="ruby-identifier">$revs</span> <span class="ruby-identifier">eq</span> {}} {
        <span class="ruby-keyword">return</span>
    }
    <span class="ruby-comment"># note: getting the delta when negative refs change is hard,</span>
    <span class="ruby-comment"># and could require multiple git log invocations, so in that</span>
    <span class="ruby-comment"># case we ask git log for all the commits (not just the delta)</span>
    <span class="ruby-keyword">if</span> {<span class="ruby-identifier">$oldneg</span> <span class="ruby-identifier">eq</span> <span class="ruby-identifier">$vnegids</span>(<span class="ruby-identifier">$view</span>)} {
        <span class="ruby-identifier">set</span> <span class="ruby-identifier">newrevs</span> {}
        <span class="ruby-identifier">set</span> <span class="ruby-identifier">npos</span> <span class="ruby-value">0</span>
        <span class="ruby-comment"># take out positive refs that we asked for before or</span>
        <span class="ruby-comment"># that we have already seen</span>
        <span class="ruby-identifier">foreach</span> <span class="ruby-identifier">rev</span> <span class="ruby-identifier">$revs</span> {
            <span class="ruby-keyword">if</span> {[<span class="ruby-identifier">string</span> <span class="ruby-identifier">length</span> <span class="ruby-identifier">$rev</span>] <span class="ruby-operator">==</span> <span class="ruby-value">40</span>} {
                <span class="ruby-keyword">if</span> {[<span class="ruby-identifier">lsearch</span> <span class="ruby-operator">-</span><span class="ruby-identifier">exact</span> <span class="ruby-identifier">$oldpos</span> <span class="ruby-identifier">$rev</span>] <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>
                    <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>[<span class="ruby-identifier">info</span> <span class="ruby-identifier">exists</span> <span class="ruby-identifier">varcid</span>(<span class="ruby-identifier">$view</span>,<span class="ruby-identifier">$rev</span>)]} {
                    <span class="ruby-identifier">lappend</span> <span class="ruby-identifier">newrevs</span> <span class="ruby-identifier">$rev</span>
                    <span class="ruby-identifier">incr</span> <span class="ruby-identifier">npos</span>
                }
            } <span class="ruby-keyword">else</span> {
                <span class="ruby-identifier">lappend</span> <span class="ruby-identifier">$newrevs</span> <span class="ruby-identifier">$rev</span>
            }
        }
        <span class="ruby-keyword">if</span> {<span class="ruby-identifier">$npos</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>} <span class="ruby-keyword">return</span>
        <span class="ruby-identifier">set</span> <span class="ruby-identifier">revs</span> <span class="ruby-identifier">$newrevs</span>
        <span class="ruby-identifier">set</span> <span class="ruby-identifier">vposids</span>(<span class="ruby-identifier">$view</span>) [<span class="ruby-identifier">lsort</span> <span class="ruby-operator">-</span><span class="ruby-identifier">unique</span> [<span class="ruby-identifier">concat</span> <span class="ruby-identifier">$oldpos</span> <span class="ruby-identifier">$vposids</span>(<span class="ruby-identifier">$view</span>)]]
    }
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">args</span> [<span class="ruby-identifier">concat</span> <span class="ruby-identifier">$vflags</span>(<span class="ruby-identifier">$view</span>) <span class="ruby-identifier">$revs</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-keyword">not</span> <span class="ruby-identifier">$oldpos</span>]
} <span class="ruby-keyword">else</span> {
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">args</span> <span class="ruby-identifier">$vorigargs</span>(<span class="ruby-identifier">$view</span>)
}
<span class="ruby-keyword">if</span> {[<span class="ruby-identifier">catch</span> {
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">fd</span> [<span class="ruby-identifier">open</span> [<span class="ruby-identifier">concat</span> <span class="ruby-operator">|</span> <span class="ruby-identifier">git</span> <span class="ruby-identifier">log</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-identifier">no</span><span class="ruby-operator">-</span><span class="ruby-identifier">color</span> <span class="ruby-operator">-</span><span class="ruby-identifier">z</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-identifier">pretty</span>=<span class="ruby-identifier">raw</span> <span class="ruby-identifier">$show_notes</span>                      <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-identifier">parents</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-identifier">boundary</span> <span class="ruby-identifier">$args</span> <span class="ruby-string">&quot;--&quot;</span> <span class="ruby-identifier">$vfilelimit</span>(<span class="ruby-identifier">$view</span>)] <span class="ruby-identifier">r</span>]
} <span class="ruby-identifier">err</span>]} {
    <span class="ruby-identifier">error_popup</span> <span class="ruby-string">&quot;[mc &quot;</span><span class="ruby-constant">Error</span> <span class="ruby-identifier">executing</span> <span class="ruby-identifier">git</span> <span class="ruby-identifier">log</span><span class="ruby-operator">:</span><span class="ruby-string">&quot;] $err&quot;</span>
    <span class="ruby-keyword">return</span>
}
<span class="ruby-keyword">if</span> {<span class="ruby-identifier">$viewactive</span>(<span class="ruby-identifier">$view</span>) <span class="ruby-operator">==</span> <span class="ruby-value">0</span>} {
    <span class="ruby-identifier">set</span> <span class="ruby-identifier">startmsecs</span> [<span class="ruby-identifier">clock</span> <span class="ruby-identifier">clicks</span> <span class="ruby-operator">-</span><span class="ruby-identifier">milliseconds</span>]
}
<span class="ruby-identifier">set</span> <span class="ruby-identifier">i</span> [<span class="ruby-identifier">reg_instance</span> <span class="ruby-identifier">$fd</span>]
<span class="ruby-identifier">lappend</span> <span class="ruby-identifier">viewinstances</span>(<span class="ruby-identifier">$view</span>) <span class="ruby-identifier">$i</span>
<span class="ruby-identifier">fconfigure</span> <span class="ruby-identifier">$fd</span> <span class="ruby-operator">-</span><span class="ruby-identifier">blocking</span> <span class="ruby-value">0</span> <span class="ruby-operator">-</span><span class="ruby-identifier">translation</span> <span class="ruby-identifier">lf</span> <span class="ruby-operator">-</span><span class="ruby-identifier">eofchar</span> {}
<span class="ruby-keyword">if</span> {<span class="ruby-identifier">$tclencoding</span> <span class="ruby-operator">!=</span> {}} {
    <span class="ruby-identifier">fconfigure</span> <span class="ruby-identifier">$fd</span> <span class="ruby-operator">-</span><span class="ruby-identifier">encoding</span> <span class="ruby-identifier">$tclencoding</span>
}
<span class="ruby-identifier">filerun</span> <span class="ruby-identifier">$fd</span> [<span class="ruby-identifier">list</span> <span class="ruby-identifier">getcommitlines</span> <span class="ruby-identifier">$fd</span> <span class="ruby-identifier">$i</span> <span class="ruby-identifier">$view</span> <span class="ruby-value">1</span>]
<span class="ruby-identifier">incr</span> <span class="ruby-identifier">viewactive</span>(<span class="ruby-identifier">$view</span>)
<span class="ruby-identifier">set</span> <span class="ruby-identifier">viewcomplete</span>(<span class="ruby-identifier">$view</span>) <span class="ruby-value">0</span>
<span class="ruby-identifier">reset_pending_select</span> {}
<span class="ruby-identifier">nowbusy</span> <span class="ruby-identifier">$view</span> [<span class="ruby-identifier">mc</span> <span class="ruby-string">&quot;Reading&quot;</span>]
<span class="ruby-keyword">if</span> {<span class="ruby-identifier">$showneartags</span>} {
    <span class="ruby-identifier">getallcommits</span>
}
</pre>

<p>}</p>

<p>proc reloadcommits {} {</p>

<pre>global curview viewcomplete selectedline currentid thickerline
global showneartags treediffs commitinterest cached_commitrow
global targetid

set selid {}
if {$selectedline ne {}} {
    set selid $currentid
}

if {!$viewcomplete($curview)} {
    stop_rev_list $curview
}
resetvarcs $curview
set selectedline {}
catch {unset currentid}
catch {unset thickerline}
catch {unset treediffs}
readrefs
changedrefs
if {$showneartags} {
    getallcommits
}
clear_display
catch {unset commitinterest}
catch {unset cached_commitrow}
catch {unset targetid}
setcanvscroll
getcommits $selid
return 0</pre>

<p>}</p>

<p># This makes a string representation of a positive integer which # sorts as
a string in numerical order proc strrep {n} {</p>

<pre>if {$n &lt; 16} {
    return [format &quot;%x&quot; $n]
} elseif {$n &lt; 256} {
    return [format &quot;x%.2x&quot; $n]
} elseif {$n &lt; 65536} {
    return [format &quot;y%.4x&quot; $n]
}
return [format &quot;z%.8x&quot; $n]</pre>

<p>}</p>

<p># Procedures used in reordering commits from git log (without #
–topo-order) into the order for display.</p>

<p>proc varcinit {view} {</p>

<pre>global varcstart vupptr vdownptr vleftptr vbackptr varctok varcrow
global vtokmod varcmod vrowmod varcix vlastins

set varcstart($view) {{}}
set vupptr($view) {0}
set vdownptr($view) {0}
set vleftptr($view) {0}
set vbackptr($view) {0}
set varctok($view) {{}}
set varcrow($view) {{}}
set vtokmod($view) {}
set varcmod($view) 0
set vrowmod($view) 0
set varcix($view) {{}}
set vlastins($view) {0}</pre>

<p>}</p>

<p>proc resetvarcs {view} {</p>

<pre>global varcid varccommits parents children vseedcount ordertok
global vshortids

foreach vid [array names varcid $view,*] {
    unset varcid($vid)
    unset children($vid)
    unset parents($vid)
}
foreach vid [array names vshortids $view,*] {
    unset vshortids($vid)
}
# some commits might have children but haven&#39;t been seen yet
foreach vid [array names children $view,*] {
    unset children($vid)
}
foreach va [array names varccommits $view,*] {
    unset varccommits($va)
}
foreach vd [array names vseedcount $view,*] {
    unset vseedcount($vd)
}
catch {unset ordertok}</pre>

<p>}</p>

<p># returns a list of the commits with no children proc seeds {v} {</p>

<pre>global vdownptr vleftptr varcstart

set ret {}
set a [lindex $vdownptr($v) 0]
while {$a != 0} {
    lappend ret [lindex $varcstart($v) $a]
    set a [lindex $vleftptr($v) $a]
}
return $ret</pre>

<p>}</p>

<p>proc newvarc {view id} {</p>

<pre>global varcid varctok parents children vdatemode
global vupptr vdownptr vleftptr vbackptr varcrow varcix varcstart
global commitdata commitinfo vseedcount varccommits vlastins

set a [llength $varctok($view)]
set vid $view,$id
if {[llength $children($vid)] == 0 || $vdatemode($view)} {
    if {![info exists commitinfo($id)]} {
        parsecommit $id $commitdata($id) 1
    }
    set cdate [lindex [lindex $commitinfo($id) 4] 0]
    if {![string is integer -strict $cdate]} {
        set cdate 0
    }
    if {![info exists vseedcount($view,$cdate)]} {
        set vseedcount($view,$cdate) -1
    }
    set c [incr vseedcount($view,$cdate)]
    set cdate [expr {$cdate ^ 0xffffffff}]
    set tok &quot;s[strrep $cdate][strrep $c]&quot;
} else {
    set tok {}
}
set ka 0
if {[llength $children($vid)] &gt; 0} {
    set kid [lindex $children($vid) end]
    set k $varcid($view,$kid)
    if {[string compare [lindex $varctok($view) $k] $tok] &gt; 0} {
        set ki $kid
        set ka $k
        set tok [lindex $varctok($view) $k]
    }
}
if {$ka != 0} {
    set i [lsearch -exact $parents($view,$ki) $id]
    set j [expr {[llength $parents($view,$ki)] - 1 - $i}]
    append tok [strrep $j]
}
set c [lindex $vlastins($view) $ka]
if {$c == 0 || [string compare $tok [lindex $varctok($view) $c]] &lt; 0} {
    set c $ka
    set b [lindex $vdownptr($view) $ka]
} else {
    set b [lindex $vleftptr($view) $c]
}
while {$b != 0 &amp;&amp; [string compare $tok [lindex $varctok($view) $b]] &gt;= 0} {
    set c $b
    set b [lindex $vleftptr($view) $c]
}
if {$c == $ka} {
    lset vdownptr($view) $ka $a
    lappend vbackptr($view) 0
} else {
    lset vleftptr($view) $c $a
    lappend vbackptr($view) $c
}
lset vlastins($view) $ka $a
lappend vupptr($view) $ka
lappend vleftptr($view) $b
if {$b != 0} {
    lset vbackptr($view) $b $a
}
lappend varctok($view) $tok
lappend varcstart($view) $id
lappend vdownptr($view) 0
lappend varcrow($view) {}
lappend varcix($view) {}
set varccommits($view,$a) {}
lappend vlastins($view) 0
return $a</pre>

<p>}</p>

<p>proc splitvarc {p v} {</p>

<pre>global varcid varcstart varccommits varctok vtokmod
global vupptr vdownptr vleftptr vbackptr varcix varcrow vlastins

set oa $varcid($v,$p)
set otok [lindex $varctok($v) $oa]
set ac $varccommits($v,$oa)
set i [lsearch -exact $varccommits($v,$oa) $p]
if {$i &lt;= 0} return
set na [llength $varctok($v)]
# &quot;%&quot; sorts before &quot;0&quot;...
set tok &quot;$otok%[strrep $i]&quot;
lappend varctok($v) $tok
lappend varcrow($v) {}
lappend varcix($v) {}
set varccommits($v,$oa) [lrange $ac 0 [expr {$i - 1}]]
set varccommits($v,$na) [lrange $ac $i end]
lappend varcstart($v) $p
foreach id $varccommits($v,$na) {
    set varcid($v,$id) $na
}
lappend vdownptr($v) [lindex $vdownptr($v) $oa]
lappend vlastins($v) [lindex $vlastins($v) $oa]
lset vdownptr($v) $oa $na
lset vlastins($v) $oa 0
lappend vupptr($v) $oa
lappend vleftptr($v) 0
lappend vbackptr($v) 0
for {set b [lindex $vdownptr($v) $na]} {$b != 0} {set b [lindex $vleftptr($v) $b]} {
    lset vupptr($v) $b $na
}
if {[string compare $otok $vtokmod($v)] &lt;= 0} {
    modify_arc $v $oa
}</pre>

<p>}</p>

<p>proc renumbervarc {a v} {</p>

<pre>global parents children varctok varcstart varccommits
global vupptr vdownptr vleftptr vbackptr vlastins varcid vtokmod vdatemode

set t1 [clock clicks -milliseconds]
set todo {}
set isrelated($a) 1
set kidchanged($a) 1
set ntot 0
while {$a != 0} {
    if {[info exists isrelated($a)]} {
        lappend todo $a
        set id [lindex $varccommits($v,$a) end]
        foreach p $parents($v,$id) {
            if {[info exists varcid($v,$p)]} {
                set isrelated($varcid($v,$p)) 1
            }
        }
    }
    incr ntot
    set b [lindex $vdownptr($v) $a]
    if {$b == 0} {
        while {$a != 0} {
            set b [lindex $vleftptr($v) $a]
            if {$b != 0} break
            set a [lindex $vupptr($v) $a]
        }
    }
    set a $b
}
foreach a $todo {
    if {![info exists kidchanged($a)]} continue
    set id [lindex $varcstart($v) $a]
    if {[llength $children($v,$id)] &gt; 1} {
        set children($v,$id) [lsort -command [list vtokcmp $v] \
                                  $children($v,$id)]
    }
    set oldtok [lindex $varctok($v) $a]
    if {!$vdatemode($v)} {
        set tok {}
    } else {
        set tok $oldtok
    }
    set ka 0
    set kid [last_real_child $v,$id]
    if {$kid ne {}} {
        set k $varcid($v,$kid)
        if {[string compare [lindex $varctok($v) $k] $tok] &gt; 0} {
            set ki $kid
            set ka $k
            set tok [lindex $varctok($v) $k]
        }
    }
    if {$ka != 0} {
        set i [lsearch -exact $parents($v,$ki) $id]
        set j [expr {[llength $parents($v,$ki)] - 1 - $i}]
        append tok [strrep $j]
    }
    if {$tok eq $oldtok} {
        continue
    }
    set id [lindex $varccommits($v,$a) end]
    foreach p $parents($v,$id) {
        if {[info exists varcid($v,$p)]} {
            set kidchanged($varcid($v,$p)) 1
        } else {
            set sortkids($p) 1
        }
    }
    lset varctok($v) $a $tok
    set b [lindex $vupptr($v) $a]
    if {$b != $ka} {
        if {[string compare [lindex $varctok($v) $ka] $vtokmod($v)] &lt; 0} {
            modify_arc $v $ka
        }
        if {[string compare [lindex $varctok($v) $b] $vtokmod($v)] &lt; 0} {
            modify_arc $v $b
        }
        set c [lindex $vbackptr($v) $a]
        set d [lindex $vleftptr($v) $a]
        if {$c == 0} {
            lset vdownptr($v) $b $d
        } else {
            lset vleftptr($v) $c $d
        }
        if {$d != 0} {
            lset vbackptr($v) $d $c
        }
        if {[lindex $vlastins($v) $b] == $a} {
            lset vlastins($v) $b $c
        }
        lset vupptr($v) $a $ka
        set c [lindex $vlastins($v) $ka]
        if {$c == 0 || \
                [string compare $tok [lindex $varctok($v) $c]] &lt; 0} {
            set c $ka
            set b [lindex $vdownptr($v) $ka]
        } else {
            set b [lindex $vleftptr($v) $c]
        }
        while {$b != 0 &amp;&amp; \
                  [string compare $tok [lindex $varctok($v) $b]] &gt;= 0} {
            set c $b
            set b [lindex $vleftptr($v) $c]
        }
        if {$c == $ka} {
            lset vdownptr($v) $ka $a
            lset vbackptr($v) $a 0
        } else {
            lset vleftptr($v) $c $a
            lset vbackptr($v) $a $c
        }
        lset vleftptr($v) $a $b
        if {$b != 0} {
            lset vbackptr($v) $b $a
        }
        lset vlastins($v) $ka $a
    }
}
foreach id [array names sortkids] {
    if {[llength $children($v,$id)] &gt; 1} {
        set children($v,$id) [lsort -command [list vtokcmp $v] \
                                  $children($v,$id)]
    }
}
set t2 [clock clicks -milliseconds]
#puts &quot;renumbervarc did [llength $todo] of $ntot arcs in [expr {$t2-$t1}]ms&quot;</pre>

<p>}</p>

<p># Fix up the graph after we have found out that in view $v, # $p (a commit
that we have already seen) is actually the parent # of the last commit in
arc $a. proc fix_reversal {p a v} {</p>

<pre>global varcid varcstart varctok vupptr

set pa $varcid($v,$p)
if {$p ne [lindex $varcstart($v) $pa]} {
    splitvarc $p $v
    set pa $varcid($v,$p)
}
# seeds always need to be renumbered
if {[lindex $vupptr($v) $pa] == 0 ||
    [string compare [lindex $varctok($v) $a] \
         [lindex $varctok($v) $pa]] &gt; 0} {
    renumbervarc $pa $v
}</pre>

<p>}</p>

<p>proc insertrow {id p v} {</p>

<pre>global cmitlisted children parents varcid varctok vtokmod
global varccommits ordertok commitidx numcommits curview
global targetid targetrow vshortids

readcommit $id
set vid $v,$id
set cmitlisted($vid) 1
set children($vid) {}
set parents($vid) [list $p]
set a [newvarc $v $id]
set varcid($vid) $a
lappend vshortids($v,[string range $id 0 3]) $id
if {[string compare [lindex $varctok($v) $a] $vtokmod($v)] &lt; 0} {
    modify_arc $v $a
}
lappend varccommits($v,$a) $id
set vp $v,$p
if {[llength [lappend children($vp) $id]] &gt; 1} {
    set children($vp) [lsort -command [list vtokcmp $v] $children($vp)]
    catch {unset ordertok}
}
fix_reversal $p $a $v
incr commitidx($v)
if {$v == $curview} {
    set numcommits $commitidx($v)
    setcanvscroll
    if {[info exists targetid]} {
        if {![comes_before $targetid $p]} {
            incr targetrow
        }
    }
}</pre>

<p>}</p>

<p>proc insertfakerow {id p} {</p>

<pre>global varcid varccommits parents children cmitlisted
global commitidx varctok vtokmod targetid targetrow curview numcommits

set v $curview
set a $varcid($v,$p)
set i [lsearch -exact $varccommits($v,$a) $p]
if {$i &lt; 0} {
    puts &quot;oops: insertfakerow can&#39;t find [shortids $p] on arc $a&quot;
    return
}
set children($v,$id) {}
set parents($v,$id) [list $p]
set varcid($v,$id) $a
lappend children($v,$p) $id
set cmitlisted($v,$id) 1
set numcommits [incr commitidx($v)]
# note we deliberately don&#39;t update varcstart($v) even if $i == 0
set varccommits($v,$a) [linsert $varccommits($v,$a) $i $id]
modify_arc $v $a $i
if {[info exists targetid]} {
    if {![comes_before $targetid $p]} {
        incr targetrow
    }
}
setcanvscroll
drawvisible</pre>

<p>}</p>

<p>proc removefakerow {id} {</p>

<pre>global varcid varccommits parents children commitidx
global varctok vtokmod cmitlisted currentid selectedline
global targetid curview numcommits

set v $curview
if {[llength $parents($v,$id)] != 1} {
    puts &quot;oops: removefakerow [shortids $id] has [llength $parents($v,$id)] parents&quot;
    return
}
set p [lindex $parents($v,$id) 0]
set a $varcid($v,$id)
set i [lsearch -exact $varccommits($v,$a) $id]
if {$i &lt; 0} {
    puts &quot;oops: removefakerow can&#39;t find [shortids $id] on arc $a&quot;
    return
}
unset varcid($v,$id)
set varccommits($v,$a) [lreplace $varccommits($v,$a) $i $i]
unset parents($v,$id)
unset children($v,$id)
unset cmitlisted($v,$id)
set numcommits [incr commitidx($v) -1]
set j [lsearch -exact $children($v,$p) $id]
if {$j &gt;= 0} {
    set children($v,$p) [lreplace $children($v,$p) $j $j]
}
modify_arc $v $a $i
if {[info exist currentid] &amp;&amp; $id eq $currentid} {
    unset currentid
    set selectedline {}
}
if {[info exists targetid] &amp;&amp; $targetid eq $id} {
    set targetid $p
}
setcanvscroll
drawvisible</pre>

<p>}</p>

<p>proc real_children {vp} {</p>

<pre>global children nullid nullid2

set kids {}
foreach id $children($vp) {
    if {$id ne $nullid &amp;&amp; $id ne $nullid2} {
        lappend kids $id
    }
}
return $kids</pre>

<p>}</p>

<p>proc first_real_child {vp} {</p>

<pre>global children nullid nullid2

foreach id $children($vp) {
    if {$id ne $nullid &amp;&amp; $id ne $nullid2} {
        return $id
    }
}
return {}</pre>

<p>}</p>

<p>proc last_real_child {vp} {</p>

<pre>global children nullid nullid2

set kids $children($vp)
for {set i [llength $kids]} {[incr i -1] &gt;= 0} {} {
    set id [lindex $kids $i]
    if {$id ne $nullid &amp;&amp; $id ne $nullid2} {
        return $id
    }
}
return {}</pre>

<p>}</p>

<p>proc vtokcmp {v a b} {</p>

<pre>global varctok varcid

return [string compare [lindex $varctok($v) $varcid($v,$a)] \
            [lindex $varctok($v) $varcid($v,$b)]]</pre>

<p>}</p>

<p># This assumes that if lim is not given, the caller has checked that # arc
a&#39;s token is less than $vtokmod($v) proc modify_arc {v a {lim {}}} {</p>

<pre>global varctok vtokmod varcmod varcrow vupptr curview vrowmod varccommits

if {$lim ne {}} {
    set c [string compare [lindex $varctok($v) $a] $vtokmod($v)]
    if {$c &gt; 0} return
    if {$c == 0} {
        set r [lindex $varcrow($v) $a]
        if {$r ne {} &amp;&amp; $vrowmod($v) &lt;= $r + $lim} return
    }
}
set vtokmod($v) [lindex $varctok($v) $a]
set varcmod($v) $a
if {$v == $curview} {
    while {$a != 0 &amp;&amp; [lindex $varcrow($v) $a] eq {}} {
        set a [lindex $vupptr($v) $a]
        set lim {}
    }
    set r 0
    if {$a != 0} {
        if {$lim eq {}} {
            set lim [llength $varccommits($v,$a)]
        }
        set r [expr {[lindex $varcrow($v) $a] + $lim}]
    }
    set vrowmod($v) $r
    undolayout $r
}</pre>

<p>}</p>

<p>proc update_arcrows {v} {</p>

<pre>global vtokmod varcmod vrowmod varcrow commitidx currentid selectedline
global varcid vrownum varcorder varcix varccommits
global vupptr vdownptr vleftptr varctok
global displayorder parentlist curview cached_commitrow

if {$vrowmod($v) == $commitidx($v)} return
if {$v == $curview} {
    if {[llength $displayorder] &gt; $vrowmod($v)} {
        set displayorder [lrange $displayorder 0 [expr {$vrowmod($v) - 1}]]
        set parentlist [lrange $parentlist 0 [expr {$vrowmod($v) - 1}]]
    }
    catch {unset cached_commitrow}
}
set narctot [expr {[llength $varctok($v)] - 1}]
set a $varcmod($v)
while {$a != 0 &amp;&amp; [lindex $varcix($v) $a] eq {}} {
    # go up the tree until we find something that has a row number,
    # or we get to a seed
    set a [lindex $vupptr($v) $a]
}
if {$a == 0} {
    set a [lindex $vdownptr($v) 0]
    if {$a == 0} return
    set vrownum($v) {0}
    set varcorder($v) [list $a]
    lset varcix($v) $a 0
    lset varcrow($v) $a 0
    set arcn 0
    set row 0
} else {
    set arcn [lindex $varcix($v) $a]
    if {[llength $vrownum($v)] &gt; $arcn + 1} {
        set vrownum($v) [lrange $vrownum($v) 0 $arcn]
        set varcorder($v) [lrange $varcorder($v) 0 $arcn]
    }
    set row [lindex $varcrow($v) $a]
}
while {1} {
    set p $a
    incr row [llength $varccommits($v,$a)]
    # go down if possible
    set b [lindex $vdownptr($v) $a]
    if {$b == 0} {
        # if not, go left, or go up until we can go left
        while {$a != 0} {
            set b [lindex $vleftptr($v) $a]
            if {$b != 0} break
            set a [lindex $vupptr($v) $a]
        }
        if {$a == 0} break
    }
    set a $b
    incr arcn
    lappend vrownum($v) $row
    lappend varcorder($v) $a
    lset varcix($v) $a $arcn
    lset varcrow($v) $a $row
}
set vtokmod($v) [lindex $varctok($v) $p]
set varcmod($v) $p
set vrowmod($v) $row
if {[info exists currentid]} {
    set selectedline [rowofcommit $currentid]
}</pre>

<p>}</p>

<p># Test whether view $v contains commit $id proc commitinview {id v} {</p>

<pre>global varcid

return [info exists varcid($v,$id)]</pre>

<p>}</p>

<p># Return the row number for commit $id in the current view proc rowofcommit
{id} {</p>

<pre>global varcid varccommits varcrow curview cached_commitrow
global varctok vtokmod

set v $curview
if {![info exists varcid($v,$id)]} {
    puts &quot;oops rowofcommit no arc for [shortids $id]&quot;
    return {}
}
set a $varcid($v,$id)
if {[string compare [lindex $varctok($v) $a] $vtokmod($v)] &gt;= 0} {
    update_arcrows $v
}
if {[info exists cached_commitrow($id)]} {
    return $cached_commitrow($id)
}
set i [lsearch -exact $varccommits($v,$a) $id]
if {$i &lt; 0} {
    puts &quot;oops didn&#39;t find commit [shortids $id] in arc $a&quot;
    return {}
}
incr i [lindex $varcrow($v) $a]
set cached_commitrow($id) $i
return $i</pre>

<p>}</p>

<p># Returns 1 if a is on an earlier row than b, otherwise 0 proc comes_before
{a b} {</p>

<pre>global varcid varctok curview

set v $curview
if {$a eq $b || ![info exists varcid($v,$a)] || \
        ![info exists varcid($v,$b)]} {
    return 0
}
if {$varcid($v,$a) != $varcid($v,$b)} {
    return [expr {[string compare [lindex $varctok($v) $varcid($v,$a)] \
                       [lindex $varctok($v) $varcid($v,$b)]] &lt; 0}]
}
return [expr {[rowofcommit $a] &lt; [rowofcommit $b]}]</pre>

<p>}</p>

<p>proc bsearch {l elt} {</p>

<pre>if {[llength $l] == 0 || $elt &lt;= [lindex $l 0]} {
    return 0
}
set lo 0
set hi [llength $l]
while {$hi - $lo &gt; 1} {
    set mid [expr {int(($lo + $hi) / 2)}]
    set t [lindex $l $mid]
    if {$elt &lt; $t} {
        set hi $mid
    } elseif {$elt &gt; $t} {
        set lo $mid
    } else {
        return $mid
    }
}
return $lo</pre>

<p>}</p>

<p># Make sure rows $start..$end-1 are valid in displayorder and parentlist
proc make_disporder {start end} {</p>

<pre>global vrownum curview commitidx displayorder parentlist
global varccommits varcorder parents vrowmod varcrow
global d_valid_start d_valid_end

if {$end &gt; $vrowmod($curview)} {
    update_arcrows $curview
}
set ai [bsearch $vrownum($curview) $start]
set start [lindex $vrownum($curview) $ai]
set narc [llength $vrownum($curview)]
for {set r $start} {$ai &lt; $narc &amp;&amp; $r &lt; $end} {incr ai} {
    set a [lindex $varcorder($curview) $ai]
    set l [llength $displayorder]
    set al [llength $varccommits($curview,$a)]
    if {$l &lt; $r + $al} {
        if {$l &lt; $r} {
            set pad [ntimes [expr {$r - $l}] {}]
            set displayorder [concat $displayorder $pad]
            set parentlist [concat $parentlist $pad]
        } elseif {$l &gt; $r} {
            set displayorder [lrange $displayorder 0 [expr {$r - 1}]]
            set parentlist [lrange $parentlist 0 [expr {$r - 1}]]
        }
        foreach id $varccommits($curview,$a) {
            lappend displayorder $id
            lappend parentlist $parents($curview,$id)
        }
    } elseif {[lindex $displayorder [expr {$r + $al - 1}]] eq {}} {
        set i $r
        foreach id $varccommits($curview,$a) {
            lset displayorder $i $id
            lset parentlist $i $parents($curview,$id)
            incr i
        }
    }
    incr r $al
}</pre>

<p>}</p>

<p>proc commitonrow {row} {</p>

<pre>global displayorder

set id [lindex $displayorder $row]
if {$id eq {}} {
    make_disporder $row [expr {$row + 1}]
    set id [lindex $displayorder $row]
}
return $id</pre>

<p>}</p>

<p>proc closevarcs {v} {</p>

<pre>global varctok varccommits varcid parents children
global cmitlisted commitidx vtokmod

set missing_parents 0
set scripts {}
set narcs [llength $varctok($v)]
for {set a 1} {$a &lt; $narcs} {incr a} {
    set id [lindex $varccommits($v,$a) end]
    foreach p $parents($v,$id) {
        if {[info exists varcid($v,$p)]} continue
        # add p as a new commit
        incr missing_parents
        set cmitlisted($v,$p) 0
        set parents($v,$p) {}
        if {[llength $children($v,$p)] == 1 &amp;&amp;
            [llength $parents($v,$id)] == 1} {
            set b $a
        } else {
            set b [newvarc $v $p]
        }
        set varcid($v,$p) $b
        if {[string compare [lindex $varctok($v) $b] $vtokmod($v)] &lt; 0} {
            modify_arc $v $b
        }
        lappend varccommits($v,$b) $p
        incr commitidx($v)
        set scripts [check_interest $p $scripts]
    }
}
if {$missing_parents &gt; 0} {
    foreach s $scripts {
        eval $s
    }
}</pre>

<p>}</p>

<p># Use $rwid as a substitute for $id, i.e. reparent $id&#39;s children to
$rwid # Assumes we already have an arc for $rwid. proc rewrite_commit {v id
rwid} {</p>

<pre>global children parents varcid varctok vtokmod varccommits

foreach ch $children($v,$id) {
    # make $rwid be $ch&#39;s parent in place of $id
    set i [lsearch -exact $parents($v,$ch) $id]
    if {$i &lt; 0} {
        puts &quot;oops rewrite_commit didn&#39;t find $id in parent list for $ch&quot;
    }
    set parents($v,$ch) [lreplace $parents($v,$ch) $i $i $rwid]
    # add $ch to $rwid&#39;s children and sort the list if necessary
    if {[llength [lappend children($v,$rwid) $ch]] &gt; 1} {
        set children($v,$rwid) [lsort -command [list vtokcmp $v] \
                                    $children($v,$rwid)]
    }
    # fix the graph after joining $id to $rwid
    set a $varcid($v,$ch)
    fix_reversal $rwid $a $v
    # parentlist is wrong for the last element of arc $a
    # even if displayorder is right, hence the 3rd arg here
    modify_arc $v $a [expr {[llength $varccommits($v,$a)] - 1}]
}</pre>

<p>}</p>

<p># Mechanism for registering a command to be executed when we come # across
a particular commit.  To handle the case when only the # prefix of the
commit is known, the commitinterest array is now # indexed by the first 4
characters of the ID.  Each element is a # list of id, cmd pairs. proc
interestedin {id cmd} {</p>

<pre>global commitinterest

lappend commitinterest([string range $id 0 3]) $id $cmd</pre>

<p>}</p>

<p>proc check_interest {id scripts} {</p>

<pre>global commitinterest

set prefix [string range $id 0 3]
if {[info exists commitinterest($prefix)]} {
    set newlist {}
    foreach {i script} $commitinterest($prefix) {
        if {[string match &quot;$i*&quot; $id]} {
            lappend scripts [string map [list &quot;%I&quot; $id &quot;%P&quot; $i] $script]
        } else {
            lappend newlist $i $script
        }
    }
    if {$newlist ne {}} {
        set commitinterest($prefix) $newlist
    } else {
        unset commitinterest($prefix)
    }
}
return $scripts</pre>

<p>}</p>

<p>proc getcommitlines {fd inst view updating}  {</p>

<pre>global cmitlisted leftover
global commitidx commitdata vdatemode
global parents children curview hlview
global idpending ordertok
global varccommits varcid varctok vtokmod vfilelimit vshortids

set stuff [read $fd 500000]
# git log doesn&#39;t terminate the last commit with a null...
if {$stuff == {} &amp;&amp; $leftover($inst) ne {} &amp;&amp; [eof $fd]} {
    set stuff &quot;\0&quot;
}
if {$stuff == {}} {
    if {![eof $fd]} {
        return 1
    }
    global commfd viewcomplete viewactive viewname
    global viewinstances
    unset commfd($inst)
    set i [lsearch -exact $viewinstances($view) $inst]
    if {$i &gt;= 0} {
        set viewinstances($view) [lreplace $viewinstances($view) $i $i]
    }
    # set it blocking so we wait for the process to terminate
    fconfigure $fd -blocking 1
    if {[catch {close $fd} err]} {
        set fv {}
        if {$view != $curview} {
            set fv &quot; for the \&quot;$viewname($view)\&quot; view&quot;
        }
        if {[string range $err 0 4] == &quot;usage&quot;} {
            set err &quot;Gitk: error reading commits$fv:\
                    bad arguments to git log.&quot;
            if {$viewname($view) eq &quot;Command line&quot;} {
                append err \
                    &quot;  (Note: arguments to gitk are passed to git log\
                     to allow selection of commits to be displayed.)&quot;
            }
        } else {
            set err &quot;Error reading commits$fv: $err&quot;
        }
        error_popup $err
    }
    if {[incr viewactive($view) -1] &lt;= 0} {
        set viewcomplete($view) 1
        # Check if we have seen any ids listed as parents that haven&#39;t
        # appeared in the list
        closevarcs $view
        notbusy $view
    }
    if {$view == $curview} {
        run chewcommits
    }
    return 0
}
set start 0
set gotsome 0
set scripts {}
while 1 {
    set i [string first &quot;\0&quot; $stuff $start]
    if {$i &lt; 0} {
        append leftover($inst) [string range $stuff $start end]
        break
    }
    if {$start == 0} {
        set cmit $leftover($inst)
        append cmit [string range $stuff 0 [expr {$i - 1}]]
        set leftover($inst) {}
    } else {
        set cmit [string range $stuff $start [expr {$i - 1}]]
    }
    set start [expr {$i + 1}]
    set j [string first &quot;\n&quot; $cmit]
    set ok 0
    set listed 1
    if {$j &gt;= 0 &amp;&amp; [string match &quot;commit *&quot; $cmit]} {
        set ids [string range $cmit 7 [expr {$j - 1}]]
        if {[string match {[-^&lt;&gt;]*} $ids]} {
            switch -- [string index $ids 0] {
                &quot;-&quot; {set listed 0}
                &quot;^&quot; {set listed 2}
                &quot;&lt;&quot; {set listed 3}
                &quot;&gt;&quot; {set listed 4}
            }
            set ids [string range $ids 1 end]
        }
        set ok 1
        foreach id $ids {
            if {[string length $id] != 40} {
                set ok 0
                break
            }
        }
    }
    if {!$ok} {
        set shortcmit $cmit
        if {[string length $shortcmit] &gt; 80} {
            set shortcmit &quot;[string range $shortcmit 0 80]...&quot;
        }
        error_popup &quot;[mc &quot;Can&#39;t parse git log output:&quot;] {$shortcmit}&quot;
        exit 1
    }
    set id [lindex $ids 0]
    set vid $view,$id

    lappend vshortids($view,[string range $id 0 3]) $id

    if {!$listed &amp;&amp; $updating &amp;&amp; ![info exists varcid($vid)] &amp;&amp;
        $vfilelimit($view) ne {}} {
        # git log doesn&#39;t rewrite parents for unlisted commits
        # when doing path limiting, so work around that here
        # by working out the rewritten parent with git rev-list
        # and if we already know about it, using the rewritten
        # parent as a substitute parent for $id&#39;s children.
        if {![catch {
            set rwid [exec git rev-list --first-parent --max-count=1 \
                          $id -- $vfilelimit($view)]
        }]} {
            if {$rwid ne {} &amp;&amp; [info exists varcid($view,$rwid)]} {
                # use $rwid in place of $id
                rewrite_commit $view $id $rwid
                continue
            }
        }
    }

    set a 0
    if {[info exists varcid($vid)]} {
        if {$cmitlisted($vid) || !$listed} continue
        set a $varcid($vid)
    }
    if {$listed} {
        set olds [lrange $ids 1 end]
    } else {
        set olds {}
    }
    set commitdata($id) [string range $cmit [expr {$j + 1}] end]
    set cmitlisted($vid) $listed
    set parents($vid) $olds
    if {![info exists children($vid)]} {
        set children($vid) {}
    } elseif {$a == 0 &amp;&amp; [llength $children($vid)] == 1} {
        set k [lindex $children($vid) 0]
        if {[llength $parents($view,$k)] == 1 &amp;&amp;
            (!$vdatemode($view) ||
             $varcid($view,$k) == [llength $varctok($view)] - 1)} {
            set a $varcid($view,$k)
        }
    }
    if {$a == 0} {
        # new arc
        set a [newvarc $view $id]
    }
    if {[string compare [lindex $varctok($view) $a] $vtokmod($view)] &lt; 0} {
        modify_arc $view $a
    }
    if {![info exists varcid($vid)]} {
        set varcid($vid) $a
        lappend varccommits($view,$a) $id
        incr commitidx($view)
    }

    set i 0
    foreach p $olds {
        if {$i == 0 || [lsearch -exact $olds $p] &gt;= $i} {
            set vp $view,$p
            if {[llength [lappend children($vp) $id]] &gt; 1 &amp;&amp;
                [vtokcmp $view [lindex $children($vp) end-1] $id] &gt; 0} {
                set children($vp) [lsort -command [list vtokcmp $view] \
                                       $children($vp)]
                catch {unset ordertok}
            }
            if {[info exists varcid($view,$p)]} {
                fix_reversal $p $a $view
            }
        }
        incr i
    }

    set scripts [check_interest $id $scripts]
    set gotsome 1
}
if {$gotsome} {
    global numcommits hlview

    if {$view == $curview} {
        set numcommits $commitidx($view)
        run chewcommits
    }
    if {[info exists hlview] &amp;&amp; $view == $hlview} {
        # we never actually get here...
        run vhighlightmore
    }
    foreach s $scripts {
        eval $s
    }
}
return 2</pre>

<p>}</p>

<p>proc chewcommits {} {</p>

<pre>global curview hlview viewcomplete
global pending_select

layoutmore
if {$viewcomplete($curview)} {
    global commitidx varctok
    global numcommits startmsecs

    if {[info exists pending_select]} {
        update
        reset_pending_select {}

        if {[commitinview $pending_select $curview]} {
            selectline [rowofcommit $pending_select] 1
        } else {
            set row [first_real_row]
            selectline $row 1
        }
    }
    if {$commitidx($curview) &gt; 0} {
        #set ms [expr {[clock clicks -milliseconds] - $startmsecs}]
        #puts &quot;overall $ms ms for $numcommits commits&quot;
        #puts &quot;[llength $varctok($view)] arcs, $commitidx($view) commits&quot;
    } else {
        show_status [mc &quot;No commits selected&quot;]
    }
    notbusy layout
}
return 0</pre>

<p>}</p>

<p>proc do_readcommit {id} {</p>

<pre>global tclencoding

# Invoke git-log to handle automatic encoding conversion
set fd [open [concat | git log --no-color --pretty=raw -1 $id] r]
# Read the results using i18n.logoutputencoding
fconfigure $fd -translation lf -eofchar {}
if {$tclencoding != {}} {
    fconfigure $fd -encoding $tclencoding
}
set contents [read $fd]
close $fd
# Remove the heading line
regsub {^commit [0-9a-f]+\n} $contents {} contents

return $contents</pre>

<p>}</p>

<p>proc readcommit {id} {</p>

<pre>if {[catch {set contents [do_readcommit $id]}]} return
parsecommit $id $contents 1</pre>

<p>}</p>

<p>proc parsecommit {id contents listed} {</p>

<pre>global commitinfo

set inhdr 1
set comment {}
set headline {}
set auname {}
set audate {}
set comname {}
set comdate {}
set hdrend [string first &quot;\n\n&quot; $contents]
if {$hdrend &lt; 0} {
    # should never happen...
    set hdrend [string length $contents]
}
set header [string range $contents 0 [expr {$hdrend - 1}]]
set comment [string range $contents [expr {$hdrend + 2}] end]
foreach line [split $header &quot;\n&quot;] {
    set line [split $line &quot; &quot;]
    set tag [lindex $line 0]
    if {$tag == &quot;author&quot;} {
        set audate [lrange $line end-1 end]
        set auname [join [lrange $line 1 end-2] &quot; &quot;]
    } elseif {$tag == &quot;committer&quot;} {
        set comdate [lrange $line end-1 end]
        set comname [join [lrange $line 1 end-2] &quot; &quot;]
    }
}
set headline {}
# take the first non-blank line of the comment as the headline
set headline [string trimleft $comment]
set i [string first &quot;\n&quot; $headline]
if {$i &gt;= 0} {
    set headline [string range $headline 0 $i]
}
set headline [string trimright $headline]
set i [string first &quot;\r&quot; $headline]
if {$i &gt;= 0} {
    set headline [string trimright [string range $headline 0 $i]]
}
if {!$listed} {
    # git log indents the comment by 4 spaces;
    # if we got this via git cat-file, add the indentation
    set newcomment {}
    foreach line [split $comment &quot;\n&quot;] {
        append newcomment &quot;    &quot;
        append newcomment $line
        append newcomment &quot;\n&quot;
    }
    set comment $newcomment
}
set hasnote [string first &quot;\nNotes:\n&quot; $contents]
set commitinfo($id) [list $headline $auname $audate \
                         $comname $comdate $comment $hasnote]</pre>

<p>}</p>

<p>proc getcommit {id} {</p>

<pre>global commitdata commitinfo

if {[info exists commitdata($id)]} {
    parsecommit $id $commitdata($id) 1
} else {
    readcommit $id
    if {![info exists commitinfo($id)]} {
        set commitinfo($id) [list [mc &quot;No commit information available&quot;]]
    }
}
return 1</pre>

<p>}</p>

<p># Expand an abbreviated commit ID to a list of full 40-char IDs that match
# and are present in the current view. # This is fairly slow… proc longid
{prefix} {</p>

<pre>global varcid curview vshortids

set ids {}
if {[string length $prefix] &gt;= 4} {
    set vshortid $curview,[string range $prefix 0 3]
    if {[info exists vshortids($vshortid)]} {
        foreach id $vshortids($vshortid) {
            if {[string match &quot;$prefix*&quot; $id]} {
                if {[lsearch -exact $ids $id] &lt; 0} {
                    lappend ids $id
                    if {[llength $ids] &gt;= 2} break
                }
            }
        }
    }
} else {
    foreach match [array names varcid &quot;$curview,$prefix*&quot;] {
        lappend ids [lindex [split $match &quot;,&quot;] 1]
        if {[llength $ids] &gt;= 2} break
    }
}
return $ids</pre>

<p>}</p>

<p>proc readrefs {} {</p>

<pre>global tagids idtags headids idheads tagobjid
global otherrefids idotherrefs mainhead mainheadid
global selecthead selectheadid
global hideremotes

foreach v {tagids idtags headids idheads otherrefids idotherrefs} {
    catch {unset $v}
}
set refd [open [list | git show-ref -d] r]
while {[gets $refd line] &gt;= 0} {
    if {[string index $line 40] ne &quot; &quot;} continue
    set id [string range $line 0 39]
    set ref [string range $line 41 end]
    if {![string match &quot;refs  &quot; $ref]} continue
    set name [string range $ref 5 end]
    if {[string match &quot;remotes  &quot; $name]} {
        if {![string match &quot;  HEAD&quot; $name] &amp;&amp; !$hideremotes} {
            set headids($name) $id
            lappend idheads($id) $name
        }
    } elseif {[string match &quot;heads/*&quot; $name]} {
        set name [string range $name 6 end]
        set headids($name) $id
        lappend idheads($id) $name
    } elseif {[string match &quot;tags/*&quot; $name]} {
        # this lets refs/tags/foo^{} overwrite refs/tags/foo,
        # which is what we want since the former is the commit ID
        set name [string range $name 5 end]
        if {[string match &quot;*^{}&quot; $name]} {
            set name [string range $name 0 end-3]
        } else {
            set tagobjid($name) $id
        }
        set tagids($name) $id
        lappend idtags($id) $name
    } else {
        set otherrefids($name) $id
        lappend idotherrefs($id) $name
    }
}
catch {close $refd}
set mainhead {}
set mainheadid {}
catch {
    set mainheadid [exec git rev-parse HEAD]
    set thehead [exec git symbolic-ref HEAD]
    if {[string match &quot;refs/heads/*&quot; $thehead]} {
        set mainhead [string range $thehead 11 end]
    }
}
set selectheadid {}
if {$selecthead ne {}} {
    catch {
        set selectheadid [exec git rev-parse --verify $selecthead]
    }
}</pre>

<p>}</p>

<p># skip over fake commits proc first_real_row {} {</p>

<pre>global nullid nullid2 numcommits

for {set row 0} {$row &lt; $numcommits} {incr row} {
    set id [commitonrow $row]
    if {$id ne $nullid &amp;&amp; $id ne $nullid2} {
        break
    }
}
return $row</pre>

<p>}</p>

<p># update things for a head moved to a child of its previous location proc
movehead {id name} {</p>

<pre>global headids idheads

removehead $headids($name) $name
set headids($name) $id
lappend idheads($id) $name</pre>

<p>}</p>

<p># update things when a head has been removed proc removehead {id name} {</p>

<pre>global headids idheads

if {$idheads($id) eq $name} {
    unset idheads($id)
} else {
    set i [lsearch -exact $idheads($id) $name]
    if {$i &gt;= 0} {
        set idheads($id) [lreplace $idheads($id) $i $i]
    }
}
unset headids($name)</pre>

<p>}</p>

<p>proc ttk_toplevel {w args} {</p>

<pre>global use_ttk
eval [linsert $args 0 ::toplevel $w]
if {$use_ttk} {
    place [ttk::frame $w._toplevel_background] -x 0 -y 0 -relwidth 1 -relheight 1
}
return $w</pre>

<p>}</p>

<p>proc make_transient {window origin} {</p>

<pre>global have_tk85

# In MacOS Tk 8.4 transient appears to work by setting
# overrideredirect, which is utterly useless, since the
# windows get no border, and are not even kept above
# the parent.
if {!$have_tk85 &amp;&amp; [tk windowingsystem] eq {aqua}} return

wm transient $window $origin

# Windows fails to place transient windows normally, so
# schedule a callback to center them on the parent.
if {[tk windowingsystem] eq {win32}} {
    after idle [list tk::PlaceWindow $window widget $origin]
}</pre>

<p>}</p>

<p>proc show_error {w top msg {mc mc}} {</p>

<pre>global NS
if {![info exists NS]} {set NS &quot;&quot;}
if {[wm state $top] eq &quot;withdrawn&quot;} { wm deiconify $top }
message $w.m -text $msg -justify center -aspect 400
pack $w.m -side top -fill x -padx 20 -pady 20
${NS}::button $w.ok -default active -text [$mc OK] -command &quot;destroy $top&quot;
pack $w.ok -side bottom -fill x
bind $top &lt;Visibility&gt; &quot;grab $top; focus $top&quot;
bind $top &lt;Key-Return&gt; &quot;destroy $top&quot;
bind $top &lt;Key-space&gt;  &quot;destroy $top&quot;
bind $top &lt;Key-Escape&gt; &quot;destroy $top&quot;
tkwait window $top</pre>

<p>}</p>

<p>proc error_popup {msg {owner .}} {</p>

<pre>if {[tk windowingsystem] eq &quot;win32&quot;} {
    tk_messageBox -icon error -type ok -title [wm title .] \
        -parent $owner -message $msg
} else {
    set w .error
    ttk_toplevel $w
    make_transient $w $owner
    show_error $w $w $msg
}</pre>

<p>}</p>

<p>proc confirm_popup {msg {owner .}} {</p>

<pre>global confirm_ok NS
set confirm_ok 0
set w .confirm
ttk_toplevel $w
make_transient $w $owner
message $w.m -text $msg -justify center -aspect 400
pack $w.m -side top -fill x -padx 20 -pady 20
${NS}::button $w.ok -text [mc OK] -command &quot;set confirm_ok 1; destroy $w&quot;
pack $w.ok -side left -fill x
${NS}::button $w.cancel -text [mc Cancel] -command &quot;destroy $w&quot;
pack $w.cancel -side right -fill x
bind $w &lt;Visibility&gt; &quot;grab $w; focus $w&quot;
bind $w &lt;Key-Return&gt; &quot;set confirm_ok 1; destroy $w&quot;
bind $w &lt;Key-space&gt;  &quot;set confirm_ok 1; destroy $w&quot;
bind $w &lt;Key-Escape&gt; &quot;destroy $w&quot;
tk::PlaceWindow $w widget $owner
tkwait window $w
return $confirm_ok</pre>

<p>}</p>

<p>proc setoptions {} {</p>

<pre>if {[tk windowingsystem] ne &quot;win32&quot;} {
    option add *Panedwindow.showHandle 1 startupFile
    option add *Panedwindow.sashRelief raised startupFile
    if {[tk windowingsystem] ne &quot;aqua&quot;} {
        option add *Menu.font uifont startupFile
    }
} else {
    option add *Menu.TearOff 0 startupFile
}
option add *Button.font uifont startupFile
option add *Checkbutton.font uifont startupFile
option add *Radiobutton.font uifont startupFile
option add *Menubutton.font uifont startupFile
option add *Label.font uifont startupFile
option add *Message.font uifont startupFile
option add *Entry.font textfont startupFile
option add *Text.font textfont startupFile
option add *Labelframe.font uifont startupFile
option add *Spinbox.font textfont startupFile
option add *Listbox.font mainfont startupFile</pre>

<p>}</p>

<p># Make a menu and submenus. # m is the window name for the menu, items is
the list of menu items to add. # Each item is a list {mc label type
description options…} # mc is ignored; it&#39;s so we can put mc there to
alert xgettext # label is the string that appears in the menu # type is
cascade, command or radiobutton (should add checkbutton) # description
depends on type; it&#39;s the sublist for cascade, the # command to invoke
for command, or {variable value} for radiobutton proc makemenu {m items} {</p>

<pre>menu $m
if {[tk windowingsystem] eq {aqua}} {
    set Meta1 Cmd
} else {
    set Meta1 Ctrl
}
foreach i $items {
    set name [mc [lindex $i 1]]
    set type [lindex $i 2]
    set thing [lindex $i 3]
    set params [list $type]
    if {$name ne {}} {
        set u [string first &quot;&amp;&quot; [string map {&amp;&amp; x} $name]]
        lappend params -label [string map {&amp;&amp; &amp; &amp; {}} $name]
        if {$u &gt;= 0} {
            lappend params -underline $u
        }
    }
    switch -- $type {
        &quot;cascade&quot; {
            set submenu [string tolower [string map {&amp; &quot;&quot;} [lindex $i 1]]]
            lappend params -menu $m.$submenu
        }
        &quot;command&quot; {
            lappend params -command $thing
        }
        &quot;radiobutton&quot; {
            lappend params -variable [lindex $thing 0] \
                -value [lindex $thing 1]
        }
    }
    set tail [lrange $i 4 end]
    regsub -all {\yMeta1\y} $tail $Meta1 tail
    eval $m add $params $tail
    if {$type eq &quot;cascade&quot;} {
        makemenu $m.$submenu $thing
    }
}</pre>

<p>}</p>

<p># translate string and remove ampersands proc mca {str} {</p>

<pre>return [string map {&amp;&amp; &amp; &amp; {}} [mc $str]]</pre>

<p>}</p>

<p>proc cleardropsel {w} {</p>

<pre>$w selection clear</pre>

<p>} proc makedroplist {w varname args} {</p>

<pre>global use_ttk
if {$use_ttk} {
    set width 0
    foreach label $args {
        set cx [string length $label]
        if {$cx &gt; $width} {set width $cx}
    }
    set gm [ttk::combobox $w -width $width -state readonly\
                -textvariable $varname -values $args \
                -exportselection false]
    bind $gm &lt;&lt;ComboboxSelected&gt;&gt; [list $gm selection clear]
} else {
    set gm [eval [linsert $args 0 tk_optionMenu $w $varname]]
}
return $gm</pre>

<p>}</p>

<p>proc makewindow {} {</p>

<pre>global canv canv2 canv3 linespc charspc ctext cflist cscroll
global tabstop
global findtype findtypemenu findloc findstring fstring geometry
global entries sha1entry sha1string sha1but
global diffcontextstring diffcontext
global ignorespace
global maincursor textcursor curtextcursor
global rowctxmenu fakerowmenu mergemax wrapcomment
global highlight_files gdttype
global searchstring sstring
global bgcolor fgcolor bglist fglist diffcolors selectbgcolor
global uifgcolor uifgdisabledcolor
global filesepbgcolor filesepfgcolor
global mergecolors foundbgcolor currentsearchhitbgcolor
global headctxmenu progresscanv progressitem progresscoords statusw
global fprogitem fprogcoord lastprogupdate progupdatepending
global rprogitem rprogcoord rownumsel numcommits
global have_tk85 use_ttk NS
global git_version
global worddiff

# The &quot;mc&quot; arguments here are purely so that xgettext
# sees the following string as needing to be translated
set file {
    mc &quot;File&quot; cascade {
        {mc &quot;Update&quot; command updatecommits -accelerator F5}
        {mc &quot;Reload&quot; command reloadcommits -accelerator Shift-F5}
        {mc &quot;Reread references&quot; command rereadrefs}
        {mc &quot;List references&quot; command showrefs -accelerator F2}
        {xx &quot;&quot; separator}
        {mc &quot;Start git gui&quot; command {exec git gui &amp;}}
        {xx &quot;&quot; separator}
        {mc &quot;Quit&quot; command doquit -accelerator Meta1-Q}
    }}
set edit {
    mc &quot;Edit&quot; cascade {
        {mc &quot;Preferences&quot; command doprefs}
    }}
set view {
    mc &quot;View&quot; cascade {
        {mc &quot;New view...&quot; command {newview 0} -accelerator Shift-F4}
        {mc &quot;Edit view...&quot; command editview -state disabled -accelerator F4}
        {mc &quot;Delete view&quot; command delview -state disabled}
        {xx &quot;&quot; separator}
        {mc &quot;All files&quot; radiobutton {selectedview 0} -command {showview 0}}
    }}
if {[tk windowingsystem] ne &quot;aqua&quot;} {
    set help {
    mc &quot;Help&quot; cascade {
        {mc &quot;About gitk&quot; command about}
        {mc &quot;Key bindings&quot; command keys}
    }}
    set bar [list $file $edit $view $help]
} else {
    proc ::tk::mac::ShowPreferences {} {doprefs}
    proc ::tk::mac::Quit {} {doquit}
    lset file end [lreplace [lindex $file end] end-1 end]
    set apple {
    xx &quot;Apple&quot; cascade {
        {mc &quot;About gitk&quot; command about}
        {xx &quot;&quot; separator}
    }}
    set help {
    mc &quot;Help&quot; cascade {
        {mc &quot;Key bindings&quot; command keys}
    }}
    set bar [list $apple $file $view $help]
}
makemenu .bar $bar
. configure -menu .bar

if {$use_ttk} {
    # cover the non-themed toplevel with a themed frame.
    place [ttk::frame ._main_background] -x 0 -y 0 -relwidth 1 -relheight 1
}

# the gui has upper and lower half, parts of a paned window.
${NS}::panedwindow .ctop -orient vertical

# possibly use assumed geometry
if {![info exists geometry(pwsash0)]} {
    set geometry(topheight) [expr {15 * $linespc}]
    set geometry(topwidth) [expr {80 * $charspc}]
    set geometry(botheight) [expr {15 * $linespc}]
    set geometry(botwidth) [expr {50 * $charspc}]
    set geometry(pwsash0) [list [expr {40 * $charspc}] 2]
    set geometry(pwsash1) [list [expr {60 * $charspc}] 2]
}

# the upper half will have a paned window, a scroll bar to the right, and some stuff below
${NS}::frame .tf -height $geometry(topheight) -width $geometry(topwidth)
${NS}::frame .tf.histframe
${NS}::panedwindow .tf.histframe.pwclist -orient horizontal
if {!$use_ttk} {
    .tf.histframe.pwclist configure -sashpad 0 -handlesize 4
}

# create three canvases
set cscroll .tf.histframe.csb
set canv .tf.histframe.pwclist.canv
canvas $canv \
    -selectbackground $selectbgcolor \
    -background $bgcolor -bd 0 \
    -yscrollincr $linespc -yscrollcommand &quot;scrollcanv $cscroll&quot;
.tf.histframe.pwclist add $canv
set canv2 .tf.histframe.pwclist.canv2
canvas $canv2 \
    -selectbackground $selectbgcolor \
    -background $bgcolor -bd 0 -yscrollincr $linespc
.tf.histframe.pwclist add $canv2
set canv3 .tf.histframe.pwclist.canv3
canvas $canv3 \
    -selectbackground $selectbgcolor \
    -background $bgcolor -bd 0 -yscrollincr $linespc
.tf.histframe.pwclist add $canv3
if {$use_ttk} {
    bind .tf.histframe.pwclist &lt;Map&gt; {
        bind %W &lt;Map&gt; {}
        .tf.histframe.pwclist sashpos 1 [lindex $::geometry(pwsash1) 0]
        .tf.histframe.pwclist sashpos 0 [lindex $::geometry(pwsash0) 0]
    }
} else {
    eval .tf.histframe.pwclist sash place 0 $geometry(pwsash0)
    eval .tf.histframe.pwclist sash place 1 $geometry(pwsash1)
}

# a scroll bar to rule them
${NS}::scrollbar $cscroll -command {allcanvs yview}
if {!$use_ttk} {$cscroll configure -highlightthickness 0}
pack $cscroll -side right -fill y
bind .tf.histframe.pwclist &lt;Configure&gt; {resizeclistpanes %W %w}
lappend bglist $canv $canv2 $canv3
pack .tf.histframe.pwclist -fill both -expand 1 -side left

# we have two button bars at bottom of top frame. Bar 1
${NS}::frame .tf.bar
${NS}::frame .tf.lbar -height 15

set sha1entry .tf.bar.sha1
set entries $sha1entry
set sha1but .tf.bar.sha1label
button $sha1but -text &quot;[mc &quot;SHA1 ID:&quot;] &quot; -state disabled -relief flat \
    -command gotocommit -width 8
$sha1but conf -disabledforeground [$sha1but cget -foreground]
pack .tf.bar.sha1label -side left
${NS}::entry $sha1entry -width 40 -font textfont -textvariable sha1string
trace add variable sha1string write sha1change
pack $sha1entry -side left -pady 2

set bm_left_data {
    #define left_width 16
    #define left_height 16
    static unsigned char left_bits[] = {
    0x00, 0x00, 0xc0, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1c, 0x00,
    0x0e, 0x00, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x0e, 0x00, 0x1c, 0x00,
    0x38, 0x00, 0x70, 0x00, 0xe0, 0x00, 0xc0, 0x01};
}
set bm_right_data {
    #define right_width 16
    #define right_height 16
    static unsigned char right_bits[] = {
    0x00, 0x00, 0xc0, 0x01, 0x80, 0x03, 0x00, 0x07, 0x00, 0x0e, 0x00, 0x1c,
    0x00, 0x38, 0xff, 0x7f, 0xff, 0x7f, 0xff, 0x7f, 0x00, 0x38, 0x00, 0x1c,
    0x00, 0x0e, 0x00, 0x07, 0x80, 0x03, 0xc0, 0x01};
}
image create bitmap bm-left -data $bm_left_data -foreground $uifgcolor
image create bitmap bm-left-gray -data $bm_left_data -foreground $uifgdisabledcolor
image create bitmap bm-right -data $bm_right_data -foreground $uifgcolor
image create bitmap bm-right-gray -data $bm_right_data -foreground $uifgdisabledcolor

${NS}::button .tf.bar.leftbut -command goback -state disabled -width 26
if {$use_ttk} {
    .tf.bar.leftbut configure -image [list bm-left disabled bm-left-gray]
} else {
    .tf.bar.leftbut configure -image bm-left
}
pack .tf.bar.leftbut -side left -fill y
${NS}::button .tf.bar.rightbut -command goforw -state disabled -width 26
if {$use_ttk} {
    .tf.bar.rightbut configure -image [list bm-right disabled bm-right-gray]
} else {
    .tf.bar.rightbut configure -image bm-right
}
pack .tf.bar.rightbut -side left -fill y

${NS}::label .tf.bar.rowlabel -text [mc &quot;Row&quot;]
set rownumsel {}
${NS}::label .tf.bar.rownum -width 7 -textvariable rownumsel \
    -relief sunken -anchor e
${NS}::label .tf.bar.rowlabel2 -text &quot;/&quot;
${NS}::label .tf.bar.numcommits -width 7 -textvariable numcommits \
    -relief sunken -anchor e
pack .tf.bar.rowlabel .tf.bar.rownum .tf.bar.rowlabel2 .tf.bar.numcommits \
    -side left
if {!$use_ttk} {
    foreach w {rownum numcommits} {.tf.bar.$w configure -font textfont}
}
global selectedline
trace add variable selectedline write selectedline_change

# Status label and progress bar
set statusw .tf.bar.status
${NS}::label $statusw -width 15 -relief sunken
pack $statusw -side left -padx 5
if {$use_ttk} {
    set progresscanv [ttk::progressbar .tf.bar.progress]
} else {
    set h [expr {[font metrics uifont -linespace] + 2}]
    set progresscanv .tf.bar.progress
    canvas $progresscanv -relief sunken -height $h -borderwidth 2
    set progressitem [$progresscanv create rect -1 0 0 $h -fill green]
    set fprogitem [$progresscanv create rect -1 0 0 $h -fill yellow]
    set rprogitem [$progresscanv create rect -1 0 0 $h -fill red]
}
pack $progresscanv -side right -expand 1 -fill x -padx {0 2}
set progresscoords {0 0}
set fprogcoord 0
set rprogcoord 0
bind $progresscanv &lt;Configure&gt; adjustprogress
set lastprogupdate [clock clicks -milliseconds]
set progupdatepending 0

# build up the bottom bar of upper window
${NS}::label .tf.lbar.flabel -text &quot;[mc &quot;Find&quot;] &quot;
${NS}::button .tf.lbar.fnext -text [mc &quot;next&quot;] -command {dofind 1 1}
${NS}::button .tf.lbar.fprev -text [mc &quot;prev&quot;] -command {dofind -1 1}
${NS}::label .tf.lbar.flab2 -text &quot; [mc &quot;commit&quot;] &quot;
pack .tf.lbar.flabel .tf.lbar.fnext .tf.lbar.fprev .tf.lbar.flab2 \
    -side left -fill y
set gdttype [mc &quot;containing:&quot;]
set gm [makedroplist .tf.lbar.gdttype gdttype \
            [mc &quot;containing:&quot;] \
            [mc &quot;touching paths:&quot;] \
            [mc &quot;adding/removing string:&quot;] \
            [mc &quot;changing lines matching:&quot;]]
trace add variable gdttype write gdttype_change
pack .tf.lbar.gdttype -side left -fill y

set findstring {}
set fstring .tf.lbar.findstring
lappend entries $fstring
${NS}::entry $fstring -width 30 -textvariable findstring
trace add variable findstring write find_change
set findtype [mc &quot;Exact&quot;]
set findtypemenu [makedroplist .tf.lbar.findtype \
                      findtype [mc &quot;Exact&quot;] [mc &quot;IgnCase&quot;] [mc &quot;Regexp&quot;]]
trace add variable findtype write findcom_change
set findloc [mc &quot;All fields&quot;]
makedroplist .tf.lbar.findloc findloc [mc &quot;All fields&quot;] [mc &quot;Headline&quot;] \
    [mc &quot;Comments&quot;] [mc &quot;Author&quot;] [mc &quot;Committer&quot;]
trace add variable findloc write find_change
pack .tf.lbar.findloc -side right
pack .tf.lbar.findtype -side right
pack $fstring -side left -expand 1 -fill x

# Finish putting the upper half of the viewer together
pack .tf.lbar -in .tf -side bottom -fill x
pack .tf.bar -in .tf -side bottom -fill x
pack .tf.histframe -fill both -side top -expand 1
.ctop add .tf
if {!$use_ttk} {
    .ctop paneconfigure .tf -height $geometry(topheight)
    .ctop paneconfigure .tf -width $geometry(topwidth)
}

# now build up the bottom
${NS}::panedwindow .pwbottom -orient horizontal

# lower left, a text box over search bar, scroll bar to the right
# if we know window height, then that will set the lower text height, otherwise
# we set lower text height which will drive window height
if {[info exists geometry(main)]} {
    ${NS}::frame .bleft -width $geometry(botwidth)
} else {
    ${NS}::frame .bleft -width $geometry(botwidth) -height $geometry(botheight)
}
${NS}::frame .bleft.top
${NS}::frame .bleft.mid
${NS}::frame .bleft.bottom

${NS}::button .bleft.top.search -text [mc &quot;Search&quot;] -command dosearch
pack .bleft.top.search -side left -padx 5
set sstring .bleft.top.sstring
set searchstring &quot;&quot;
${NS}::entry $sstring -width 20 -textvariable searchstring
lappend entries $sstring
trace add variable searchstring write incrsearch
pack $sstring -side left -expand 1 -fill x
${NS}::radiobutton .bleft.mid.diff -text [mc &quot;Diff&quot;] \
    -command changediffdisp -variable diffelide -value {0 0}
${NS}::radiobutton .bleft.mid.old -text [mc &quot;Old version&quot;] \
    -command changediffdisp -variable diffelide -value {0 1}
${NS}::radiobutton .bleft.mid.new -text [mc &quot;New version&quot;] \
    -command changediffdisp -variable diffelide -value {1 0}
${NS}::label .bleft.mid.labeldiffcontext -text &quot;      [mc &quot;Lines of context&quot;]: &quot;
pack .bleft.mid.diff .bleft.mid.old .bleft.mid.new -side left
spinbox .bleft.mid.diffcontext -width 5 \
    -from 0 -increment 1 -to 10000000 \
    -validate all -validatecommand &quot;diffcontextvalidate %P&quot; \
    -textvariable diffcontextstring
.bleft.mid.diffcontext set $diffcontext
trace add variable diffcontextstring write diffcontextchange
lappend entries .bleft.mid.diffcontext
pack .bleft.mid.labeldiffcontext .bleft.mid.diffcontext -side left
${NS}::checkbutton .bleft.mid.ignspace -text [mc &quot;Ignore space change&quot;] \
    -command changeignorespace -variable ignorespace
pack .bleft.mid.ignspace -side left -padx 5

set worddiff [mc &quot;Line diff&quot;]
if {[package vcompare $git_version &quot;1.7.2&quot;] &gt;= 0} {
    makedroplist .bleft.mid.worddiff worddiff [mc &quot;Line diff&quot;] \
        [mc &quot;Markup words&quot;] [mc &quot;Color words&quot;]
    trace add variable worddiff write changeworddiff
    pack .bleft.mid.worddiff -side left -padx 5
}

set ctext .bleft.bottom.ctext
text $ctext -background $bgcolor -foreground $fgcolor \
    -state disabled -font textfont \
    -yscrollcommand scrolltext -wrap none \
    -xscrollcommand &quot;.bleft.bottom.sbhorizontal set&quot;
if {$have_tk85} {
    $ctext conf -tabstyle wordprocessor
}
${NS}::scrollbar .bleft.bottom.sb -command &quot;$ctext yview&quot;
${NS}::scrollbar .bleft.bottom.sbhorizontal -command &quot;$ctext xview&quot; -orient h
pack .bleft.top -side top -fill x
pack .bleft.mid -side top -fill x
grid $ctext .bleft.bottom.sb -sticky nsew
grid .bleft.bottom.sbhorizontal -sticky ew
grid columnconfigure .bleft.bottom 0 -weight 1
grid rowconfigure .bleft.bottom 0 -weight 1
grid rowconfigure .bleft.bottom 1 -weight 0
pack .bleft.bottom -side top -fill both -expand 1
lappend bglist $ctext
lappend fglist $ctext

$ctext tag conf comment -wrap $wrapcomment
$ctext tag conf filesep -font textfontbold -fore $filesepfgcolor -back $filesepbgcolor
$ctext tag conf hunksep -fore [lindex $diffcolors 2]
$ctext tag conf d0 -fore [lindex $diffcolors 0]
$ctext tag conf dresult -fore [lindex $diffcolors 1]
$ctext tag conf m0 -fore [lindex $mergecolors 0]
$ctext tag conf m1 -fore [lindex $mergecolors 1]
$ctext tag conf m2 -fore [lindex $mergecolors 2]
$ctext tag conf m3 -fore [lindex $mergecolors 3]
$ctext tag conf m4 -fore [lindex $mergecolors 4]
$ctext tag conf m5 -fore [lindex $mergecolors 5]
$ctext tag conf m6 -fore [lindex $mergecolors 6]
$ctext tag conf m7 -fore [lindex $mergecolors 7]
$ctext tag conf m8 -fore [lindex $mergecolors 8]
$ctext tag conf m9 -fore [lindex $mergecolors 9]
$ctext tag conf m10 -fore [lindex $mergecolors 10]
$ctext tag conf m11 -fore [lindex $mergecolors 11]
$ctext tag conf m12 -fore [lindex $mergecolors 12]
$ctext tag conf m13 -fore [lindex $mergecolors 13]
$ctext tag conf m14 -fore [lindex $mergecolors 14]
$ctext tag conf m15 -fore [lindex $mergecolors 15]
$ctext tag conf mmax -fore darkgrey
set mergemax 16
$ctext tag conf mresult -font textfontbold
$ctext tag conf msep -font textfontbold
$ctext tag conf found -back $foundbgcolor
$ctext tag conf currentsearchhit -back $currentsearchhitbgcolor
$ctext tag conf wwrap -wrap word

.pwbottom add .bleft
if {!$use_ttk} {
    .pwbottom paneconfigure .bleft -width $geometry(botwidth)
}

# lower right
${NS}::frame .bright
${NS}::frame .bright.mode
${NS}::radiobutton .bright.mode.patch -text [mc &quot;Patch&quot;] \
    -command reselectline -variable cmitmode -value &quot;patch&quot;
${NS}::radiobutton .bright.mode.tree -text [mc &quot;Tree&quot;] \
    -command reselectline -variable cmitmode -value &quot;tree&quot;
grid .bright.mode.patch .bright.mode.tree -sticky ew
pack .bright.mode -side top -fill x
set cflist .bright.cfiles
set indent [font measure mainfont &quot;nn&quot;]
text $cflist \
    -selectbackground $selectbgcolor \
    -background $bgcolor -foreground $fgcolor \
    -font mainfont \
    -tabs [list $indent [expr {2 * $indent}]] \
    -yscrollcommand &quot;.bright.sb set&quot; \
    -cursor [. cget -cursor] \
    -spacing1 1 -spacing3 1
lappend bglist $cflist
lappend fglist $cflist
${NS}::scrollbar .bright.sb -command &quot;$cflist yview&quot;
pack .bright.sb -side right -fill y
pack $cflist -side left -fill both -expand 1
$cflist tag configure highlight \
    -background [$cflist cget -selectbackground]
$cflist tag configure bold -font mainfontbold

.pwbottom add .bright
.ctop add .pwbottom

# restore window width &amp; height if known
if {[info exists geometry(main)]} {
    if {[scan $geometry(main) &quot;%dx%d&quot; w h] &gt;= 2} {
        if {$w &gt; [winfo screenwidth .]} {
            set w [winfo screenwidth .]
        }
        if {$h &gt; [winfo screenheight .]} {
            set h [winfo screenheight .]
        }
        wm geometry . &quot;${w}x$h&quot;
    }
}

if {[info exists geometry(state)] &amp;&amp; $geometry(state) eq &quot;zoomed&quot;} {
    wm state . $geometry(state)
}

if {[tk windowingsystem] eq {aqua}} {
    set M1B M1
    set ::BM &quot;3&quot;
} else {
    set M1B Control
    set ::BM &quot;2&quot;
}

if {$use_ttk} {
    bind .ctop &lt;Map&gt; {
        bind %W &lt;Map&gt; {}
        %W sashpos 0 $::geometry(topheight)
    }
    bind .pwbottom &lt;Map&gt; {
        bind %W &lt;Map&gt; {}
        %W sashpos 0 $::geometry(botwidth)
    }
}

bind .pwbottom &lt;Configure&gt; {resizecdetpanes %W %w}
pack .ctop -fill both -expand 1
bindall &lt;1&gt; {selcanvline %W %x %y}
#bindall &lt;B1-Motion&gt; {selcanvline %W %x %y}
if {[tk windowingsystem] == &quot;win32&quot;} {
    bind . &lt;MouseWheel&gt; { windows_mousewheel_redirector %W %X %Y %D }
    bind $ctext &lt;MouseWheel&gt; { windows_mousewheel_redirector %W %X %Y %D ; break }
} else {
    bindall &lt;ButtonRelease-4&gt; &quot;allcanvs yview scroll -5 units&quot;
    bindall &lt;ButtonRelease-5&gt; &quot;allcanvs yview scroll 5 units&quot;
    if {[tk windowingsystem] eq &quot;aqua&quot;} {
        bindall &lt;MouseWheel&gt; {
            set delta [expr {- (%D)}]
            allcanvs yview scroll $delta units
        }
        bindall &lt;Shift-MouseWheel&gt; {
            set delta [expr {- (%D)}]
            $canv xview scroll $delta units
        }
    }
}
bindall &lt;$::BM&gt; &quot;canvscan mark %W %x %y&quot;
bindall &lt;B$::BM-Motion&gt; &quot;canvscan dragto %W %x %y&quot;
bind all &lt;$M1B-Key-w&gt; {destroy [winfo toplevel %W]}
bind . &lt;$M1B-Key-w&gt; doquit
bindkey &lt;Home&gt; selfirstline
bindkey &lt;End&gt; sellastline
bind . &lt;Key-Up&gt; &quot;selnextline -1&quot;
bind . &lt;Key-Down&gt; &quot;selnextline 1&quot;
bind . &lt;Shift-Key-Up&gt; &quot;dofind -1 0&quot;
bind . &lt;Shift-Key-Down&gt; &quot;dofind 1 0&quot;
bindkey &lt;Key-Right&gt; &quot;goforw&quot;
bindkey &lt;Key-Left&gt; &quot;goback&quot;
bind . &lt;Key-Prior&gt; &quot;selnextpage -1&quot;
bind . &lt;Key-Next&gt; &quot;selnextpage 1&quot;
bind . &lt;$M1B-Home&gt; &quot;allcanvs yview moveto 0.0&quot;
bind . &lt;$M1B-End&gt; &quot;allcanvs yview moveto 1.0&quot;
bind . &lt;$M1B-Key-Up&gt; &quot;allcanvs yview scroll -1 units&quot;
bind . &lt;$M1B-Key-Down&gt; &quot;allcanvs yview scroll 1 units&quot;
bind . &lt;$M1B-Key-Prior&gt; &quot;allcanvs yview scroll -1 pages&quot;
bind . &lt;$M1B-Key-Next&gt; &quot;allcanvs yview scroll 1 pages&quot;
bindkey &lt;Key-Delete&gt; &quot;$ctext yview scroll -1 pages&quot;
bindkey &lt;Key-BackSpace&gt; &quot;$ctext yview scroll -1 pages&quot;
bindkey &lt;Key-space&gt; &quot;$ctext yview scroll 1 pages&quot;
bindkey p &quot;selnextline -1&quot;
bindkey n &quot;selnextline 1&quot;
bindkey z &quot;goback&quot;
bindkey x &quot;goforw&quot;
bindkey k &quot;selnextline -1&quot;
bindkey j &quot;selnextline 1&quot;
bindkey h &quot;goback&quot;
bindkey l &quot;goforw&quot;
bindkey b prevfile
bindkey d &quot;$ctext yview scroll 18 units&quot;
bindkey u &quot;$ctext yview scroll -18 units&quot;
bindkey / {focus $fstring}
bindkey &lt;Key-KP_Divide&gt; {focus $fstring}
bindkey &lt;Key-Return&gt; {dofind 1 1}
bindkey ? {dofind -1 1}
bindkey f nextfile
bind . &lt;F5&gt; updatecommits
bindmodfunctionkey Shift 5 reloadcommits
bind . &lt;F2&gt; showrefs
bindmodfunctionkey Shift 4 {newview 0}
bind . &lt;F4&gt; edit_or_newview
bind . &lt;$M1B-q&gt; doquit
bind . &lt;$M1B-f&gt; {dofind 1 1}
bind . &lt;$M1B-g&gt; {dofind 1 0}
bind . &lt;$M1B-r&gt; dosearchback
bind . &lt;$M1B-s&gt; dosearch
bind . &lt;$M1B-equal&gt; {incrfont 1}
bind . &lt;$M1B-plus&gt; {incrfont 1}
bind . &lt;$M1B-KP_Add&gt; {incrfont 1}
bind . &lt;$M1B-minus&gt; {incrfont -1}
bind . &lt;$M1B-KP_Subtract&gt; {incrfont -1}
wm protocol . WM_DELETE_WINDOW doquit
bind . &lt;Destroy&gt; {stop_backends}
bind . &lt;Button-1&gt; &quot;click %W&quot;
bind $fstring &lt;Key-Return&gt; {dofind 1 1}
bind $sha1entry &lt;Key-Return&gt; {gotocommit; break}
bind $sha1entry &lt;&lt;PasteSelection&gt;&gt; clearsha1
bind $cflist &lt;1&gt; {sel_flist %W %x %y; break}
bind $cflist &lt;B1-Motion&gt; {sel_flist %W %x %y; break}
bind $cflist &lt;ButtonRelease-1&gt; {treeclick %W %x %y}
global ctxbut
bind $cflist $ctxbut {pop_flist_menu %W %X %Y %x %y}
bind $ctext $ctxbut {pop_diff_menu %W %X %Y %x %y}
bind $ctext &lt;Button-1&gt; {focus %W}
bind $ctext &lt;&lt;Selection&gt;&gt; rehighlight_search_results

set maincursor [. cget -cursor]
set textcursor [$ctext cget -cursor]
set curtextcursor $textcursor

set rowctxmenu .rowctxmenu
makemenu $rowctxmenu {
    {mc &quot;Diff this -&gt; selected&quot; command {diffvssel 0}}
    {mc &quot;Diff selected -&gt; this&quot; command {diffvssel 1}}
    {mc &quot;Make patch&quot; command mkpatch}
    {mc &quot;Create tag&quot; command mktag}
    {mc &quot;Write commit to file&quot; command writecommit}
    {mc &quot;Create new branch&quot; command mkbranch}
    {mc &quot;Cherry-pick this commit&quot; command cherrypick}
    {mc &quot;Reset HEAD branch to here&quot; command resethead}
    {mc &quot;Mark this commit&quot; command markhere}
    {mc &quot;Return to mark&quot; command gotomark}
    {mc &quot;Find descendant of this and mark&quot; command find_common_desc}
    {mc &quot;Compare with marked commit&quot; command compare_commits}
    {mc &quot;Diff this -&gt; marked commit&quot; command {diffvsmark 0}}
    {mc &quot;Diff marked commit -&gt; this&quot; command {diffvsmark 1}}
    {mc &quot;Revert this commit&quot; command revert}
}
$rowctxmenu configure -tearoff 0

set fakerowmenu .fakerowmenu
makemenu $fakerowmenu {
    {mc &quot;Diff this -&gt; selected&quot; command {diffvssel 0}}
    {mc &quot;Diff selected -&gt; this&quot; command {diffvssel 1}}
    {mc &quot;Make patch&quot; command mkpatch}
    {mc &quot;Diff this -&gt; marked commit&quot; command {diffvsmark 0}}
    {mc &quot;Diff marked commit -&gt; this&quot; command {diffvsmark 1}}
}
$fakerowmenu configure -tearoff 0

set headctxmenu .headctxmenu
makemenu $headctxmenu {
    {mc &quot;Check out this branch&quot; command cobranch}
    {mc &quot;Remove this branch&quot; command rmbranch}
}
$headctxmenu configure -tearoff 0

global flist_menu
set flist_menu .flistctxmenu
makemenu $flist_menu {
    {mc &quot;Highlight this too&quot; command {flist_hl 0}}
    {mc &quot;Highlight this only&quot; command {flist_hl 1}}
    {mc &quot;External diff&quot; command {external_diff}}
    {mc &quot;Blame parent commit&quot; command {external_blame 1}}
}
$flist_menu configure -tearoff 0

global diff_menu
set diff_menu .diffctxmenu
makemenu $diff_menu {
    {mc &quot;Show origin of this line&quot; command show_line_source}
    {mc &quot;Run git gui blame on this line&quot; command {external_blame_diff}}
}
$diff_menu configure -tearoff 0</pre>

<p>}</p>

<p># Windows sends all mouse wheel events to the current focused window, not #
the one where the mouse hovers, so bind those events here and redirect # to
the correct window proc windows_mousewheel_redirector {W X Y D} {</p>

<pre>global canv canv2 canv3
set w [winfo containing -displayof $W $X $Y]
if {$w ne &quot;&quot;} {
    set u [expr {$D &lt; 0 ? 5 : -5}]
    if {$w == $canv || $w == $canv2 || $w == $canv3} {
        allcanvs yview scroll $u units
    } else {
        catch {
            $w yview scroll $u units
        }
    }
}</pre>

<p>}</p>

<p># Update row number label when selectedline changes proc
selectedline_change {n1 n2 op} {</p>

<pre>global selectedline rownumsel

if {$selectedline eq {}} {
    set rownumsel {}
} else {
    set rownumsel [expr {$selectedline + 1}]
}</pre>

<p>}</p>

<p># mouse-2 makes all windows scan vertically, but only the one # the cursor
is in scans horizontally proc canvscan {op w x y} {</p>

<pre>global canv canv2 canv3
foreach c [list $canv $canv2 $canv3] {
    if {$c == $w} {
        $c scan $op $x $y
    } else {
        $c scan $op 0 $y
    }
}</pre>

<p>}</p>

<p>proc scrollcanv {cscroll f0 f1} {</p>

<pre>$cscroll set $f0 $f1
drawvisible
flushhighlights</pre>

<p>}</p>

<p># when we make a key binding for the toplevel, make sure # it doesn&#39;t
get triggered when that key is pressed in the # find string entry widget.
proc bindkey {ev script} {</p>

<pre>global entries
bind . $ev $script
set escript [bind Entry $ev]
if {$escript == {}} {
    set escript [bind Entry &lt;Key&gt;]
}
foreach e $entries {
    bind $e $ev &quot;$escript; break&quot;
}</pre>

<p>}</p>

<p>proc bindmodfunctionkey {mod n script} {</p>

<pre>bind . &lt;$mod-F$n&gt; $script
catch { bind . &lt;$mod-XF86_Switch_VT_$n&gt; $script }</pre>

<p>}</p>

<p># set the focus back to the toplevel for any click outside # the entry
widgets proc click {w} {</p>

<pre>global ctext entries
foreach e [concat $entries $ctext] {
    if {$w == $e} return
}
focus .</pre>

<p>}</p>

<p># Adjust the progress bar for a change in requested extent or canvas size
proc adjustprogress {} {</p>

<pre>global progresscanv progressitem progresscoords
global fprogitem fprogcoord lastprogupdate progupdatepending
global rprogitem rprogcoord use_ttk

if {$use_ttk} {
    $progresscanv configure -value [expr {int($fprogcoord * 100)}]
    return
}

set w [expr {[winfo width $progresscanv] - 4}]
set x0 [expr {$w * [lindex $progresscoords 0]}]
set x1 [expr {$w * [lindex $progresscoords 1]}]
set h [winfo height $progresscanv]
$progresscanv coords $progressitem $x0 0 $x1 $h
$progresscanv coords $fprogitem 0 0 [expr {$w * $fprogcoord}] $h
$progresscanv coords $rprogitem 0 0 [expr {$w * $rprogcoord}] $h
set now [clock clicks -milliseconds]
if {$now &gt;= $lastprogupdate + 100} {
    set progupdatepending 0
    update
} elseif {!$progupdatepending} {
    set progupdatepending 1
    after [expr {$lastprogupdate + 100 - $now}] doprogupdate
}</pre>

<p>}</p>

<p>proc doprogupdate {} {</p>

<pre>global lastprogupdate progupdatepending

if {$progupdatepending} {
    set progupdatepending 0
    set lastprogupdate [clock clicks -milliseconds]
    update
}</pre>

<p>}</p>

<p>proc savestuff {w} {</p>

<pre>global canv canv2 canv3 mainfont textfont uifont tabstop
global stuffsaved findmergefiles maxgraphpct
global maxwidth showneartags showlocalchanges
global viewname viewfiles viewargs viewargscmd viewperm nextviewnum
global cmitmode wrapcomment datetimeformat limitdiffs
global colors uicolor bgcolor fgcolor diffcolors diffcontext selectbgcolor
global uifgcolor uifgdisabledcolor
global headbgcolor headfgcolor headoutlinecolor remotebgcolor
global tagbgcolor tagfgcolor tagoutlinecolor
global reflinecolor filesepbgcolor filesepfgcolor
global mergecolors foundbgcolor currentsearchhitbgcolor
global linehoverbgcolor linehoverfgcolor linehoveroutlinecolor circlecolors
global mainheadcirclecolor workingfilescirclecolor indexcirclecolor
global linkfgcolor circleoutlinecolor
global autoselect autosellen extdifftool perfile_attrs markbgcolor use_ttk
global hideremotes want_ttk maxrefs

if {$stuffsaved} return
if {![winfo viewable .]} return
catch {
    if {[file exists ~/.gitk-new]} {file delete -force ~/.gitk-new}
    set f [open &quot;~/.gitk-new&quot; w]
    if {$::tcl_platform(platform) eq {windows}} {
        file attributes &quot;~/.gitk-new&quot; -hidden true
    }
    puts $f [list set mainfont $mainfont]
    puts $f [list set textfont $textfont]
    puts $f [list set uifont $uifont]
    puts $f [list set tabstop $tabstop]
    puts $f [list set findmergefiles $findmergefiles]
    puts $f [list set maxgraphpct $maxgraphpct]
    puts $f [list set maxwidth $maxwidth]
    puts $f [list set cmitmode $cmitmode]
    puts $f [list set wrapcomment $wrapcomment]
    puts $f [list set autoselect $autoselect]
    puts $f [list set autosellen $autosellen]
    puts $f [list set showneartags $showneartags]
    puts $f [list set maxrefs $maxrefs]
    puts $f [list set hideremotes $hideremotes]
    puts $f [list set showlocalchanges $showlocalchanges]
    puts $f [list set datetimeformat $datetimeformat]
    puts $f [list set limitdiffs $limitdiffs]
    puts $f [list set uicolor $uicolor]
    puts $f [list set want_ttk $want_ttk]
    puts $f [list set bgcolor $bgcolor]
    puts $f [list set fgcolor $fgcolor]
    puts $f [list set uifgcolor $uifgcolor]
    puts $f [list set uifgdisabledcolor $uifgdisabledcolor]
    puts $f [list set colors $colors]
    puts $f [list set diffcolors $diffcolors]
    puts $f [list set mergecolors $mergecolors]
    puts $f [list set markbgcolor $markbgcolor]
    puts $f [list set diffcontext $diffcontext]
    puts $f [list set selectbgcolor $selectbgcolor]
    puts $f [list set foundbgcolor $foundbgcolor]
    puts $f [list set currentsearchhitbgcolor $currentsearchhitbgcolor]
    puts $f [list set extdifftool $extdifftool]
    puts $f [list set perfile_attrs $perfile_attrs]
    puts $f [list set headbgcolor $headbgcolor]
    puts $f [list set headfgcolor $headfgcolor]
    puts $f [list set headoutlinecolor $headoutlinecolor]
    puts $f [list set remotebgcolor $remotebgcolor]
    puts $f [list set tagbgcolor $tagbgcolor]
    puts $f [list set tagfgcolor $tagfgcolor]
    puts $f [list set tagoutlinecolor $tagoutlinecolor]
    puts $f [list set reflinecolor $reflinecolor]
    puts $f [list set filesepbgcolor $filesepbgcolor]
    puts $f [list set filesepfgcolor $filesepfgcolor]
    puts $f [list set linehoverbgcolor $linehoverbgcolor]
    puts $f [list set linehoverfgcolor $linehoverfgcolor]
    puts $f [list set linehoveroutlinecolor $linehoveroutlinecolor]
    puts $f [list set mainheadcirclecolor $mainheadcirclecolor]
    puts $f [list set workingfilescirclecolor $workingfilescirclecolor]
    puts $f [list set indexcirclecolor $indexcirclecolor]
    puts $f [list set circlecolors $circlecolors]
    puts $f [list set linkfgcolor $linkfgcolor]
    puts $f [list set circleoutlinecolor $circleoutlinecolor]

    puts $f &quot;set geometry(main) [wm geometry .]&quot;
    puts $f &quot;set geometry(state) [wm state .]&quot;
    puts $f &quot;set geometry(topwidth) [winfo width .tf]&quot;
    puts $f &quot;set geometry(topheight) [winfo height .tf]&quot;
    if {$use_ttk} {
        puts $f &quot;set geometry(pwsash0) \&quot;[.tf.histframe.pwclist sashpos 0] 1\&quot;&quot;
        puts $f &quot;set geometry(pwsash1) \&quot;[.tf.histframe.pwclist sashpos 1] 1\&quot;&quot;
    } else {
        puts $f &quot;set geometry(pwsash0) \&quot;[.tf.histframe.pwclist sash coord 0]\&quot;&quot;
        puts $f &quot;set geometry(pwsash1) \&quot;[.tf.histframe.pwclist sash coord 1]\&quot;&quot;
    }
    puts $f &quot;set geometry(botwidth) [winfo width .bleft]&quot;
    puts $f &quot;set geometry(botheight) [winfo height .bleft]&quot;

    puts -nonewline $f &quot;set permviews {&quot;
    for {set v 0} {$v &lt; $nextviewnum} {incr v} {
        if {$viewperm($v)} {
            puts $f &quot;{[list $viewname($v) $viewfiles($v) $viewargs($v) $viewargscmd($v)]}&quot;
        }
    }
    puts $f &quot;}&quot;
    close $f
    file rename -force &quot;~/.gitk-new&quot; &quot;~/.gitk&quot;
}
set stuffsaved 1</pre>

<p>}</p>

<p>proc resizeclistpanes {win w} {</p>

<pre>global oldwidth use_ttk
if {[info exists oldwidth($win)]} {
    if {$use_ttk} {
        set s0 [$win sashpos 0]
        set s1 [$win sashpos 1]
    } else {
        set s0 [$win sash coord 0]
        set s1 [$win sash coord 1]
    }
    if {$w &lt; 60} {
        set sash0 [expr {int($w/2 - 2)}]
        set sash1 [expr {int($w*5/6 - 2)}]
    } else {
        set factor [expr {1.0 * $w / $oldwidth($win)}]
        set sash0 [expr {int($factor * [lindex $s0 0])}]
        set sash1 [expr {int($factor * [lindex $s1 0])}]
        if {$sash0 &lt; 30} {
            set sash0 30
        }
        if {$sash1 &lt; $sash0 + 20} {
            set sash1 [expr {$sash0 + 20}]
        }
        if {$sash1 &gt; $w - 10} {
            set sash1 [expr {$w - 10}]
            if {$sash0 &gt; $sash1 - 20} {
                set sash0 [expr {$sash1 - 20}]
            }
        }
    }
    if {$use_ttk} {
        $win sashpos 0 $sash0
        $win sashpos 1 $sash1
    } else {
        $win sash place 0 $sash0 [lindex $s0 1]
        $win sash place 1 $sash1 [lindex $s1 1]
    }
}
set oldwidth($win) $w</pre>

<p>}</p>

<p>proc resizecdetpanes {win w} {</p>

<pre>global oldwidth use_ttk
if {[info exists oldwidth($win)]} {
    if {$use_ttk} {
        set s0 [$win sashpos 0]
    } else {
        set s0 [$win sash coord 0]
    }
    if {$w &lt; 60} {
        set sash0 [expr {int($w*3/4 - 2)}]
    } else {
        set factor [expr {1.0 * $w / $oldwidth($win)}]
        set sash0 [expr {int($factor * [lindex $s0 0])}]
        if {$sash0 &lt; 45} {
            set sash0 45
        }
        if {$sash0 &gt; $w - 15} {
            set sash0 [expr {$w - 15}]
        }
    }
    if {$use_ttk} {
        $win sashpos 0 $sash0
    } else {
        $win sash place 0 $sash0 [lindex $s0 1]
    }
}
set oldwidth($win) $w</pre>

<p>}</p>

<p>proc allcanvs args {</p>

<pre>global canv canv2 canv3
eval $canv $args
eval $canv2 $args
eval $canv3 $args</pre>

<p>}</p>

<p>proc bindall {event action} {</p>

<pre>global canv canv2 canv3
bind $canv $event $action
bind $canv2 $event $action
bind $canv3 $event $action</pre>

<p>}</p>

<p>proc about {} {</p>

<pre>global uifont NS
set w .about
if {[winfo exists $w]} {
    raise $w
    return
}
ttk_toplevel $w
wm title $w [mc &quot;About gitk&quot;]
make_transient $w .
message $w.m -text [mc &quot;</pre>

<p>Gitk - a commit viewer for git</p>

<p>Copyright u00a9 2005-2011 Paul Mackerras</p>

<p>Use and redistribute under the terms of the GNU General Public License“] \</p>

<pre>        -justify center -aspect 400 -border 2 -bg white -relief groove
pack $w.m -side top -fill x -padx 2 -pady 2
${NS}::button $w.ok -text [mc &quot;Close&quot;] -command &quot;destroy $w&quot; -default active
pack $w.ok -side bottom
bind $w &lt;Visibility&gt; &quot;focus $w.ok&quot;
bind $w &lt;Key-Escape&gt; &quot;destroy $w&quot;
bind $w &lt;Key-Return&gt; &quot;destroy $w&quot;
tk::PlaceWindow $w widget .</pre>

<p>}</p>

<p>proc keys {} {</p>

<pre>global NS
set w .keys
if {[winfo exists $w]} {
    raise $w
    return
}
if {[tk windowingsystem] eq {aqua}} {
    set M1T Cmd
} else {
    set M1T Ctrl
}
ttk_toplevel $w
wm title $w [mc &quot;Gitk key bindings&quot;]
make_transient $w .
message $w.m -text &quot;</pre>
<dl class="rdoc-list label-list"><dt>mc “Gitk key bindings:”
<dt>mc “&lt;%s-Q&gt;             Quit” $M1T
<dt>mc “&lt;%s-W&gt;             Close window” $M1T
<dt>mc “&lt;Home&gt;             Move to first commit”
<dt>mc “&lt;End&gt;              Move to last commit”
<dt>mc “&lt;Up&gt;, p, k Move up one commit”
<dt>mc “&lt;Down&gt;, n, j       Move down one commit”
<dt>mc “&lt;Left&gt;, z, h       Go back in history list”
<dt>mc “&lt;Right&gt;, x, l      Go forward in history list”
<dt>mc “&lt;PageUp&gt;   Move up one page in commit list”
<dt>mc “&lt;PageDown&gt; Move down one page in commit list”
<dt>mc “&lt;%s-Home&gt;  Scroll to top of commit list” $M1T
<dt>mc “&lt;%s-End&gt;   Scroll to bottom of commit list” $M1T
<dt>mc “&lt;%s-Up&gt;    Scroll commit list up one line” $M1T
<dt>mc “&lt;%s-Down&gt;  Scroll commit list down one line” $M1T
<dt>mc “&lt;%s-PageUp&gt;        Scroll commit list up one page” $M1T
<dt>mc “&lt;%s-PageDown&gt;      Scroll commit list down one page” $M1T
<dt>mc “&lt;Shift-Up&gt; Find backwards (upwards, later commits)”
<dt>mc “&lt;Shift-Down&gt;       Find forwards (downwards, earlier commits)”
<dt>mc “&lt;Delete&gt;, b        Scroll diff view up one page”
<dt>mc “&lt;Backspace&gt;        Scroll diff view up one page”
<dt>mc “&lt;Space&gt;            Scroll diff view down one page”
<dt>mc “u          Scroll diff view up 18 lines”
<dt>mc “d          Scroll diff view down 18 lines”
<dt>mc “&lt;%s-F&gt;             Find” $M1T
<dt>mc “&lt;%s-G&gt;             Move to next find hit” $M1T
<dt>mc “&lt;Return&gt;   Move to next find hit”
<dt>mc “/          Focus the search box”
<dt>mc “?          Move to previous find hit”
<dt>mc “f          Scroll diff view to next file”
<dt>mc “&lt;%s-S&gt;             Search for next hit in diff view” $M1T
<dt>mc “&lt;%s-R&gt;             Search for previous hit in diff view” $M1T
<dt>mc “&lt;%s-KP+&gt;   Increase font size” $M1T
<dt>mc “&lt;%s-plus&gt;  Increase font size” $M1T
<dt>mc “&lt;%s-KP-&gt;   Decrease font size” $M1T
<dt>mc “&lt;%s-minus&gt; Decrease font size” $M1T
<dt>mc “&lt;F5&gt;               Update”
<dd>
<p>“ \</p>

<pre>        -justify left -bg white -border 2 -relief groove
pack $w.m -side top -fill both -padx 2 -pady 2
${NS}::button $w.ok -text [mc &quot;Close&quot;] -command &quot;destroy $w&quot; -default active
bind $w &lt;Key-Escape&gt; [list destroy $w]
pack $w.ok -side bottom
bind $w &lt;Visibility&gt; &quot;focus $w.ok&quot;
bind $w &lt;Key-Escape&gt; &quot;destroy $w&quot;
bind $w &lt;Key-Return&gt; &quot;destroy $w&quot;</pre>

<p>}</p>

<p># Procedures for manipulating the file list window at the # bottom right of
the overall window.</p>

<p>proc treeview {w l openlevs} {</p>

<pre>global treecontents treediropen treeheight treeparent treeindex

set ix 0
set treeindex() 0
set lev 0
set prefix {}
set prefixend -1
set prefendstack {}
set htstack {}
set ht 0
set treecontents() {}
$w conf -state normal
foreach f $l {
    while {[string range $f 0 $prefixend] ne $prefix} {
        if {$lev &lt;= $openlevs} {
            $w mark set e:$treeindex($prefix) &quot;end -1c&quot;
            $w mark gravity e:$treeindex($prefix) left
        }
        set treeheight($prefix) $ht
        incr ht [lindex $htstack end]
        set htstack [lreplace $htstack end end]
        set prefixend [lindex $prefendstack end]
        set prefendstack [lreplace $prefendstack end end]
        set prefix [string range $prefix 0 $prefixend]
        incr lev -1
    }
    set tail [string range $f [expr {$prefixend+1}] end]
    while {[set slash [string first &quot;/&quot; $tail]] &gt;= 0} {
        lappend htstack $ht
        set ht 0
        lappend prefendstack $prefixend
        incr prefixend [expr {$slash + 1}]
        set d [string range $tail 0 $slash]
        lappend treecontents($prefix) $d
        set oldprefix $prefix
        append prefix $d
        set treecontents($prefix) {}
        set treeindex($prefix) [incr ix]
        set treeparent($prefix) $oldprefix
        set tail [string range $tail [expr {$slash+1}] end]
        if {$lev &lt;= $openlevs} {
            set ht 1
            set treediropen($prefix) [expr {$lev &lt; $openlevs}]
            set bm [expr {$lev == $openlevs? &quot;tri-rt&quot;: &quot;tri-dn&quot;}]
            $w mark set d:$ix &quot;end -1c&quot;
            $w mark gravity d:$ix left
            set str &quot;\n&quot;
            for {set i 0} {$i &lt; $lev} {incr i} {append str &quot;\t&quot;}
            $w insert end $str
            $w image create end -align center -image $bm -padx 1 \
                -name a:$ix
            $w insert end $d [highlight_tag $prefix]
            $w mark set s:$ix &quot;end -1c&quot;
            $w mark gravity s:$ix left
        }
        incr lev
    }
    if {$tail ne {}} {
        if {$lev &lt;= $openlevs} {
            incr ht
            set str &quot;\n&quot;
            for {set i 0} {$i &lt; $lev} {incr i} {append str &quot;\t&quot;}
            $w insert end $str
            $w insert end $tail [highlight_tag $f]
        }
        lappend treecontents($prefix) $tail
    }
}
while {$htstack ne {}} {
    set treeheight($prefix) $ht
    incr ht [lindex $htstack end]
    set htstack [lreplace $htstack end end]
    set prefixend [lindex $prefendstack end]
    set prefendstack [lreplace $prefendstack end end]
    set prefix [string range $prefix 0 $prefixend]
}
$w conf -state disabled</pre>

<p>}</p>

<p>proc linetoelt {l} {</p>

<pre>global treeheight treecontents

set y 2
set prefix {}
while {1} {
    foreach e $treecontents($prefix) {
        if {$y == $l} {
            return &quot;$prefix$e&quot;
        }
        set n 1
        if {[string index $e end] eq &quot;/&quot;} {
            set n $treeheight($prefix$e)
            if {$y + $n &gt; $l} {
                append prefix $e
                incr y
                break
            }
        }
        incr y $n
    }
}</pre>

<p>}</p>

<p>proc highlight_tree {y prefix} {</p>

<pre>global treeheight treecontents cflist

foreach e $treecontents($prefix) {
    set path $prefix$e
    if {[highlight_tag $path] ne {}} {
        $cflist tag add bold $y.0 &quot;$y.0 lineend&quot;
    }
    incr y
    if {[string index $e end] eq &quot;/&quot; &amp;&amp; $treeheight($path) &gt; 1} {
        set y [highlight_tree $y $path]
    }
}
return $y</pre>

<p>}</p>

<p>proc treeclosedir {w dir} {</p>

<pre>global treediropen treeheight treeparent treeindex

set ix $treeindex($dir)
$w conf -state normal
$w delete s:$ix e:$ix
set treediropen($dir) 0
$w image configure a:$ix -image tri-rt
$w conf -state disabled
set n [expr {1 - $treeheight($dir)}]
while {$dir ne {}} {
    incr treeheight($dir) $n
    set dir $treeparent($dir)
}</pre>

<p>}</p>

<p>proc treeopendir {w dir} {</p>

<pre>global treediropen treeheight treeparent treecontents treeindex

set ix $treeindex($dir)
$w conf -state normal
$w image configure a:$ix -image tri-dn
$w mark set e:$ix s:$ix
$w mark gravity e:$ix right
set lev 0
set str &quot;\n&quot;
set n [llength $treecontents($dir)]
for {set x $dir} {$x ne {}} {set x $treeparent($x)} {
    incr lev
    append str &quot;\t&quot;
    incr treeheight($x) $n
}
foreach e $treecontents($dir) {
    set de $dir$e
    if {[string index $e end] eq &quot;/&quot;} {
        set iy $treeindex($de)
        $w mark set d:$iy e:$ix
        $w mark gravity d:$iy left
        $w insert e:$ix $str
        set treediropen($de) 0
        $w image create e:$ix -align center -image tri-rt -padx 1 \
            -name a:$iy
        $w insert e:$ix $e [highlight_tag $de]
        $w mark set s:$iy e:$ix
        $w mark gravity s:$iy left
        set treeheight($de) 1
    } else {
        $w insert e:$ix $str
        $w insert e:$ix $e [highlight_tag $de]
    }
}
$w mark gravity e:$ix right
$w conf -state disabled
set treediropen($dir) 1
set top [lindex [split [$w index @0,0] .] 0]
set ht [$w cget -height]
set l [lindex [split [$w index s:$ix] .] 0]
if {$l &lt; $top} {
    $w yview $l.0
} elseif {$l + $n + 1 &gt; $top + $ht} {
    set top [expr {$l + $n + 2 - $ht}]
    if {$l &lt; $top} {
        set top $l
    }
    $w yview $top.0
}</pre>

<p>}</p>

<p>proc treeclick {w x y} {</p>

<pre>global treediropen cmitmode ctext cflist cflist_top

if {$cmitmode ne &quot;tree&quot;} return
if {![info exists cflist_top]} return
set l [lindex [split [$w index &quot;@$x,$y&quot;] &quot;.&quot;] 0]
$cflist tag remove highlight $cflist_top.0 &quot;$cflist_top.0 lineend&quot;
$cflist tag add highlight $l.0 &quot;$l.0 lineend&quot;
set cflist_top $l
if {$l == 1} {
    $ctext yview 1.0
    return
}
set e [linetoelt $l]
if {[string index $e end] ne &quot;/&quot;} {
    showfile $e
} elseif {$treediropen($e)} {
    treeclosedir $w $e
} else {
    treeopendir $w $e
}</pre>

<p>}</p>

<p>proc setfilelist {id} {</p>

<pre>global treefilelist cflist jump_to_here

treeview $cflist $treefilelist($id) 0
if {$jump_to_here ne {}} {
    set f [lindex $jump_to_here 0]
    if {[lsearch -exact $treefilelist($id) $f] &gt;= 0} {
        showfile $f
    }
}</pre>

<p>}</p>

<p>image create bitmap tri-rt -background black -foreground blue -data {</p>

<pre>#define tri-rt_width 13
#define tri-rt_height 13
static unsigned char tri-rt_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x30, 0x00, 0x70, 0x00, 0xf0, 0x00,
   0xf0, 0x01, 0xf0, 0x00, 0x70, 0x00, 0x30, 0x00, 0x10, 0x00, 0x00, 0x00,
   0x00, 0x00};</pre>

<p>} -maskdata {</p>

<pre>#define tri-rt-mask_width 13
#define tri-rt-mask_height 13
static unsigned char tri-rt-mask_bits[] = {
   0x08, 0x00, 0x18, 0x00, 0x38, 0x00, 0x78, 0x00, 0xf8, 0x00, 0xf8, 0x01,
   0xf8, 0x03, 0xf8, 0x01, 0xf8, 0x00, 0x78, 0x00, 0x38, 0x00, 0x18, 0x00,
   0x08, 0x00};</pre>

<p>} image create bitmap tri-dn -background black -foreground blue -data {</p>

<pre>#define tri-dn_width 13
#define tri-dn_height 13
static unsigned char tri-dn_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x07, 0xf8, 0x03,
   0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00};</pre>

<p>} -maskdata {</p>

<pre>#define tri-dn-mask_width 13
#define tri-dn-mask_height 13
static unsigned char tri-dn-mask_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x1f, 0xfe, 0x0f, 0xfc, 0x07,
   0xf8, 0x03, 0xf0, 0x01, 0xe0, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00};</pre>

<p>}</p>

<p>image create bitmap reficon-T -background black -foreground yellow -data {</p>

<pre>#define tagicon_width 13
#define tagicon_height 9
static unsigned char tagicon_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0xf0, 0x07, 0xf8, 0x07,
   0xfc, 0x07, 0xf8, 0x07, 0xf0, 0x07, 0x00, 0x00, 0x00, 0x00};</pre>

<p>} -maskdata {</p>

<pre>#define tagicon-mask_width 13
#define tagicon-mask_height 9
static unsigned char tagicon-mask_bits[] = {
   0x00, 0x00, 0xf0, 0x0f, 0xf8, 0x0f, 0xfc, 0x0f,
   0xfe, 0x0f, 0xfc, 0x0f, 0xf8, 0x0f, 0xf0, 0x0f, 0x00, 0x00};</pre>

<p>} set rectdata {</p>

<pre>#define headicon_width 13
#define headicon_height 9
static unsigned char headicon_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0xf8, 0x07,
   0xf8, 0x07, 0xf8, 0x07, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00};</pre>

<p>} set rectmask {</p>

<pre>#define headicon-mask_width 13
#define headicon-mask_height 9
static unsigned char headicon-mask_bits[] = {
   0x00, 0x00, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f,
   0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f, 0xfc, 0x0f, 0x00, 0x00};</pre>

<p>} image create bitmap reficon-H -background black -foreground green \</p>

<pre>-data $rectdata -maskdata $rectmask</pre>

<p>image create bitmap reficon-o -background black -foreground “#ddddff” \</p>

<pre>-data $rectdata -maskdata $rectmask</pre>

<p>proc init_flist {first} {</p>

<pre>global cflist cflist_top difffilestart

$cflist conf -state normal
$cflist delete 0.0 end
if {$first ne {}} {
    $cflist insert end $first
    set cflist_top 1
    $cflist tag add highlight 1.0 &quot;1.0 lineend&quot;
} else {
    catch {unset cflist_top}
}
$cflist conf -state disabled
set difffilestart {}</pre>

<p>}</p>

<p>proc highlight_tag {f} {</p>

<pre>global highlight_paths

foreach p $highlight_paths {
    if {[string match $p $f]} {
        return &quot;bold&quot;
    }
}
return {}</pre>

<p>}</p>

<p>proc highlight_filelist {} {</p>

<pre>global cmitmode cflist

$cflist conf -state normal
if {$cmitmode ne &quot;tree&quot;} {
    set end [lindex [split [$cflist index end] .] 0]
    for {set l 2} {$l &lt; $end} {incr l} {
        set line [$cflist get $l.0 &quot;$l.0 lineend&quot;]
        if {[highlight_tag $line] ne {}} {
            $cflist tag add bold $l.0 &quot;$l.0 lineend&quot;
        }
    }
} else {
    highlight_tree 2 {}
}
$cflist conf -state disabled</pre>

<p>}</p>

<p>proc unhighlight_filelist {} {</p>

<pre>global cflist

$cflist conf -state normal
$cflist tag remove bold 1.0 end
$cflist conf -state disabled</pre>

<p>}</p>

<p>proc add_flist {fl} {</p>

<pre>global cflist

$cflist conf -state normal
foreach f $fl {
    $cflist insert end &quot;\n&quot;
    $cflist insert end $f [highlight_tag $f]
}
$cflist conf -state disabled</pre>

<p>}</p>

<p>proc sel_flist {w x y} {</p>

<pre>global ctext difffilestart cflist cflist_top cmitmode

if {$cmitmode eq &quot;tree&quot;} return
if {![info exists cflist_top]} return
set l [lindex [split [$w index &quot;@$x,$y&quot;] &quot;.&quot;] 0]
$cflist tag remove highlight $cflist_top.0 &quot;$cflist_top.0 lineend&quot;
$cflist tag add highlight $l.0 &quot;$l.0 lineend&quot;
set cflist_top $l
if {$l == 1} {
    $ctext yview 1.0
} else {
    catch {$ctext yview [lindex $difffilestart [expr {$l - 2}]]}
}
suppress_highlighting_file_for_current_scrollpos</pre>

<p>}</p>

<p>proc pop_flist_menu {w X Y x y} {</p>

<pre>global ctext cflist cmitmode flist_menu flist_menu_file
global treediffs diffids

stopfinding
set l [lindex [split [$w index &quot;@$x,$y&quot;] &quot;.&quot;] 0]
if {$l &lt;= 1} return
if {$cmitmode eq &quot;tree&quot;} {
    set e [linetoelt $l]
    if {[string index $e end] eq &quot;/&quot;} return
} else {
    set e [lindex $treediffs($diffids) [expr {$l-2}]]
}
set flist_menu_file $e
set xdiffstate &quot;normal&quot;
if {$cmitmode eq &quot;tree&quot;} {
    set xdiffstate &quot;disabled&quot;
}
# Disable &quot;External diff&quot; item in tree mode
$flist_menu entryconf 2 -state $xdiffstate
tk_popup $flist_menu $X $Y</pre>

<p>}</p>

<p>proc find_ctext_fileinfo {line} {</p>

<pre>global ctext_file_names ctext_file_lines

set ok [bsearch $ctext_file_lines $line]
set tline [lindex $ctext_file_lines $ok]

if {$ok &gt;= [llength $ctext_file_lines] || $line &lt; $tline} {
    return {}
} else {
    return [list [lindex $ctext_file_names $ok] $tline]
}</pre>

<p>}</p>

<p>proc pop_diff_menu {w X Y x y} {</p>

<pre>global ctext diff_menu flist_menu_file
global diff_menu_txtpos diff_menu_line
global diff_menu_filebase

set diff_menu_txtpos [split [$w index &quot;@$x,$y&quot;] &quot;.&quot;]
set diff_menu_line [lindex $diff_menu_txtpos 0]
# don&#39;t pop up the menu on hunk-separator or file-separator lines
if {[lsearch -glob [$ctext tag names $diff_menu_line.0] &quot;*sep&quot;] &gt;= 0} {
    return
}
stopfinding
set f [find_ctext_fileinfo $diff_menu_line]
if {$f eq {}} return
set flist_menu_file [lindex $f 0]
set diff_menu_filebase [lindex $f 1]
tk_popup $diff_menu $X $Y</pre>

<p>}</p>

<p>proc flist_hl {only} {</p>

<pre>global flist_menu_file findstring gdttype

set x [shellquote $flist_menu_file]
if {$only || $findstring eq {} || $gdttype ne [mc &quot;touching paths:&quot;]} {
    set findstring $x
} else {
    append findstring &quot; &quot; $x
}
set gdttype [mc &quot;touching paths:&quot;]</pre>

<p>}</p>

<p>proc gitknewtmpdir {} {</p>

<pre>global diffnum gitktmpdir gitdir

if {![info exists gitktmpdir]} {
    set gitktmpdir [file join $gitdir [format &quot;.gitk-tmp.%s&quot; [pid]]]
    if {[catch {file mkdir $gitktmpdir} err]} {
        error_popup &quot;[mc &quot;Error creating temporary directory %s:&quot; $gitktmpdir] $err&quot;
        unset gitktmpdir
        return {}
    }
    set diffnum 0
}
incr diffnum
set diffdir [file join $gitktmpdir $diffnum]
if {[catch {file mkdir $diffdir} err]} {
    error_popup &quot;[mc &quot;Error creating temporary directory %s:&quot; $diffdir] $err&quot;
    return {}
}
return $diffdir</pre>

<p>}</p>

<p>proc save_file_from_commit {filename output what} {</p>

<pre>global nullfile

if {[catch {exec git show $filename -- &gt; $output} err]} {
    if {[string match &quot;fatal: bad revision *&quot; $err]} {
        return $nullfile
    }
    error_popup &quot;[mc &quot;Error getting \&quot;%s\&quot; from %s:&quot; $filename $what] $err&quot;
    return {}
}
return $output</pre>

<p>}</p>

<p>proc external_diff_get_one_file {diffid filename diffdir} {</p>

<pre>global nullid nullid2 nullfile
global worktree

if {$diffid == $nullid} {
    set difffile [file join $worktree $filename]
    if {[file exists $difffile]} {
        return $difffile
    }
    return $nullfile
}
if {$diffid == $nullid2} {
    set difffile [file join $diffdir &quot;\[index\] [file tail $filename]&quot;]
    return [save_file_from_commit :$filename $difffile index]
}
set difffile [file join $diffdir &quot;\[$diffid\] [file tail $filename]&quot;]
return [save_file_from_commit $diffid:$filename $difffile \
           &quot;revision $diffid&quot;]</pre>

<p>}</p>

<p>proc external_diff {} {</p>

<pre>global nullid nullid2
global flist_menu_file
global diffids
global extdifftool

if {[llength $diffids] == 1} {
    # no reference commit given
    set diffidto [lindex $diffids 0]
    if {$diffidto eq $nullid} {
        # diffing working copy with index
        set diffidfrom $nullid2
    } elseif {$diffidto eq $nullid2} {
        # diffing index with HEAD
        set diffidfrom &quot;HEAD&quot;
    } else {
        # use first parent commit
        global parentlist selectedline
        set diffidfrom [lindex $parentlist $selectedline 0]
    }
} else {
    set diffidfrom [lindex $diffids 0]
    set diffidto [lindex $diffids 1]
}

# make sure that several diffs wont collide
set diffdir [gitknewtmpdir]
if {$diffdir eq {}} return

# gather files to diff
set difffromfile [external_diff_get_one_file $diffidfrom $flist_menu_file $diffdir]
set difftofile [external_diff_get_one_file $diffidto $flist_menu_file $diffdir]

if {$difffromfile ne {} &amp;&amp; $difftofile ne {}} {
    set cmd [list [shellsplit $extdifftool] $difffromfile $difftofile]
    if {[catch {set fl [open |$cmd r]} err]} {
        file delete -force $diffdir
        error_popup &quot;$extdifftool: [mc &quot;command failed:&quot;] $err&quot;
    } else {
        fconfigure $fl -blocking 0
        filerun $fl [list delete_at_eof $fl $diffdir]
    }
}</pre>

<p>}</p>

<p>proc find_hunk_blamespec {base line} {</p>

<pre>global ctext

# Find and parse the hunk header
set s_lix [$ctext search -backwards -regexp ^@@ &quot;$line.0 lineend&quot; $base.0]
if {$s_lix eq {}} return

set s_line [$ctext get $s_lix &quot;$s_lix + 1 lines&quot;]
if {![regexp {^@@@*(( -\d+(,\d+)?)+) \+(\d+)(,\d+)? @@} $s_line \
        s_line old_specs osz osz1 new_line nsz]} {
    return
}

# base lines for the parents
set base_lines [list $new_line]
foreach old_spec [lrange [split $old_specs &quot; &quot;] 1 end] {
    if {![regexp -- {-(\d+)(,\d+)?} $old_spec \
            old_spec old_line osz]} {
        return
    }
    lappend base_lines $old_line
}

# Now scan the lines to determine offset within the hunk
set max_parent [expr {[llength $base_lines]-2}]
set dline 0
set s_lno [lindex [split $s_lix &quot;.&quot;] 0]

# Determine if the line is removed
set chunk [$ctext get $line.0 &quot;$line.1 + $max_parent chars&quot;]
if {[string match {[-+ ]*} $chunk]} {
    set removed_idx [string first &quot;-&quot; $chunk]
    # Choose a parent index
    if {$removed_idx &gt;= 0} {
        set parent $removed_idx
    } else {
        set unchanged_idx [string first &quot; &quot; $chunk]
        if {$unchanged_idx &gt;= 0} {
            set parent $unchanged_idx
        } else {
            # blame the current commit
            set parent -1
        }
    }
    # then count other lines that belong to it
    for {set i $line} {[incr i -1] &gt; $s_lno} {} {
        set chunk [$ctext get $i.0 &quot;$i.1 + $max_parent chars&quot;]
        # Determine if the line is removed
        set removed_idx [string first &quot;-&quot; $chunk]
        if {$parent &gt;= 0} {
            set code [string index $chunk $parent]
            if {$code eq &quot;-&quot; || ($removed_idx &lt; 0 &amp;&amp; $code ne &quot;+&quot;)} {
                incr dline
            }
        } else {
            if {$removed_idx &lt; 0} {
                incr dline
            }
        }
    }
    incr parent
} else {
    set parent 0
}

incr dline [lindex $base_lines $parent]
return [list $parent $dline]</pre>

<p>}</p>

<p>proc external_blame_diff {} {</p>

<pre>global currentid cmitmode
global diff_menu_txtpos diff_menu_line
global diff_menu_filebase flist_menu_file

if {$cmitmode eq &quot;tree&quot;} {
    set parent_idx 0
    set line [expr {$diff_menu_line - $diff_menu_filebase}]
} else {
    set hinfo [find_hunk_blamespec $diff_menu_filebase $diff_menu_line]
    if {$hinfo ne {}} {
        set parent_idx [lindex $hinfo 0]
        set line [lindex $hinfo 1]
    } else {
        set parent_idx 0
        set line 0
    }
}

external_blame $parent_idx $line</pre>

<p>}</p>

<p># Find the SHA1 ID of the blob for file $fname in the index # at stage 0 or
2 proc index_sha1 {fname} {</p>

<pre>set f [open [list | git ls-files -s $fname] r]
while {[gets $f line] &gt;= 0} {
    set info [lindex [split $line &quot;\t&quot;] 0]
    set stage [lindex $info 2]
    if {$stage eq &quot;0&quot; || $stage eq &quot;2&quot;} {
        close $f
        return [lindex $info 1]
    }
}
close $f
return {}</pre>

<p>}</p>

<p># Turn an absolute path into one relative to the current directory proc
make_relative {f} {</p>

<pre>if {[file pathtype $f] eq &quot;relative&quot;} {
    return $f
}
set elts [file split $f]
set here [file split [pwd]]
set ei 0
set hi 0
set res {}
foreach d $here {
    if {$ei &lt; $hi || $ei &gt;= [llength $elts] || [lindex $elts $ei] ne $d} {
        lappend res &quot;..&quot;
    } else {
        incr ei
    }
    incr hi
}
set elts [concat $res [lrange $elts $ei end]]
return [eval file join $elts]</pre>

<p>}</p>

<p>proc external_blame {parent_idx {line {}}} {</p>

<pre>global flist_menu_file cdup
global nullid nullid2
global parentlist selectedline currentid

if {$parent_idx &gt; 0} {
    set base_commit [lindex $parentlist $selectedline [expr {$parent_idx-1}]]
} else {
    set base_commit $currentid
}

if {$base_commit eq {} || $base_commit eq $nullid || $base_commit eq $nullid2} {
    error_popup [mc &quot;No such commit&quot;]
    return
}

set cmdline [list git gui blame]
if {$line ne {} &amp;&amp; $line &gt; 1} {
    lappend cmdline &quot;--line=$line&quot;
}
set f [file join $cdup $flist_menu_file]
# Unfortunately it seems git gui blame doesn&#39;t like
# being given an absolute path...
set f [make_relative $f]
lappend cmdline $base_commit $f
if {[catch {eval exec $cmdline &amp;} err]} {
    error_popup &quot;[mc &quot;git gui blame: command failed:&quot;] $err&quot;
}</pre>

<p>}</p>

<p>proc show_line_source {} {</p>

<pre>global cmitmode currentid parents curview blamestuff blameinst
global diff_menu_line diff_menu_filebase flist_menu_file
global nullid nullid2 gitdir cdup

set from_index {}
if {$cmitmode eq &quot;tree&quot;} {
    set id $currentid
    set line [expr {$diff_menu_line - $diff_menu_filebase}]
} else {
    set h [find_hunk_blamespec $diff_menu_filebase $diff_menu_line]
    if {$h eq {}} return
    set pi [lindex $h 0]
    if {$pi == 0} {
        mark_ctext_line $diff_menu_line
        return
    }
    incr pi -1
    if {$currentid eq $nullid} {
        if {$pi &gt; 0} {
            # must be a merge in progress...
            if {[catch {
                # get the last line from .git/MERGE_HEAD
                set f [open [file join $gitdir MERGE_HEAD] r]
                set id [lindex [split [read $f] &quot;\n&quot;] end-1]
                close $f
            } err]} {
                error_popup [mc &quot;Couldn&#39;t read merge head: %s&quot; $err]
                return
            }
        } elseif {$parents($curview,$currentid) eq $nullid2} {
            # need to do the blame from the index
            if {[catch {
                set from_index [index_sha1 $flist_menu_file]
            } err]} {
                error_popup [mc &quot;Error reading index: %s&quot; $err]
                return
            }
        } else {
            set id $parents($curview,$currentid)
        }
    } else {
        set id [lindex $parents($curview,$currentid) $pi]
    }
    set line [lindex $h 1]
}
set blameargs {}
if {$from_index ne {}} {
    lappend blameargs | git cat-file blob $from_index
}
lappend blameargs | git blame -p -L$line,+1
if {$from_index ne {}} {
    lappend blameargs --contents -
} else {
    lappend blameargs $id
}
lappend blameargs -- [file join $cdup $flist_menu_file]
if {[catch {
    set f [open $blameargs r]
} err]} {
    error_popup [mc &quot;Couldn&#39;t start git blame: %s&quot; $err]
    return
}
nowbusy blaming [mc &quot;Searching&quot;]
fconfigure $f -blocking 0
set i [reg_instance $f]
set blamestuff($i) {}
set blameinst $i
filerun $f [list read_line_source $f $i]</pre>

<p>}</p>

<p>proc stopblaming {} {</p>

<pre>global blameinst

if {[info exists blameinst]} {
    stop_instance $blameinst
    unset blameinst
    notbusy blaming
}</pre>

<p>}</p>

<p>proc read_line_source {fd inst} {</p>

<pre>global blamestuff curview commfd blameinst nullid nullid2

while {[gets $fd line] &gt;= 0} {
    lappend blamestuff($inst) $line
}
if {![eof $fd]} {
    return 1
}
unset commfd($inst)
unset blameinst
notbusy blaming
fconfigure $fd -blocking 1
if {[catch {close $fd} err]} {
    error_popup [mc &quot;Error running git blame: %s&quot; $err]
    return 0
}

set fname {}
set line [split [lindex $blamestuff($inst) 0] &quot; &quot;]
set id [lindex $line 0]
set lnum [lindex $line 1]
if {[string length $id] == 40 &amp;&amp; [string is xdigit $id] &amp;&amp;
    [string is digit -strict $lnum]} {
    # look for &quot;filename&quot; line
    foreach l $blamestuff($inst) {
        if {[string match &quot;filename *&quot; $l]} {
            set fname [string range $l 9 end]
            break
        }
    }
}
if {$fname ne {}} {
    # all looks good, select it
    if {$id eq $nullid} {
        # blame uses all-zeroes to mean not committed,
        # which would mean a change in the index
        set id $nullid2
    }
    if {[commitinview $id $curview]} {
        selectline [rowofcommit $id] 1 [list $fname $lnum]
    } else {
        error_popup [mc &quot;That line comes from commit %s, \
                         which is not in this view&quot; [shortids $id]]
    }
} else {
    puts &quot;oops couldn&#39;t parse git blame output&quot;
}
return 0</pre>

<p>}</p>

<p># delete $dir when we see eof on $f (presumably because the child has
exited) proc delete_at_eof {f dir} {</p>

<pre>while {[gets $f line] &gt;= 0} {}
if {[eof $f]} {
    if {[catch {close $f} err]} {
        error_popup &quot;[mc &quot;External diff viewer failed:&quot;] $err&quot;
    }
    file delete -force $dir
    return 0
}
return 1</pre>

<p>}</p>

<p># Functions for adding and removing shell-type quoting</p>

<p>proc shellquote {str} {</p>

<pre>if {![string match &quot;*\[&#39;\&quot;\\ \t]*&quot; $str]} {
    return $str
}
if {![string match &quot;*\[&#39;\&quot;\\]*&quot; $str]} {
    return &quot;\&quot;$str\&quot;&quot;
}
if {![string match &quot;*&#39;*&quot; $str]} {
    return &quot;&#39;$str&#39;&quot;
}
return &quot;\&quot;[string map {\&quot; \\\&quot; \\ \\\\} $str]\&quot;&quot;</pre>

<p>}</p>

<p>proc shellarglist {l} {</p>

<pre>set str {}
foreach a $l {
    if {$str ne {}} {
        append str &quot; &quot;
    }
    append str [shellquote $a]
}
return $str</pre>

<p>}</p>

<p>proc shelldequote {str} {</p>

<pre>set ret {}
set used -1
while {1} {
    incr used
    if {![regexp -start $used -indices &quot;\[&#39;\&quot;\\\\ \t]&quot; $str first]} {
        append ret [string range $str $used end]
        set used [string length $str]
        break
    }
    set first [lindex $first 0]
    set ch [string index $str $first]
    if {$first &gt; $used} {
        append ret [string range $str $used [expr {$first - 1}]]
        set used $first
    }
    if {$ch eq &quot; &quot; || $ch eq &quot;\t&quot;} break
    incr used
    if {$ch eq &quot;&#39;&quot;} {
        set first [string first &quot;&#39;&quot; $str $used]
        if {$first &lt; 0} {
            error &quot;unmatched single-quote&quot;
        }
        append ret [string range $str $used [expr {$first - 1}]]
        set used $first
        continue
    }
    if {$ch eq &quot;\\&quot;} {
        if {$used &gt;= [string length $str]} {
            error &quot;trailing backslash&quot;
        }
        append ret [string index $str $used]
        continue
    }
    # here ch == &quot;\&quot;&quot;
    while {1} {
        if {![regexp -start $used -indices &quot;\[\&quot;\\\\]&quot; $str first]} {
            error &quot;unmatched double-quote&quot;
        }
        set first [lindex $first 0]
        set ch [string index $str $first]
        if {$first &gt; $used} {
            append ret [string range $str $used [expr {$first - 1}]]
            set used $first
        }
        if {$ch eq &quot;\&quot;&quot;} break
        incr used
        append ret [string index $str $used]
        incr used
    }
}
return [list $used $ret]</pre>

<p>}</p>

<p>proc shellsplit {str} {</p>

<pre>set l {}
while {1} {
    set str [string trimleft $str]
    if {$str eq {}} break
    set dq [shelldequote $str]
    set n [lindex $dq 0]
    set word [lindex $dq 1]
    set str [string range $str $n end]
    lappend l $word
}
return $l</pre>

<p>}</p>

<p># Code to implement multiple views</p>

<p>proc newview {ishighlight} {</p>

<pre>global nextviewnum newviewname newishighlight
global revtreeargs viewargscmd newviewopts curview

set newishighlight $ishighlight
set top .gitkview
if {[winfo exists $top]} {
    raise $top
    return
}
decode_view_opts $nextviewnum $revtreeargs
set newviewname($nextviewnum) &quot;[mc &quot;View&quot;] $nextviewnum&quot;
set newviewopts($nextviewnum,perm) 0
set newviewopts($nextviewnum,cmd)  $viewargscmd($curview)
vieweditor $top $nextviewnum [mc &quot;Gitk view definition&quot;]</pre>

<p>}</p>

<p>set known_view_options {</p>

<pre>{perm      b    .  {}               {mc &quot;Remember this view&quot;}}
{reflabel  l    +  {}               {mc &quot;References (space separated list):&quot;}}
{refs      t15  .. {}               {mc &quot;Branches &amp; tags:&quot;}}
{allrefs   b    *. &quot;--all&quot;          {mc &quot;All refs&quot;}}
{branches  b    .  &quot;--branches&quot;     {mc &quot;All (local) branches&quot;}}
{tags      b    .  &quot;--tags&quot;         {mc &quot;All tags&quot;}}
{remotes   b    .  &quot;--remotes&quot;      {mc &quot;All remote-tracking branches&quot;}}
{commitlbl l    +  {}               {mc &quot;Commit Info (regular expressions):&quot;}}
{author    t15  .. &quot;--author=*&quot;     {mc &quot;Author:&quot;}}
{committer t15  .  &quot;--committer=*&quot;  {mc &quot;Committer:&quot;}}
{loginfo   t15  .. &quot;--grep=*&quot;       {mc &quot;Commit Message:&quot;}}
{allmatch  b    .. &quot;--all-match&quot;    {mc &quot;Matches all Commit Info criteria&quot;}}
{changes_l l    +  {}               {mc &quot;Changes to Files:&quot;}}
{pickaxe_s r0   .  {}               {mc &quot;Fixed String&quot;}}
{pickaxe_t r1   .  &quot;--pickaxe-regex&quot;  {mc &quot;Regular Expression&quot;}}
{pickaxe   t15  .. &quot;-S*&quot;            {mc &quot;Search string:&quot;}}
{datelabel l    +  {}               {mc &quot;Commit Dates (\&quot;2 weeks ago\&quot;, \&quot;2009-03-17 15:27:38\&quot;, \&quot;March 17, 2009 15:27:38\&quot;):&quot;}}
{since     t15  ..  {&quot;--since=*&quot; &quot;--after=*&quot;}  {mc &quot;Since:&quot;}}
{until     t15  .   {&quot;--until=*&quot; &quot;--before=*&quot;} {mc &quot;Until:&quot;}}
{limit_lbl l    +  {}               {mc &quot;Limit and/or skip a number of revisions (positive integer):&quot;}}
{limit     t10  *. &quot;--max-count=*&quot;  {mc &quot;Number to show:&quot;}}
{skip      t10  .  &quot;--skip=*&quot;       {mc &quot;Number to skip:&quot;}}
{misc_lbl  l    +  {}               {mc &quot;Miscellaneous options:&quot;}}
{dorder    b    *. {&quot;--date-order&quot; &quot;-d&quot;}      {mc &quot;Strictly sort by date&quot;}}
{lright    b    .  &quot;--left-right&quot;   {mc &quot;Mark branch sides&quot;}}
{first     b    .  &quot;--first-parent&quot; {mc &quot;Limit to first parent&quot;}}
{smplhst   b    .  &quot;--simplify-by-decoration&quot;   {mc &quot;Simple history&quot;}}
{args      t50  *. {}               {mc &quot;Additional arguments to git log:&quot;}}
{allpaths  path +  {}               {mc &quot;Enter files and directories to include, one per line:&quot;}}
{cmd       t50= +  {}               {mc &quot;Command to generate more commits to include:&quot;}}
}</pre>

<p># Convert $newviewopts($n, …) into args for git log. proc encode_view_opts
{n} {</p>

<pre>global known_view_options newviewopts

set rargs [list]
foreach opt $known_view_options {
    set patterns [lindex $opt 3]
    if {$patterns eq {}} continue
    set pattern [lindex $patterns 0]

    if {[lindex $opt 1] eq &quot;b&quot;} {
        set val $newviewopts($n,[lindex $opt 0])
        if {$val} {
            lappend rargs $pattern
        }
    } elseif {[regexp {^r(\d+)$} [lindex $opt 1] type value]} {
        regexp {^(.*_)} [lindex $opt 0] uselessvar button_id
        set val $newviewopts($n,$button_id)
        if {$val eq $value} {
            lappend rargs $pattern
        }
    } else {
        set val $newviewopts($n,[lindex $opt 0])
        set val [string trim $val]
        if {$val ne {}} {
            set pfix [string range $pattern 0 end-1]
            lappend rargs $pfix$val
        }
    }
}
set rargs [concat $rargs [shellsplit $newviewopts($n,refs)]]
return [concat $rargs [shellsplit $newviewopts($n,args)]]</pre>

<p>}</p>

<p># Fill $newviewopts($n, …) based on args for git log. proc decode_view_opts
{n view_args} {</p>

<pre>global known_view_options newviewopts

foreach opt $known_view_options {
    set id [lindex $opt 0]
    if {[lindex $opt 1] eq &quot;b&quot;} {
        # Checkboxes
        set val 0
    } elseif {[regexp {^r(\d+)$} [lindex $opt 1]]} {
        # Radiobuttons
        regexp {^(.*_)} $id uselessvar id
        set val 0
    } else {
        # Text fields
        set val {}
    }
    set newviewopts($n,$id) $val
}
set oargs [list]
set refargs [list]
foreach arg $view_args {
    if {[regexp -- {^-([0-9]+)$} $arg arg cnt]
        &amp;&amp; ![info exists found(limit)]} {
        set newviewopts($n,limit) $cnt
        set found(limit) 1
        continue
    }
    catch { unset val }
    foreach opt $known_view_options {
        set id [lindex $opt 0]
        if {[info exists found($id)]} continue
        foreach pattern [lindex $opt 3] {
            if {![string match $pattern $arg]} continue
            if {[lindex $opt 1] eq &quot;b&quot;} {
                # Check buttons
                set val 1
            } elseif {[regexp {^r(\d+)$} [lindex $opt 1] match num]} {
                # Radio buttons
                regexp {^(.*_)} $id uselessvar id
                set val $num
            } else {
                # Text input fields
                set size [string length $pattern]
                set val [string range $arg [expr {$size-1}] end]
            }
            set newviewopts($n,$id) $val
            set found($id) 1
            break
        }
        if {[info exists val]} break
    }
    if {[info exists val]} continue
    if {[regexp {^-} $arg]} {
        lappend oargs $arg
    } else {
        lappend refargs $arg
    }
}
set newviewopts($n,refs) [shellarglist $refargs]
set newviewopts($n,args) [shellarglist $oargs]</pre>

<p>}</p>

<p>proc edit_or_newview {} {</p>

<pre>global curview

if {$curview &gt; 0} {
    editview
} else {
    newview 0
}</pre>

<p>}</p>

<p>proc editview {} {</p>

<pre>global curview
global viewname viewperm newviewname newviewopts
global viewargs viewargscmd

set top .gitkvedit-$curview
if {[winfo exists $top]} {
    raise $top
    return
}
decode_view_opts $curview $viewargs($curview)
set newviewname($curview)      $viewname($curview)
set newviewopts($curview,perm) $viewperm($curview)
set newviewopts($curview,cmd)  $viewargscmd($curview)
vieweditor $top $curview &quot;[mc &quot;Gitk: edit view&quot;] $viewname($curview)&quot;</pre>

<p>}</p>

<p>proc vieweditor {top n title} {</p>

<pre>global newviewname newviewopts viewfiles bgcolor
global known_view_options NS

ttk_toplevel $top
wm title $top [concat $title [mc &quot;-- criteria for selecting revisions&quot;]]
make_transient $top .

# View name
${NS}::frame $top.nfr
${NS}::label $top.nl -text [mc &quot;View Name&quot;]
${NS}::entry $top.name -width 20 -textvariable newviewname($n)
pack $top.nfr -in $top -fill x -pady 5 -padx 3
pack $top.nl -in $top.nfr -side left -padx {0 5}
pack $top.name -in $top.nfr -side left -padx {0 25}

# View options
set cframe $top.nfr
set cexpand 0
set cnt 0
foreach opt $known_view_options {
    set id [lindex $opt 0]
    set type [lindex $opt 1]
    set flags [lindex $opt 2]
    set title [eval [lindex $opt 4]]
    set lxpad 0

    if {$flags eq &quot;+&quot; || $flags eq &quot;*&quot;} {
        set cframe $top.fr$cnt
        incr cnt
        ${NS}::frame $cframe
        pack $cframe -in $top -fill x -pady 3 -padx 3
        set cexpand [expr {$flags eq &quot;*&quot;}]
    } elseif {$flags eq &quot;..&quot; || $flags eq &quot;*.&quot;} {
        set cframe $top.fr$cnt
        incr cnt
        ${NS}::frame $cframe
        pack $cframe -in $top -fill x -pady 3 -padx [list 15 3]
        set cexpand [expr {$flags eq &quot;*.&quot;}]
    } else {
        set lxpad 5
    }

    if {$type eq &quot;l&quot;} {
        ${NS}::label $cframe.l_$id -text $title
        pack $cframe.l_$id -in $cframe -side left -pady [list 3 0] -anchor w
    } elseif {$type eq &quot;b&quot;} {
        ${NS}::checkbutton $cframe.c_$id -text $title -variable newviewopts($n,$id)
        pack $cframe.c_$id -in $cframe -side left \
            -padx [list $lxpad 0] -expand $cexpand -anchor w
    } elseif {[regexp {^r(\d+)$} $type type sz]} {
        regexp {^(.*_)} $id uselessvar button_id
        ${NS}::radiobutton $cframe.c_$id -text $title -variable newviewopts($n,$button_id) -value $sz
        pack $cframe.c_$id -in $cframe -side left \
            -padx [list $lxpad 0] -expand $cexpand -anchor w
    } elseif {[regexp {^t(\d+)$} $type type sz]} {
        ${NS}::label $cframe.l_$id -text $title
        ${NS}::entry $cframe.e_$id -width $sz -background $bgcolor \
            -textvariable newviewopts($n,$id)
        pack $cframe.l_$id -in $cframe -side left -padx [list $lxpad 0]
        pack $cframe.e_$id -in $cframe -side left -expand 1 -fill x
    } elseif {[regexp {^t(\d+)=$} $type type sz]} {
        ${NS}::label $cframe.l_$id -text $title
        ${NS}::entry $cframe.e_$id -width $sz -background $bgcolor \
            -textvariable newviewopts($n,$id)
        pack $cframe.l_$id -in $cframe -side top -pady [list 3 0] -anchor w
        pack $cframe.e_$id -in $cframe -side top -fill x
    } elseif {$type eq &quot;path&quot;} {
        ${NS}::label $top.l -text $title
        pack $top.l -in $top -side top -pady [list 3 0] -anchor w -padx 3
        text $top.t -width 40 -height 5 -background $bgcolor
        if {[info exists viewfiles($n)]} {
            foreach f $viewfiles($n) {
                $top.t insert end $f
                $top.t insert end &quot;\n&quot;
            }
            $top.t delete {end - 1c} end
            $top.t mark set insert 0.0
        }
        pack $top.t -in $top -side top -pady [list 0 5] -fill both -expand 1 -padx 3
    }
}

${NS}::frame $top.buts
${NS}::button $top.buts.ok -text [mc &quot;OK&quot;] -command [list newviewok $top $n]
${NS}::button $top.buts.apply -text [mc &quot;Apply (F5)&quot;] -command [list newviewok $top $n 1]
${NS}::button $top.buts.can -text [mc &quot;Cancel&quot;] -command [list destroy $top]
bind $top &lt;Control-Return&gt; [list newviewok $top $n]
bind $top &lt;F5&gt; [list newviewok $top $n 1]
bind $top &lt;Escape&gt; [list destroy $top]
grid $top.buts.ok $top.buts.apply $top.buts.can
grid columnconfigure $top.buts 0 -weight 1 -uniform a
grid columnconfigure $top.buts 1 -weight 1 -uniform a
grid columnconfigure $top.buts 2 -weight 1 -uniform a
pack $top.buts -in $top -side top -fill x
focus $top.t</pre>

<p>}</p>

<p>proc doviewmenu {m first cmd op argv} {</p>

<pre>set nmenu [$m index end]
for {set i $first} {$i &lt;= $nmenu} {incr i} {
    if {[$m entrycget $i -command] eq $cmd} {
        eval $m $op $i $argv
        break
    }
}</pre>

<p>}</p>

<p>proc allviewmenus {n op args} {</p>

<pre># global viewhlmenu

doviewmenu .bar.view 5 [list showview $n] $op $args
# doviewmenu $viewhlmenu 1 [list addvhighlight $n] $op $args</pre>

<p>}</p>

<p>proc newviewok {top n {apply 0}} {</p>

<pre>global nextviewnum newviewperm newviewname newishighlight
global viewname viewfiles viewperm selectedview curview
global viewargs viewargscmd newviewopts viewhlmenu

if {[catch {
    set newargs [encode_view_opts $n]
} err]} {
    error_popup &quot;[mc &quot;Error in commit selection arguments:&quot;] $err&quot; $top
    return
}
set files {}
foreach f [split [$top.t get 0.0 end] &quot;\n&quot;] {
    set ft [string trim $f]
    if {$ft ne {}} {
        lappend files $ft
    }
}
if {![info exists viewfiles($n)]} {
    # creating a new view
    incr nextviewnum
    set viewname($n) $newviewname($n)
    set viewperm($n) $newviewopts($n,perm)
    set viewfiles($n) $files
    set viewargs($n) $newargs
    set viewargscmd($n) $newviewopts($n,cmd)
    addviewmenu $n
    if {!$newishighlight} {
        run showview $n
    } else {
        run addvhighlight $n
    }
} else {
    # editing an existing view
    set viewperm($n) $newviewopts($n,perm)
    if {$newviewname($n) ne $viewname($n)} {
        set viewname($n) $newviewname($n)
        doviewmenu .bar.view 5 [list showview $n] \
            entryconf [list -label $viewname($n)]
        # doviewmenu $viewhlmenu 1 [list addvhighlight $n] \
            # entryconf [list -label $viewname($n) -value $viewname($n)]
    }
    if {$files ne $viewfiles($n) || $newargs ne $viewargs($n) || \
            $newviewopts($n,cmd) ne $viewargscmd($n)} {
        set viewfiles($n) $files
        set viewargs($n) $newargs
        set viewargscmd($n) $newviewopts($n,cmd)
        if {$curview == $n} {
            run reloadcommits
        }
    }
}
if {$apply} return
catch {destroy $top}</pre>

<p>}</p>

<p>proc delview {} {</p>

<pre>global curview viewperm hlview selectedhlview

if {$curview == 0} return
if {[info exists hlview] &amp;&amp; $hlview == $curview} {
    set selectedhlview [mc &quot;None&quot;]
    unset hlview
}
allviewmenus $curview delete
set viewperm($curview) 0
showview 0</pre>

<p>}</p>

<p>proc addviewmenu {n} {</p>

<pre>global viewname viewhlmenu

.bar.view add radiobutton -label $viewname($n) \
    -command [list showview $n] -variable selectedview -value $n
#$viewhlmenu add radiobutton -label $viewname($n) \
#   -command [list addvhighlight $n] -variable selectedhlview</pre>

<p>}</p>

<p>proc showview {n} {</p>

<pre>global curview cached_commitrow ordertok
global displayorder parentlist rowidlist rowisopt rowfinal
global colormap rowtextx nextcolor canvxmax
global numcommits viewcomplete
global selectedline currentid canv canvy0
global treediffs
global pending_select mainheadid
global commitidx
global selectedview
global hlview selectedhlview commitinterest

if {$n == $curview} return
set selid {}
set ymax [lindex [$canv cget -scrollregion] 3]
set span [$canv yview]
set ytop [expr {[lindex $span 0] * $ymax}]
set ybot [expr {[lindex $span 1] * $ymax}]
set yscreen [expr {($ybot - $ytop) / 2}]
if {$selectedline ne {}} {
    set selid $currentid
    set y [yc $selectedline]
    if {$ytop &lt; $y &amp;&amp; $y &lt; $ybot} {
        set yscreen [expr {$y - $ytop}]
    }
} elseif {[info exists pending_select]} {
    set selid $pending_select
    unset pending_select
}
unselectline
normalline
catch {unset treediffs}
clear_display
if {[info exists hlview] &amp;&amp; $hlview == $n} {
    unset hlview
    set selectedhlview [mc &quot;None&quot;]
}
catch {unset commitinterest}
catch {unset cached_commitrow}
catch {unset ordertok}

set curview $n
set selectedview $n
.bar.view entryconf [mca &quot;Edit view...&quot;] -state [expr {$n == 0? &quot;disabled&quot;: &quot;normal&quot;}]
.bar.view entryconf [mca &quot;Delete view&quot;] -state [expr {$n == 0? &quot;disabled&quot;: &quot;normal&quot;}]

run refill_reflist
if {![info exists viewcomplete($n)]} {
    getcommits $selid
    return
}

set displayorder {}
set parentlist {}
set rowidlist {}
set rowisopt {}
set rowfinal {}
set numcommits $commitidx($n)

catch {unset colormap}
catch {unset rowtextx}
set nextcolor 0
set canvxmax [$canv cget -width]
set curview $n
set row 0
setcanvscroll
set yf 0
set row {}
if {$selid ne {} &amp;&amp; [commitinview $selid $n]} {
    set row [rowofcommit $selid]
    # try to get the selected row in the same position on the screen
    set ymax [lindex [$canv cget -scrollregion] 3]
    set ytop [expr {[yc $row] - $yscreen}]
    if {$ytop &lt; 0} {
        set ytop 0
    }
    set yf [expr {$ytop * 1.0 / $ymax}]
}
allcanvs yview moveto $yf
drawvisible
if {$row ne {}} {
    selectline $row 0
} elseif {!$viewcomplete($n)} {
    reset_pending_select $selid
} else {
    reset_pending_select {}

    if {[commitinview $pending_select $curview]} {
        selectline [rowofcommit $pending_select] 1
    } else {
        set row [first_real_row]
        if {$row &lt; $numcommits} {
            selectline $row 0
        }
    }
}
if {!$viewcomplete($n)} {
    if {$numcommits == 0} {
        show_status [mc &quot;Reading commits...&quot;]
    }
} elseif {$numcommits == 0} {
    show_status [mc &quot;No commits selected&quot;]
}</pre>

<p>}</p>

<p># Stuff relating to the highlighting facility</p>

<p>proc ishighlighted {id} {</p>

<pre>global vhighlights fhighlights nhighlights rhighlights

if {[info exists nhighlights($id)] &amp;&amp; $nhighlights($id) &gt; 0} {
    return $nhighlights($id)
}
if {[info exists vhighlights($id)] &amp;&amp; $vhighlights($id) &gt; 0} {
    return $vhighlights($id)
}
if {[info exists fhighlights($id)] &amp;&amp; $fhighlights($id) &gt; 0} {
    return $fhighlights($id)
}
if {[info exists rhighlights($id)] &amp;&amp; $rhighlights($id) &gt; 0} {
    return $rhighlights($id)
}
return 0</pre>

<p>}</p>

<p>proc bolden {id font} {</p>

<pre>global canv linehtag currentid boldids need_redisplay markedid

# need_redisplay = 1 means the display is stale and about to be redrawn
if {$need_redisplay} return
lappend boldids $id
$canv itemconf $linehtag($id) -font $font
if {[info exists currentid] &amp;&amp; $id eq $currentid} {
    $canv delete secsel
    set t [eval $canv create rect [$canv bbox $linehtag($id)] \
               -outline {{}} -tags secsel \
               -fill [$canv cget -selectbackground]]
    $canv lower $t
}
if {[info exists markedid] &amp;&amp; $id eq $markedid} {
    make_idmark $id
}</pre>

<p>}</p>

<p>proc bolden_name {id font} {</p>

<pre>global canv2 linentag currentid boldnameids need_redisplay

if {$need_redisplay} return
lappend boldnameids $id
$canv2 itemconf $linentag($id) -font $font
if {[info exists currentid] &amp;&amp; $id eq $currentid} {
    $canv2 delete secsel
    set t [eval $canv2 create rect [$canv2 bbox $linentag($id)] \
               -outline {{}} -tags secsel \
               -fill [$canv2 cget -selectbackground]]
    $canv2 lower $t
}</pre>

<p>}</p>

<p>proc unbolden {} {</p>

<pre>global boldids

set stillbold {}
foreach id $boldids {
    if {![ishighlighted $id]} {
        bolden $id mainfont
    } else {
        lappend stillbold $id
    }
}
set boldids $stillbold</pre>

<p>}</p>

<p>proc addvhighlight {n} {</p>

<pre>global hlview viewcomplete curview vhl_done commitidx

if {[info exists hlview]} {
    delvhighlight
}
set hlview $n
if {$n != $curview &amp;&amp; ![info exists viewcomplete($n)]} {
    start_rev_list $n
}
set vhl_done $commitidx($hlview)
if {$vhl_done &gt; 0} {
    drawvisible
}</pre>

<p>}</p>

<p>proc delvhighlight {} {</p>

<pre>global hlview vhighlights

if {![info exists hlview]} return
unset hlview
catch {unset vhighlights}
unbolden</pre>

<p>}</p>

<p>proc vhighlightmore {} {</p>

<pre>global hlview vhl_done commitidx vhighlights curview

set max $commitidx($hlview)
set vr [visiblerows]
set r0 [lindex $vr 0]
set r1 [lindex $vr 1]
for {set i $vhl_done} {$i &lt; $max} {incr i} {
    set id [commitonrow $i $hlview]
    if {[commitinview $id $curview]} {
        set row [rowofcommit $id]
        if {$r0 &lt;= $row &amp;&amp; $row &lt;= $r1} {
            if {![highlighted $row]} {
                bolden $id mainfontbold
            }
            set vhighlights($id) 1
        }
    }
}
set vhl_done $max
return 0</pre>

<p>}</p>

<p>proc askvhighlight {row id} {</p>

<pre>global hlview vhighlights iddrawn

if {[commitinview $id $hlview]} {
    if {[info exists iddrawn($id)] &amp;&amp; ![ishighlighted $id]} {
        bolden $id mainfontbold
    }
    set vhighlights($id) 1
} else {
    set vhighlights($id) 0
}</pre>

<p>}</p>

<p>proc hfiles_change {} {</p>

<pre>global highlight_files filehighlight fhighlights fh_serial
global highlight_paths

if {[info exists filehighlight]} {
    # delete previous highlights
    catch {close $filehighlight}
    unset filehighlight
    catch {unset fhighlights}
    unbolden
    unhighlight_filelist
}
set highlight_paths {}
after cancel do_file_hl $fh_serial
incr fh_serial
if {$highlight_files ne {}} {
    after 300 do_file_hl $fh_serial
}</pre>

<p>}</p>

<p>proc gdttype_change {name ix op} {</p>

<pre>global gdttype highlight_files findstring findpattern

stopfinding
if {$findstring ne {}} {
    if {$gdttype eq [mc &quot;containing:&quot;]} {
        if {$highlight_files ne {}} {
            set highlight_files {}
            hfiles_change
        }
        findcom_change
    } else {
        if {$findpattern ne {}} {
            set findpattern {}
            findcom_change
        }
        set highlight_files $findstring
        hfiles_change
    }
    drawvisible
}
# enable/disable findtype/findloc menus too</pre>

<p>}</p>

<p>proc find_change {name ix op} {</p>

<pre>global gdttype findstring highlight_files

stopfinding
if {$gdttype eq [mc &quot;containing:&quot;]} {
    findcom_change
} else {
    if {$highlight_files ne $findstring} {
        set highlight_files $findstring
        hfiles_change
    }
}
drawvisible</pre>

<p>}</p>

<p>proc findcom_change args {</p>

<pre>global nhighlights boldnameids
global findpattern findtype findstring gdttype

stopfinding
# delete previous highlights, if any
foreach id $boldnameids {
    bolden_name $id mainfont
}
set boldnameids {}
catch {unset nhighlights}
unbolden
unmarkmatches
if {$gdttype ne [mc &quot;containing:&quot;] || $findstring eq {}} {
    set findpattern {}
} elseif {$findtype eq [mc &quot;Regexp&quot;]} {
    set findpattern $findstring
} else {
    set e [string map {&quot;*&quot; &quot;\\*&quot; &quot;?&quot; &quot;\\?&quot; &quot;\[&quot; &quot;\\\[&quot; &quot;\\&quot; &quot;\\\\&quot;} \
               $findstring]
    set findpattern &quot;*$e*&quot;
}</pre>

<p>}</p>

<p>proc makepatterns {l} {</p>

<pre>set ret {}
foreach e $l {
    set ee [string map {&quot;*&quot; &quot;\\*&quot; &quot;?&quot; &quot;\\?&quot; &quot;\[&quot; &quot;\\\[&quot; &quot;\\&quot; &quot;\\\\&quot;} $e]
    if {[string index $ee end] eq &quot;/&quot;} {
        lappend ret &quot;$ee*&quot;
    } else {
        lappend ret $ee
        lappend ret &quot;$ee/*&quot;
    }
}
return $ret</pre>

<p>}</p>

<p>proc do_file_hl {serial} {</p>

<pre>global highlight_files filehighlight highlight_paths gdttype fhl_list
global cdup findtype

if {$gdttype eq [mc &quot;touching paths:&quot;]} {
    # If &quot;exact&quot; match then convert backslashes to forward slashes.
    # Most useful to support Windows-flavoured file paths.
    if {$findtype eq [mc &quot;Exact&quot;]} {
        set highlight_files [string map {&quot;\\&quot; &quot;/&quot;} $highlight_files]
    }
    if {[catch {set paths [shellsplit $highlight_files]}]} return
    set highlight_paths [makepatterns $paths]
    highlight_filelist
    set relative_paths {}
    foreach path $paths {
        lappend relative_paths [file join $cdup $path]
    }
    set gdtargs [concat -- $relative_paths]
} elseif {$gdttype eq [mc &quot;adding/removing string:&quot;]} {
    set gdtargs [list &quot;-S$highlight_files&quot;]
} elseif {$gdttype eq [mc &quot;changing lines matching:&quot;]} {
    set gdtargs [list &quot;-G$highlight_files&quot;]
} else {
    # must be &quot;containing:&quot;, i.e. we&#39;re searching commit info
    return
}
set cmd [concat | git diff-tree -r -s --stdin $gdtargs]
set filehighlight [open $cmd r+]
fconfigure $filehighlight -blocking 0
filerun $filehighlight readfhighlight
set fhl_list {}
drawvisible
flushhighlights</pre>

<p>}</p>

<p>proc flushhighlights {} {</p>

<pre>global filehighlight fhl_list

if {[info exists filehighlight]} {
    lappend fhl_list {}
    puts $filehighlight &quot;&quot;
    flush $filehighlight
}</pre>

<p>}</p>

<p>proc askfilehighlight {row id} {</p>

<pre>global filehighlight fhighlights fhl_list

lappend fhl_list $id
set fhighlights($id) -1
puts $filehighlight $id</pre>

<p>}</p>

<p>proc readfhighlight {} {</p>

<pre>global filehighlight fhighlights curview iddrawn
global fhl_list find_dirn

if {![info exists filehighlight]} {
    return 0
}
set nr 0
while {[incr nr] &lt;= 100 &amp;&amp; [gets $filehighlight line] &gt;= 0} {
    set line [string trim $line]
    set i [lsearch -exact $fhl_list $line]
    if {$i &lt; 0} continue
    for {set j 0} {$j &lt; $i} {incr j} {
        set id [lindex $fhl_list $j]
        set fhighlights($id) 0
    }
    set fhl_list [lrange $fhl_list [expr {$i+1}] end]
    if {$line eq {}} continue
    if {![commitinview $line $curview]} continue
    if {[info exists iddrawn($line)] &amp;&amp; ![ishighlighted $line]} {
        bolden $line mainfontbold
    }
    set fhighlights($line) 1
}
if {[eof $filehighlight]} {
    # strange...
    puts &quot;oops, git diff-tree died&quot;
    catch {close $filehighlight}
    unset filehighlight
    return 0
}
if {[info exists find_dirn]} {
    run findmore
}
return 1</pre>

<p>}</p>

<p>proc doesmatch {f} {</p>

<pre>global findtype findpattern

if {$findtype eq [mc &quot;Regexp&quot;]} {
    return [regexp $findpattern $f]
} elseif {$findtype eq [mc &quot;IgnCase&quot;]} {
    return [string match -nocase $findpattern $f]
} else {
    return [string match $findpattern $f]
}</pre>

<p>}</p>

<p>proc askfindhighlight {row id} {</p>

<pre>global nhighlights commitinfo iddrawn
global findloc
global markingmatches

if {![info exists commitinfo($id)]} {
    getcommit $id
}
set info $commitinfo($id)
set isbold 0
set fldtypes [list [mc Headline] [mc Author] &quot;&quot; [mc Committer] &quot;&quot; [mc Comments]]
foreach f $info ty $fldtypes {
    if {$ty eq &quot;&quot;} continue
    if {($findloc eq [mc &quot;All fields&quot;] || $findloc eq $ty) &amp;&amp;
        [doesmatch $f]} {
        if {$ty eq [mc &quot;Author&quot;]} {
            set isbold 2
            break
        }
        set isbold 1
    }
}
if {$isbold &amp;&amp; [info exists iddrawn($id)]} {
    if {![ishighlighted $id]} {
        bolden $id mainfontbold
        if {$isbold &gt; 1} {
            bolden_name $id mainfontbold
        }
    }
    if {$markingmatches} {
        markrowmatches $row $id
    }
}
set nhighlights($id) $isbold</pre>

<p>}</p>

<p>proc markrowmatches {row id} {</p>

<pre>global canv canv2 linehtag linentag commitinfo findloc

set headline [lindex $commitinfo($id) 0]
set author [lindex $commitinfo($id) 1]
$canv delete match$row
$canv2 delete match$row
if {$findloc eq [mc &quot;All fields&quot;] || $findloc eq [mc &quot;Headline&quot;]} {
    set m [findmatches $headline]
    if {$m ne {}} {
        markmatches $canv $row $headline $linehtag($id) $m \
            [$canv itemcget $linehtag($id) -font] $row
    }
}
if {$findloc eq [mc &quot;All fields&quot;] || $findloc eq [mc &quot;Author&quot;]} {
    set m [findmatches $author]
    if {$m ne {}} {
        markmatches $canv2 $row $author $linentag($id) $m \
            [$canv2 itemcget $linentag($id) -font] $row
    }
}</pre>

<p>}</p>

<p>proc vrel_change {name ix op} {</p>

<pre>global highlight_related

rhighlight_none
if {$highlight_related ne [mc &quot;None&quot;]} {
    run drawvisible
}</pre>

<p>}</p>

<p># prepare for testing whether commits are descendents or ancestors of a
proc rhighlight_sel {a} {</p>

<pre>global descendent desc_todo ancestor anc_todo
global highlight_related

catch {unset descendent}
set desc_todo [list $a]
catch {unset ancestor}
set anc_todo [list $a]
if {$highlight_related ne [mc &quot;None&quot;]} {
    rhighlight_none
    run drawvisible
}</pre>

<p>}</p>

<p>proc rhighlight_none {} {</p>

<pre>global rhighlights

catch {unset rhighlights}
unbolden</pre>

<p>}</p>

<p>proc is_descendent {a} {</p>

<pre>global curview children descendent desc_todo

set v $curview
set la [rowofcommit $a]
set todo $desc_todo
set leftover {}
set done 0
for {set i 0} {$i &lt; [llength $todo]} {incr i} {
    set do [lindex $todo $i]
    if {[rowofcommit $do] &lt; $la} {
        lappend leftover $do
        continue
    }
    foreach nk $children($v,$do) {
        if {![info exists descendent($nk)]} {
            set descendent($nk) 1
            lappend todo $nk
            if {$nk eq $a} {
                set done 1
            }
        }
    }
    if {$done} {
        set desc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]
        return
    }
}
set descendent($a) 0
set desc_todo $leftover</pre>

<p>}</p>

<p>proc is_ancestor {a} {</p>

<pre>global curview parents ancestor anc_todo

set v $curview
set la [rowofcommit $a]
set todo $anc_todo
set leftover {}
set done 0
for {set i 0} {$i &lt; [llength $todo]} {incr i} {
    set do [lindex $todo $i]
    if {![commitinview $do $v] || [rowofcommit $do] &gt; $la} {
        lappend leftover $do
        continue
    }
    foreach np $parents($v,$do) {
        if {![info exists ancestor($np)]} {
            set ancestor($np) 1
            lappend todo $np
            if {$np eq $a} {
                set done 1
            }
        }
    }
    if {$done} {
        set anc_todo [concat $leftover [lrange $todo [expr {$i+1}] end]]
        return
    }
}
set ancestor($a) 0
set anc_todo $leftover</pre>

<p>}</p>

<p>proc askrelhighlight {row id} {</p>

<pre>global descendent highlight_related iddrawn rhighlights
global selectedline ancestor

if {$selectedline eq {}} return
set isbold 0
if {$highlight_related eq [mc &quot;Descendant&quot;] ||
    $highlight_related eq [mc &quot;Not descendant&quot;]} {
    if {![info exists descendent($id)]} {
        is_descendent $id
    }
    if {$descendent($id) == ($highlight_related eq [mc &quot;Descendant&quot;])} {
        set isbold 1
    }
} elseif {$highlight_related eq [mc &quot;Ancestor&quot;] ||
          $highlight_related eq [mc &quot;Not ancestor&quot;]} {
    if {![info exists ancestor($id)]} {
        is_ancestor $id
    }
    if {$ancestor($id) == ($highlight_related eq [mc &quot;Ancestor&quot;])} {
        set isbold 1
    }
}
if {[info exists iddrawn($id)]} {
    if {$isbold &amp;&amp; ![ishighlighted $id]} {
        bolden $id mainfontbold
    }
}
set rhighlights($id) $isbold</pre>

<p>}</p>

<p># Graph layout functions</p>

<p>proc shortids {ids} {</p>

<pre>set res {}
foreach id $ids {
    if {[llength $id] &gt; 1} {
        lappend res [shortids $id]
    } elseif {[regexp {^[0-9a-f]{40}$} $id]} {
        lappend res [string range $id 0 7]
    } else {
        lappend res $id
    }
}
return $res</pre>

<p>}</p>

<p>proc ntimes {n o} {</p>

<pre>set ret {}
set o [list $o]
for {set mask 1} {$mask &lt;= $n} {incr mask $mask} {
    if {($n &amp; $mask) != 0} {
        set ret [concat $ret $o]
    }
    set o [concat $o $o]
}
return $ret</pre>

<p>}</p>

<p>proc ordertoken {id} {</p>

<pre>global ordertok curview varcid varcstart varctok curview parents children
global nullid nullid2

if {[info exists ordertok($id)]} {
    return $ordertok($id)
}
set origid $id
set todo {}
while {1} {
    if {[info exists varcid($curview,$id)]} {
        set a $varcid($curview,$id)
        set p [lindex $varcstart($curview) $a]
    } else {
        set p [lindex $children($curview,$id) 0]
    }
    if {[info exists ordertok($p)]} {
        set tok $ordertok($p)
        break
    }
    set id [first_real_child $curview,$p]
    if {$id eq {}} {
        # it&#39;s a root
        set tok [lindex $varctok($curview) $varcid($curview,$p)]
        break
    }
    if {[llength $parents($curview,$id)] == 1} {
        lappend todo [list $p {}]
    } else {
        set j [lsearch -exact $parents($curview,$id) $p]
        if {$j &lt; 0} {
            puts &quot;oops didn&#39;t find [shortids $p] in parents of [shortids $id]&quot;
        }
        lappend todo [list $p [strrep $j]]
    }
}
for {set i [llength $todo]} {[incr i -1] &gt;= 0} {} {
    set p [lindex $todo $i 0]
    append tok [lindex $todo $i 1]
    set ordertok($p) $tok
}
set ordertok($origid) $tok
return $tok</pre>

<p>}</p>

<p># Work out where id should go in idlist so that order-token # values
increase from left to right proc idcol {idlist id {i 0}} {</p>

<pre>set t [ordertoken $id]
if {$i &lt; 0} {
    set i 0
}
if {$i &gt;= [llength $idlist] || $t &lt; [ordertoken [lindex $idlist $i]]} {
    if {$i &gt; [llength $idlist]} {
        set i [llength $idlist]
    }
    while {[incr i -1] &gt;= 0 &amp;&amp; $t &lt; [ordertoken [lindex $idlist $i]]} {}
    incr i
} else {
    if {$t &gt; [ordertoken [lindex $idlist $i]]} {
        while {[incr i] &lt; [llength $idlist] &amp;&amp;
               $t &gt;= [ordertoken [lindex $idlist $i]]} {}
    }
}
return $i</pre>

<p>}</p>

<p>proc initlayout {} {</p>

<pre>global rowidlist rowisopt rowfinal displayorder parentlist
global numcommits canvxmax canv
global nextcolor
global colormap rowtextx

set numcommits 0
set displayorder {}
set parentlist {}
set nextcolor 0
set rowidlist {}
set rowisopt {}
set rowfinal {}
set canvxmax [$canv cget -width]
catch {unset colormap}
catch {unset rowtextx}
setcanvscroll</pre>

<p>}</p>

<p>proc setcanvscroll {} {</p>

<pre>global canv canv2 canv3 numcommits linespc canvxmax canvy0
global lastscrollset lastscrollrows

set ymax [expr {$canvy0 + ($numcommits - 0.5) * $linespc + 2}]
$canv conf -scrollregion [list 0 0 $canvxmax $ymax]
$canv2 conf -scrollregion [list 0 0 0 $ymax]
$canv3 conf -scrollregion [list 0 0 0 $ymax]
set lastscrollset [clock clicks -milliseconds]
set lastscrollrows $numcommits</pre>

<p>}</p>

<p>proc visiblerows {} {</p>

<pre>global canv numcommits linespc

set ymax [lindex [$canv cget -scrollregion] 3]
if {$ymax eq {} || $ymax == 0} return
set f [$canv yview]
set y0 [expr {int([lindex $f 0] * $ymax)}]
set r0 [expr {int(($y0 - 3) / $linespc) - 1}]
if {$r0 &lt; 0} {
    set r0 0
}
set y1 [expr {int([lindex $f 1] * $ymax)}]
set r1 [expr {int(($y1 - 3) / $linespc) + 1}]
if {$r1 &gt;= $numcommits} {
    set r1 [expr {$numcommits - 1}]
}
return [list $r0 $r1]</pre>

<p>}</p>

<p>proc layoutmore {} {</p>

<pre>global commitidx viewcomplete curview
global numcommits pending_select curview
global lastscrollset lastscrollrows

if {$lastscrollrows &lt; 100 || $viewcomplete($curview) ||
    [clock clicks -milliseconds] - $lastscrollset &gt; 500} {
    setcanvscroll
}
if {[info exists pending_select] &amp;&amp;
    [commitinview $pending_select $curview]} {
    update
    selectline [rowofcommit $pending_select] 1
}
drawvisible</pre>

<p>}</p>

<p># With path limiting, we mightn&#39;t get the actual HEAD commit, # so ask
git rev-list what is the first ancestor of HEAD that # touches a file in
the path limit. proc get_viewmainhead {view} {</p>

<pre>global viewmainheadid vfilelimit viewinstances mainheadid

catch {
    set rfd [open [concat | git rev-list -1 $mainheadid \
                       -- $vfilelimit($view)] r]
    set j [reg_instance $rfd]
    lappend viewinstances($view) $j
    fconfigure $rfd -blocking 0
    filerun $rfd [list getviewhead $rfd $j $view]
    set viewmainheadid($curview) {}
}</pre>

<p>}</p>

<p># git rev-list should give us just 1 line to use as viewmainheadid($view)
proc getviewhead {fd inst view} {</p>

<pre>global viewmainheadid commfd curview viewinstances showlocalchanges

set id {}
if {[gets $fd line] &lt; 0} {
    if {![eof $fd]} {
        return 1
    }
} elseif {[string length $line] == 40 &amp;&amp; [string is xdigit $line]} {
    set id $line
}
set viewmainheadid($view) $id
close $fd
unset commfd($inst)
set i [lsearch -exact $viewinstances($view) $inst]
if {$i &gt;= 0} {
    set viewinstances($view) [lreplace $viewinstances($view) $i $i]
}
if {$showlocalchanges &amp;&amp; $id ne {} &amp;&amp; $view == $curview} {
    doshowlocalchanges
}
return 0</pre>

<p>}</p>

<p>proc doshowlocalchanges {} {</p>

<pre>global curview viewmainheadid

if {$viewmainheadid($curview) eq {}} return
if {[commitinview $viewmainheadid($curview) $curview]} {
    dodiffindex
} else {
    interestedin $viewmainheadid($curview) dodiffindex
}</pre>

<p>}</p>

<p>proc dohidelocalchanges {} {</p>

<pre>global nullid nullid2 lserial curview

if {[commitinview $nullid $curview]} {
    removefakerow $nullid
}
if {[commitinview $nullid2 $curview]} {
    removefakerow $nullid2
}
incr lserial</pre>

<p>}</p>

<p># spawn off a process to do git diff-index –cached HEAD proc dodiffindex {}
{</p>

<pre>global lserial showlocalchanges vfilelimit curview
global hasworktree

if {!$showlocalchanges || !$hasworktree} return
incr lserial
set cmd &quot;|git diff-index --cached HEAD&quot;
if {$vfilelimit($curview) ne {}} {
    set cmd [concat $cmd -- $vfilelimit($curview)]
}
set fd [open $cmd r]
fconfigure $fd -blocking 0
set i [reg_instance $fd]
filerun $fd [list readdiffindex $fd $lserial $i]</pre>

<p>}</p>

<p>proc readdiffindex {fd serial inst} {</p>

<pre>global viewmainheadid nullid nullid2 curview commitinfo commitdata lserial
global vfilelimit

set isdiff 1
if {[gets $fd line] &lt; 0} {
    if {![eof $fd]} {
        return 1
    }
    set isdiff 0
}
# we only need to see one line and we don&#39;t really care what it says...
stop_instance $inst

if {$serial != $lserial} {
    return 0
}

# now see if there are any local changes not checked in to the index
set cmd &quot;|git diff-files&quot;
if {$vfilelimit($curview) ne {}} {
    set cmd [concat $cmd -- $vfilelimit($curview)]
}
set fd [open $cmd r]
fconfigure $fd -blocking 0
set i [reg_instance $fd]
filerun $fd [list readdifffiles $fd $serial $i]

if {$isdiff &amp;&amp; ![commitinview $nullid2 $curview]} {
    # add the line for the changes in the index to the graph
    set hl [mc &quot;Local changes checked in to index but not committed&quot;]
    set commitinfo($nullid2) [list  $hl {} {} {} {} &quot;    $hl\n&quot;]
    set commitdata($nullid2) &quot;\n    $hl\n&quot;
    if {[commitinview $nullid $curview]} {
        removefakerow $nullid
    }
    insertfakerow $nullid2 $viewmainheadid($curview)
} elseif {!$isdiff &amp;&amp; [commitinview $nullid2 $curview]} {
    if {[commitinview $nullid $curview]} {
        removefakerow $nullid
    }
    removefakerow $nullid2
}
return 0</pre>

<p>}</p>

<p>proc readdifffiles {fd serial inst} {</p>

<pre>global viewmainheadid nullid nullid2 curview
global commitinfo commitdata lserial

set isdiff 1
if {[gets $fd line] &lt; 0} {
    if {![eof $fd]} {
        return 1
    }
    set isdiff 0
}
# we only need to see one line and we don&#39;t really care what it says...
stop_instance $inst

if {$serial != $lserial} {
    return 0
}

if {$isdiff &amp;&amp; ![commitinview $nullid $curview]} {
    # add the line for the local diff to the graph
    set hl [mc &quot;Local uncommitted changes, not checked in to index&quot;]
    set commitinfo($nullid) [list  $hl {} {} {} {} &quot;    $hl\n&quot;]
    set commitdata($nullid) &quot;\n    $hl\n&quot;
    if {[commitinview $nullid2 $curview]} {
        set p $nullid2
    } else {
        set p $viewmainheadid($curview)
    }
    insertfakerow $nullid $p
} elseif {!$isdiff &amp;&amp; [commitinview $nullid $curview]} {
    removefakerow $nullid
}
return 0</pre>

<p>}</p>

<p>proc nextuse {id row} {</p>

<pre>global curview children

if {[info exists children($curview,$id)]} {
    foreach kid $children($curview,$id) {
        if {![commitinview $kid $curview]} {
            return -1
        }
        if {[rowofcommit $kid] &gt; $row} {
            return [rowofcommit $kid]
        }
    }
}
if {[commitinview $id $curview]} {
    return [rowofcommit $id]
}
return -1</pre>

<p>}</p>

<p>proc prevuse {id row} {</p>

<pre>global curview children

set ret -1
if {[info exists children($curview,$id)]} {
    foreach kid $children($curview,$id) {
        if {![commitinview $kid $curview]} break
        if {[rowofcommit $kid] &lt; $row} {
            set ret [rowofcommit $kid]
        }
    }
}
return $ret</pre>

<p>}</p>

<p>proc make_idlist {row} {</p>

<pre>global displayorder parentlist uparrowlen downarrowlen mingaplen
global commitidx curview children

set r [expr {$row - $mingaplen - $downarrowlen - 1}]
if {$r &lt; 0} {
    set r 0
}
set ra [expr {$row - $downarrowlen}]
if {$ra &lt; 0} {
    set ra 0
}
set rb [expr {$row + $uparrowlen}]
if {$rb &gt; $commitidx($curview)} {
    set rb $commitidx($curview)
}
make_disporder $r [expr {$rb + 1}]
set ids {}
for {} {$r &lt; $ra} {incr r} {
    set nextid [lindex $displayorder [expr {$r + 1}]]
    foreach p [lindex $parentlist $r] {
        if {$p eq $nextid} continue
        set rn [nextuse $p $r]
        if {$rn &gt;= $row &amp;&amp;
            $rn &lt;= $r + $downarrowlen + $mingaplen + $uparrowlen} {
            lappend ids [list [ordertoken $p] $p]
        }
    }
}
for {} {$r &lt; $row} {incr r} {
    set nextid [lindex $displayorder [expr {$r + 1}]]
    foreach p [lindex $parentlist $r] {
        if {$p eq $nextid} continue
        set rn [nextuse $p $r]
        if {$rn &lt; 0 || $rn &gt;= $row} {
            lappend ids [list [ordertoken $p] $p]
        }
    }
}
set id [lindex $displayorder $row]
lappend ids [list [ordertoken $id] $id]
while {$r &lt; $rb} {
    foreach p [lindex $parentlist $r] {
        set firstkid [lindex $children($curview,$p) 0]
        if {[rowofcommit $firstkid] &lt; $row} {
            lappend ids [list [ordertoken $p] $p]
        }
    }
    incr r
    set id [lindex $displayorder $r]
    if {$id ne {}} {
        set firstkid [lindex $children($curview,$id) 0]
        if {$firstkid ne {} &amp;&amp; [rowofcommit $firstkid] &lt; $row} {
            lappend ids [list [ordertoken $id] $id]
        }
    }
}
set idlist {}
foreach idx [lsort -unique $ids] {
    lappend idlist [lindex $idx 1]
}
return $idlist</pre>

<p>}</p>

<p>proc rowsequal {a b} {</p>

<pre>while {[set i [lsearch -exact $a {}]] &gt;= 0} {
    set a [lreplace $a $i $i]
}
while {[set i [lsearch -exact $b {}]] &gt;= 0} {
    set b [lreplace $b $i $i]
}
return [expr {$a eq $b}]</pre>

<p>}</p>

<p>proc makeupline {id row rend col} {</p>

<pre>global rowidlist uparrowlen downarrowlen mingaplen

for {set r $rend} {1} {set r $rstart} {
    set rstart [prevuse $id $r]
    if {$rstart &lt; 0} return
    if {$rstart &lt; $row} break
}
if {$rstart + $uparrowlen + $mingaplen + $downarrowlen &lt; $rend} {
    set rstart [expr {$rend - $uparrowlen - 1}]
}
for {set r $rstart} {[incr r] &lt;= $row} {} {
    set idlist [lindex $rowidlist $r]
    if {$idlist ne {} &amp;&amp; [lsearch -exact $idlist $id] &lt; 0} {
        set col [idcol $idlist $id $col]
        lset rowidlist $r [linsert $idlist $col $id]
        changedrow $r
    }
}</pre>

<p>}</p>

<p>proc layoutrows {row endrow} {</p>

<pre>global rowidlist rowisopt rowfinal displayorder
global uparrowlen downarrowlen maxwidth mingaplen
global children parentlist
global commitidx viewcomplete curview

make_disporder [expr {$row - 1}] [expr {$endrow + $uparrowlen}]
set idlist {}
if {$row &gt; 0} {
    set rm1 [expr {$row - 1}]
    foreach id [lindex $rowidlist $rm1] {
        if {$id ne {}} {
            lappend idlist $id
        }
    }
    set final [lindex $rowfinal $rm1]
}
for {} {$row &lt; $endrow} {incr row} {
    set rm1 [expr {$row - 1}]
    if {$rm1 &lt; 0 || $idlist eq {}} {
        set idlist [make_idlist $row]
        set final 1
    } else {
        set id [lindex $displayorder $rm1]
        set col [lsearch -exact $idlist $id]
        set idlist [lreplace $idlist $col $col]
        foreach p [lindex $parentlist $rm1] {
            if {[lsearch -exact $idlist $p] &lt; 0} {
                set col [idcol $idlist $p $col]
                set idlist [linsert $idlist $col $p]
                # if not the first child, we have to insert a line going up
                if {$id ne [lindex $children($curview,$p) 0]} {
                    makeupline $p $rm1 $row $col
                }
            }
        }
        set id [lindex $displayorder $row]
        if {$row &gt; $downarrowlen} {
            set termrow [expr {$row - $downarrowlen - 1}]
            foreach p [lindex $parentlist $termrow] {
                set i [lsearch -exact $idlist $p]
                if {$i &lt; 0} continue
                set nr [nextuse $p $termrow]
                if {$nr &lt; 0 || $nr &gt;= $row + $mingaplen + $uparrowlen} {
                    set idlist [lreplace $idlist $i $i]
                }
            }
        }
        set col [lsearch -exact $idlist $id]
        if {$col &lt; 0} {
            set col [idcol $idlist $id]
            set idlist [linsert $idlist $col $id]
            if {$children($curview,$id) ne {}} {
                makeupline $id $rm1 $row $col
            }
        }
        set r [expr {$row + $uparrowlen - 1}]
        if {$r &lt; $commitidx($curview)} {
            set x $col
            foreach p [lindex $parentlist $r] {
                if {[lsearch -exact $idlist $p] &gt;= 0} continue
                set fk [lindex $children($curview,$p) 0]
                if {[rowofcommit $fk] &lt; $row} {
                    set x [idcol $idlist $p $x]
                    set idlist [linsert $idlist $x $p]
                }
            }
            if {[incr r] &lt; $commitidx($curview)} {
                set p [lindex $displayorder $r]
                if {[lsearch -exact $idlist $p] &lt; 0} {
                    set fk [lindex $children($curview,$p) 0]
                    if {$fk ne {} &amp;&amp; [rowofcommit $fk] &lt; $row} {
                        set x [idcol $idlist $p $x]
                        set idlist [linsert $idlist $x $p]
                    }
                }
            }
        }
    }
    if {$final &amp;&amp; !$viewcomplete($curview) &amp;&amp;
        $row + $uparrowlen + $mingaplen + $downarrowlen
            &gt;= $commitidx($curview)} {
        set final 0
    }
    set l [llength $rowidlist]
    if {$row == $l} {
        lappend rowidlist $idlist
        lappend rowisopt 0
        lappend rowfinal $final
    } elseif {$row &lt; $l} {
        if {![rowsequal $idlist [lindex $rowidlist $row]]} {
            lset rowidlist $row $idlist
            changedrow $row
        }
        lset rowfinal $row $final
    } else {
        set pad [ntimes [expr {$row - $l}] {}]
        set rowidlist [concat $rowidlist $pad]
        lappend rowidlist $idlist
        set rowfinal [concat $rowfinal $pad]
        lappend rowfinal $final
        set rowisopt [concat $rowisopt [ntimes [expr {$row - $l + 1}] 0]]
    }
}
return $row</pre>

<p>}</p>

<p>proc changedrow {row} {</p>

<pre>global displayorder iddrawn rowisopt need_redisplay

set l [llength $rowisopt]
if {$row &lt; $l} {
    lset rowisopt $row 0
    if {$row + 1 &lt; $l} {
        lset rowisopt [expr {$row + 1}] 0
        if {$row + 2 &lt; $l} {
            lset rowisopt [expr {$row + 2}] 0
        }
    }
}
set id [lindex $displayorder $row]
if {[info exists iddrawn($id)]} {
    set need_redisplay 1
}</pre>

<p>}</p>

<p>proc insert_pad {row col npad} {</p>

<pre>global rowidlist

set pad [ntimes $npad {}]
set idlist [lindex $rowidlist $row]
set bef [lrange $idlist 0 [expr {$col - 1}]]
set aft [lrange $idlist $col end]
set i [lsearch -exact $aft {}]
if {$i &gt; 0} {
    set aft [lreplace $aft $i $i]
}
lset rowidlist $row [concat $bef $pad $aft]
changedrow $row</pre>

<p>}</p>

<p>proc optimize_rows {row col endrow} {</p>

<pre>global rowidlist rowisopt displayorder curview children

if {$row &lt; 1} {
    set row 1
}
for {} {$row &lt; $endrow} {incr row; set col 0} {
    if {[lindex $rowisopt $row]} continue
    set haspad 0
    set y0 [expr {$row - 1}]
    set ym [expr {$row - 2}]
    set idlist [lindex $rowidlist $row]
    set previdlist [lindex $rowidlist $y0]
    if {$idlist eq {} || $previdlist eq {}} continue
    if {$ym &gt;= 0} {
        set pprevidlist [lindex $rowidlist $ym]
        if {$pprevidlist eq {}} continue
    } else {
        set pprevidlist {}
    }
    set x0 -1
    set xm -1
    for {} {$col &lt; [llength $idlist]} {incr col} {
        set id [lindex $idlist $col]
        if {[lindex $previdlist $col] eq $id} continue
        if {$id eq {}} {
            set haspad 1
            continue
        }
        set x0 [lsearch -exact $previdlist $id]
        if {$x0 &lt; 0} continue
        set z [expr {$x0 - $col}]
        set isarrow 0
        set z0 {}
        if {$ym &gt;= 0} {
            set xm [lsearch -exact $pprevidlist $id]
            if {$xm &gt;= 0} {
                set z0 [expr {$xm - $x0}]
            }
        }
        if {$z0 eq {}} {
            # if row y0 is the first child of $id then it&#39;s not an arrow
            if {[lindex $children($curview,$id) 0] ne
                [lindex $displayorder $y0]} {
                set isarrow 1
            }
        }
        if {!$isarrow &amp;&amp; $id ne [lindex $displayorder $row] &amp;&amp;
            [lsearch -exact [lindex $rowidlist [expr {$row+1}]] $id] &lt; 0} {
            set isarrow 1
        }
        # Looking at lines from this row to the previous row,
        # make them go straight up if they end in an arrow on
        # the previous row; otherwise make them go straight up
        # or at 45 degrees.
        if {$z &lt; -1 || ($z &lt; 0 &amp;&amp; $isarrow)} {
            # Line currently goes left too much;
            # insert pads in the previous row, then optimize it
            set npad [expr {-1 - $z + $isarrow}]
            insert_pad $y0 $x0 $npad
            if {$y0 &gt; 0} {
                optimize_rows $y0 $x0 $row
            }
            set previdlist [lindex $rowidlist $y0]
            set x0 [lsearch -exact $previdlist $id]
            set z [expr {$x0 - $col}]
            if {$z0 ne {}} {
                set pprevidlist [lindex $rowidlist $ym]
                set xm [lsearch -exact $pprevidlist $id]
                set z0 [expr {$xm - $x0}]
            }
        } elseif {$z &gt; 1 || ($z &gt; 0 &amp;&amp; $isarrow)} {
            # Line currently goes right too much;
            # insert pads in this line
            set npad [expr {$z - 1 + $isarrow}]
            insert_pad $row $col $npad
            set idlist [lindex $rowidlist $row]
            incr col $npad
            set z [expr {$x0 - $col}]
            set haspad 1
        }
        if {$z0 eq {} &amp;&amp; !$isarrow &amp;&amp; $ym &gt;= 0} {
            # this line links to its first child on row $row-2
            set id [lindex $displayorder $ym]
            set xc [lsearch -exact $pprevidlist $id]
            if {$xc &gt;= 0} {
                set z0 [expr {$xc - $x0}]
            }
        }
        # avoid lines jigging left then immediately right
        if {$z0 ne {} &amp;&amp; $z &lt; 0 &amp;&amp; $z0 &gt; 0} {
            insert_pad $y0 $x0 1
            incr x0
            optimize_rows $y0 $x0 $row
            set previdlist [lindex $rowidlist $y0]
        }
    }
    if {!$haspad} {
        # Find the first column that doesn&#39;t have a line going right
        for {set col [llength $idlist]} {[incr col -1] &gt;= 0} {} {
            set id [lindex $idlist $col]
            if {$id eq {}} break
            set x0 [lsearch -exact $previdlist $id]
            if {$x0 &lt; 0} {
                # check if this is the link to the first child
                set kid [lindex $displayorder $y0]
                if {[lindex $children($curview,$id) 0] eq $kid} {
                    # it is, work out offset to child
                    set x0 [lsearch -exact $previdlist $kid]
                }
            }
            if {$x0 &lt;= $col} break
        }
        # Insert a pad at that column as long as it has a line and
        # isn&#39;t the last column
        if {$x0 &gt;= 0 &amp;&amp; [incr col] &lt; [llength $idlist]} {
            set idlist [linsert $idlist $col {}]
            lset rowidlist $row $idlist
            changedrow $row
        }
    }
}</pre>

<p>}</p>

<p>proc xc {row col} {</p>

<pre>global canvx0 linespc
return [expr {$canvx0 + $col * $linespc}]</pre>

<p>}</p>

<p>proc yc {row} {</p>

<pre>global canvy0 linespc
return [expr {$canvy0 + $row * $linespc}]</pre>

<p>}</p>

<p>proc linewidth {id} {</p>

<pre>global thickerline lthickness

set wid $lthickness
if {[info exists thickerline] &amp;&amp; $id eq $thickerline} {
    set wid [expr {2 * $lthickness}]
}
return $wid</pre>

<p>}</p>

<p>proc rowranges {id} {</p>

<pre>global curview children uparrowlen downarrowlen
global rowidlist

set kids $children($curview,$id)
if {$kids eq {}} {
    return {}
}
set ret {}
lappend kids $id
foreach child $kids {
    if {![commitinview $child $curview]} break
    set row [rowofcommit $child]
    if {![info exists prev]} {
        lappend ret [expr {$row + 1}]
    } else {
        if {$row &lt;= $prevrow} {
            puts &quot;oops children of [shortids $id] out of order [shortids $child] $row &lt;= [shortids $prev] $prevrow&quot;
        }
        # see if the line extends the whole way from prevrow to row
        if {$row &gt; $prevrow + $uparrowlen + $downarrowlen &amp;&amp;
            [lsearch -exact [lindex $rowidlist \
                        [expr {int(($row + $prevrow) / 2)}]] $id] &lt; 0} {
            # it doesn&#39;t, see where it ends
            set r [expr {$prevrow + $downarrowlen}]
            if {[lsearch -exact [lindex $rowidlist $r] $id] &lt; 0} {
                while {[incr r -1] &gt; $prevrow &amp;&amp;
                       [lsearch -exact [lindex $rowidlist $r] $id] &lt; 0} {}
            } else {
                while {[incr r] &lt;= $row &amp;&amp;
                       [lsearch -exact [lindex $rowidlist $r] $id] &gt;= 0} {}
                incr r -1
            }
            lappend ret $r
            # see where it starts up again
            set r [expr {$row - $uparrowlen}]
            if {[lsearch -exact [lindex $rowidlist $r] $id] &lt; 0} {
                while {[incr r] &lt; $row &amp;&amp;
                       [lsearch -exact [lindex $rowidlist $r] $id] &lt; 0} {}
            } else {
                while {[incr r -1] &gt;= $prevrow &amp;&amp;
                       [lsearch -exact [lindex $rowidlist $r] $id] &gt;= 0} {}
                incr r
            }
            lappend ret $r
        }
    }
    if {$child eq $id} {
        lappend ret $row
    }
    set prev $child
    set prevrow $row
}
return $ret</pre>

<p>}</p>

<p>proc drawlineseg {id row endrow arrowlow} {</p>

<pre>global rowidlist displayorder iddrawn linesegs
global canv colormap linespc curview maxlinelen parentlist

set cols [list [lsearch -exact [lindex $rowidlist $row] $id]]
set le [expr {$row + 1}]
set arrowhigh 1
while {1} {
    set c [lsearch -exact [lindex $rowidlist $le] $id]
    if {$c &lt; 0} {
        incr le -1
        break
    }
    lappend cols $c
    set x [lindex $displayorder $le]
    if {$x eq $id} {
        set arrowhigh 0
        break
    }
    if {[info exists iddrawn($x)] || $le == $endrow} {
        set c [lsearch -exact [lindex $rowidlist [expr {$le+1}]] $id]
        if {$c &gt;= 0} {
            lappend cols $c
            set arrowhigh 0
        }
        break
    }
    incr le
}
if {$le &lt;= $row} {
    return $row
}

set lines {}
set i 0
set joinhigh 0
if {[info exists linesegs($id)]} {
    set lines $linesegs($id)
    foreach li $lines {
        set r0 [lindex $li 0]
        if {$r0 &gt; $row} {
            if {$r0 == $le &amp;&amp; [lindex $li 1] - $row &lt;= $maxlinelen} {
                set joinhigh 1
            }
            break
        }
        incr i
    }
}
set joinlow 0
if {$i &gt; 0} {
    set li [lindex $lines [expr {$i-1}]]
    set r1 [lindex $li 1]
    if {$r1 == $row &amp;&amp; $le - [lindex $li 0] &lt;= $maxlinelen} {
        set joinlow 1
    }
}

set x [lindex $cols [expr {$le - $row}]]
set xp [lindex $cols [expr {$le - 1 - $row}]]
set dir [expr {$xp - $x}]
if {$joinhigh} {
    set ith [lindex $lines $i 2]
    set coords [$canv coords $ith]
    set ah [$canv itemcget $ith -arrow]
    set arrowhigh [expr {$ah eq &quot;first&quot; || $ah eq &quot;both&quot;}]
    set x2 [lindex $cols [expr {$le + 1 - $row}]]
    if {$x2 ne {} &amp;&amp; $x - $x2 == $dir} {
        set coords [lrange $coords 0 end-2]
    }
} else {
    set coords [list [xc $le $x] [yc $le]]
}
if {$joinlow} {
    set itl [lindex $lines [expr {$i-1}] 2]
    set al [$canv itemcget $itl -arrow]
    set arrowlow [expr {$al eq &quot;last&quot; || $al eq &quot;both&quot;}]
} elseif {$arrowlow} {
    if {[lsearch -exact [lindex $rowidlist [expr {$row-1}]] $id] &gt;= 0 ||
        [lsearch -exact [lindex $parentlist [expr {$row-1}]] $id] &gt;= 0} {
        set arrowlow 0
    }
}
set arrow [lindex {none first last both} [expr {$arrowhigh + 2*$arrowlow}]]
for {set y $le} {[incr y -1] &gt; $row} {} {
    set x $xp
    set xp [lindex $cols [expr {$y - 1 - $row}]]
    set ndir [expr {$xp - $x}]
    if {$dir != $ndir || $xp &lt; 0} {
        lappend coords [xc $y $x] [yc $y]
    }
    set dir $ndir
}
if {!$joinlow} {
    if {$xp &lt; 0} {
        # join parent line to first child
        set ch [lindex $displayorder $row]
        set xc [lsearch -exact [lindex $rowidlist $row] $ch]
        if {$xc &lt; 0} {
            puts &quot;oops: drawlineseg: child $ch not on row $row&quot;
        } elseif {$xc != $x} {
            if {($arrowhigh &amp;&amp; $le == $row + 1) || $dir == 0} {
                set d [expr {int(0.5 * $linespc)}]
                set x1 [xc $row $x]
                if {$xc &lt; $x} {
                    set x2 [expr {$x1 - $d}]
                } else {
                    set x2 [expr {$x1 + $d}]
                }
                set y2 [yc $row]
                set y1 [expr {$y2 + $d}]
                lappend coords $x1 $y1 $x2 $y2
            } elseif {$xc &lt; $x - 1} {
                lappend coords [xc $row [expr {$x-1}]] [yc $row]
            } elseif {$xc &gt; $x + 1} {
                lappend coords [xc $row [expr {$x+1}]] [yc $row]
            }
            set x $xc
        }
        lappend coords [xc $row $x] [yc $row]
    } else {
        set xn [xc $row $xp]
        set yn [yc $row]
        lappend coords $xn $yn
    }
    if {!$joinhigh} {
        assigncolor $id
        set t [$canv create line $coords -width [linewidth $id] \
                   -fill $colormap($id) -tags lines.$id -arrow $arrow]
        $canv lower $t
        bindline $t $id
        set lines [linsert $lines $i [list $row $le $t]]
    } else {
        $canv coords $ith $coords
        if {$arrow ne $ah} {
            $canv itemconf $ith -arrow $arrow
        }
        lset lines $i 0 $row
    }
} else {
    set xo [lsearch -exact [lindex $rowidlist [expr {$row - 1}]] $id]
    set ndir [expr {$xo - $xp}]
    set clow [$canv coords $itl]
    if {$dir == $ndir} {
        set clow [lrange $clow 2 end]
    }
    set coords [concat $coords $clow]
    if {!$joinhigh} {
        lset lines [expr {$i-1}] 1 $le
    } else {
        # coalesce two pieces
        $canv delete $ith
        set b [lindex $lines [expr {$i-1}] 0]
        set e [lindex $lines $i 1]
        set lines [lreplace $lines [expr {$i-1}] $i [list $b $e $itl]]
    }
    $canv coords $itl $coords
    if {$arrow ne $al} {
        $canv itemconf $itl -arrow $arrow
    }
}

set linesegs($id) $lines
return $le</pre>

<p>}</p>

<p>proc drawparentlinks {id row} {</p>

<pre>global rowidlist canv colormap curview parentlist
global idpos linespc

set rowids [lindex $rowidlist $row]
set col [lsearch -exact $rowids $id]
if {$col &lt; 0} return
set olds [lindex $parentlist $row]
set row2 [expr {$row + 1}]
set x [xc $row $col]
set y [yc $row]
set y2 [yc $row2]
set d [expr {int(0.5 * $linespc)}]
set ymid [expr {$y + $d}]
set ids [lindex $rowidlist $row2]
# rmx = right-most X coord used
set rmx 0
foreach p $olds {
    set i [lsearch -exact $ids $p]
    if {$i &lt; 0} {
        puts &quot;oops, parent $p of $id not in list&quot;
        continue
    }
    set x2 [xc $row2 $i]
    if {$x2 &gt; $rmx} {
        set rmx $x2
    }
    set j [lsearch -exact $rowids $p]
    if {$j &lt; 0} {
        # drawlineseg will do this one for us
        continue
    }
    assigncolor $p
    # should handle duplicated parents here...
    set coords [list $x $y]
    if {$i != $col} {
        # if attaching to a vertical segment, draw a smaller
        # slant for visual distinctness
        if {$i == $j} {
            if {$i &lt; $col} {
                lappend coords [expr {$x2 + $d}] $y $x2 $ymid
            } else {
                lappend coords [expr {$x2 - $d}] $y $x2 $ymid
            }
        } elseif {$i &lt; $col &amp;&amp; $i &lt; $j} {
            # segment slants towards us already
            lappend coords [xc $row $j] $y
        } else {
            if {$i &lt; $col - 1} {
                lappend coords [expr {$x2 + $linespc}] $y
            } elseif {$i &gt; $col + 1} {
                lappend coords [expr {$x2 - $linespc}] $y
            }
            lappend coords $x2 $y2
        }
    } else {
        lappend coords $x2 $y2
    }
    set t [$canv create line $coords -width [linewidth $p] \
               -fill $colormap($p) -tags lines.$p]
    $canv lower $t
    bindline $t $p
}
if {$rmx &gt; [lindex $idpos($id) 1]} {
    lset idpos($id) 1 $rmx
    redrawtags $id
}</pre>

<p>}</p>

<p>proc drawlines {id} {</p>

<pre>global canv

$canv itemconf lines.$id -width [linewidth $id]</pre>

<p>}</p>

<p>proc drawcmittext {id row col} {</p>

<pre>global linespc canv canv2 canv3 fgcolor curview
global cmitlisted commitinfo rowidlist parentlist
global rowtextx idpos idtags idheads idotherrefs
global linehtag linentag linedtag selectedline
global canvxmax boldids boldnameids fgcolor markedid
global mainheadid nullid nullid2 circleitem circlecolors ctxbut
global mainheadcirclecolor workingfilescirclecolor indexcirclecolor
global circleoutlinecolor

# listed is 0 for boundary, 1 for normal, 2 for negative, 3 for left, 4 for right
set listed $cmitlisted($curview,$id)
if {$id eq $nullid} {
    set ofill $workingfilescirclecolor
} elseif {$id eq $nullid2} {
    set ofill $indexcirclecolor
} elseif {$id eq $mainheadid} {
    set ofill $mainheadcirclecolor
} else {
    set ofill [lindex $circlecolors $listed]
}
set x [xc $row $col]
set y [yc $row]
set orad [expr {$linespc / 3}]
if {$listed &lt;= 2} {
    set t [$canv create oval [expr {$x - $orad}] [expr {$y - $orad}] \
               [expr {$x + $orad - 1}] [expr {$y + $orad - 1}] \
               -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]
} elseif {$listed == 3} {
    # triangle pointing left for left-side commits
    set t [$canv create polygon \
               [expr {$x - $orad}] $y \
               [expr {$x + $orad - 1}] [expr {$y - $orad}] \
               [expr {$x + $orad - 1}] [expr {$y + $orad - 1}] \
               -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]
} else {
    # triangle pointing right for right-side commits
    set t [$canv create polygon \
               [expr {$x + $orad - 1}] $y \
               [expr {$x - $orad}] [expr {$y - $orad}] \
               [expr {$x - $orad}] [expr {$y + $orad - 1}] \
               -fill $ofill -outline $circleoutlinecolor -width 1 -tags circle]
}
set circleitem($row) $t
$canv raise $t
$canv bind $t &lt;1&gt; {selcanvline {} %x %y}
set rmx [llength [lindex $rowidlist $row]]
set olds [lindex $parentlist $row]
if {$olds ne {}} {
    set nextids [lindex $rowidlist [expr {$row + 1}]]
    foreach p $olds {
        set i [lsearch -exact $nextids $p]
        if {$i &gt; $rmx} {
            set rmx $i
        }
    }
}
set xt [xc $row $rmx]
set rowtextx($row) $xt
set idpos($id) [list $x $xt $y]
if {[info exists idtags($id)] || [info exists idheads($id)]
    || [info exists idotherrefs($id)]} {
    set xt [drawtags $id $x $xt $y]
}
if {[lindex $commitinfo($id) 6] &gt; 0} {
    set xt [drawnotesign $xt $y]
}
set headline [lindex $commitinfo($id) 0]
set name [lindex $commitinfo($id) 1]
set date [lindex $commitinfo($id) 2]
set date [formatdate $date]
set font mainfont
set nfont mainfont
set isbold [ishighlighted $id]
if {$isbold &gt; 0} {
    lappend boldids $id
    set font mainfontbold
    if {$isbold &gt; 1} {
        lappend boldnameids $id
        set nfont mainfontbold
    }
}
set linehtag($id) [$canv create text $xt $y -anchor w -fill $fgcolor \
                       -text $headline -font $font -tags text]
$canv bind $linehtag($id) $ctxbut &quot;rowmenu %X %Y $id&quot;
set linentag($id) [$canv2 create text 3 $y -anchor w -fill $fgcolor \
                       -text $name -font $nfont -tags text]
set linedtag($id) [$canv3 create text 3 $y -anchor w -fill $fgcolor \
                       -text $date -font mainfont -tags text]
if {$selectedline == $row} {
    make_secsel $id
}
if {[info exists markedid] &amp;&amp; $markedid eq $id} {
    make_idmark $id
}
set xr [expr {$xt + [font measure $font $headline]}]
if {$xr &gt; $canvxmax} {
    set canvxmax $xr
    setcanvscroll
}</pre>

<p>}</p>

<p>proc drawcmitrow {row} {</p>

<pre>global displayorder rowidlist nrows_drawn
global iddrawn markingmatches
global commitinfo numcommits
global filehighlight fhighlights findpattern nhighlights
global hlview vhighlights
global highlight_related rhighlights

if {$row &gt;= $numcommits} return

set id [lindex $displayorder $row]
if {[info exists hlview] &amp;&amp; ![info exists vhighlights($id)]} {
    askvhighlight $row $id
}
if {[info exists filehighlight] &amp;&amp; ![info exists fhighlights($id)]} {
    askfilehighlight $row $id
}
if {$findpattern ne {} &amp;&amp; ![info exists nhighlights($id)]} {
    askfindhighlight $row $id
}
if {$highlight_related ne [mc &quot;None&quot;] &amp;&amp; ![info exists rhighlights($id)]} {
    askrelhighlight $row $id
}
if {![info exists iddrawn($id)]} {
    set col [lsearch -exact [lindex $rowidlist $row] $id]
    if {$col &lt; 0} {
        puts &quot;oops, row $row id $id not in list&quot;
        return
    }
    if {![info exists commitinfo($id)]} {
        getcommit $id
    }
    assigncolor $id
    drawcmittext $id $row $col
    set iddrawn($id) 1
    incr nrows_drawn
}
if {$markingmatches} {
    markrowmatches $row $id
}</pre>

<p>}</p>

<p>proc drawcommits {row {endrow {}}} {</p>

<pre>global numcommits iddrawn displayorder curview need_redisplay
global parentlist rowidlist rowfinal uparrowlen downarrowlen nrows_drawn

if {$row &lt; 0} {
    set row 0
}
if {$endrow eq {}} {
    set endrow $row
}
if {$endrow &gt;= $numcommits} {
    set endrow [expr {$numcommits - 1}]
}

set rl1 [expr {$row - $downarrowlen - 3}]
if {$rl1 &lt; 0} {
    set rl1 0
}
set ro1 [expr {$row - 3}]
if {$ro1 &lt; 0} {
    set ro1 0
}
set r2 [expr {$endrow + $uparrowlen + 3}]
if {$r2 &gt; $numcommits} {
    set r2 $numcommits
}
for {set r $rl1} {$r &lt; $r2} {incr r} {
    if {[lindex $rowidlist $r] ne {} &amp;&amp; [lindex $rowfinal $r]} {
        if {$rl1 &lt; $r} {
            layoutrows $rl1 $r
        }
        set rl1 [expr {$r + 1}]
    }
}
if {$rl1 &lt; $r} {
    layoutrows $rl1 $r
}
optimize_rows $ro1 0 $r2
if {$need_redisplay || $nrows_drawn &gt; 2000} {
    clear_display
}

# make the lines join to already-drawn rows either side
set r [expr {$row - 1}]
if {$r &lt; 0 || ![info exists iddrawn([lindex $displayorder $r])]} {
    set r $row
}
set er [expr {$endrow + 1}]
if {$er &gt;= $numcommits ||
    ![info exists iddrawn([lindex $displayorder $er])]} {
    set er $endrow
}
for {} {$r &lt;= $er} {incr r} {
    set id [lindex $displayorder $r]
    set wasdrawn [info exists iddrawn($id)]
    drawcmitrow $r
    if {$r == $er} break
    set nextid [lindex $displayorder [expr {$r + 1}]]
    if {$wasdrawn &amp;&amp; [info exists iddrawn($nextid)]} continue
    drawparentlinks $id $r

    set rowids [lindex $rowidlist $r]
    foreach lid $rowids {
        if {$lid eq {}} continue
        if {[info exists lineend($lid)] &amp;&amp; $lineend($lid) &gt; $r} continue
        if {$lid eq $id} {
            # see if this is the first child of any of its parents
            foreach p [lindex $parentlist $r] {
                if {[lsearch -exact $rowids $p] &lt; 0} {
                    # make this line extend up to the child
                    set lineend($p) [drawlineseg $p $r $er 0]
                }
            }
        } else {
            set lineend($lid) [drawlineseg $lid $r $er 1]
        }
    }
}</pre>

<p>}</p>

<p>proc undolayout {row} {</p>

<pre>global uparrowlen mingaplen downarrowlen
global rowidlist rowisopt rowfinal need_redisplay

set r [expr {$row - ($uparrowlen + $mingaplen + $downarrowlen)}]
if {$r &lt; 0} {
    set r 0
}
if {[llength $rowidlist] &gt; $r} {
    incr r -1
    set rowidlist [lrange $rowidlist 0 $r]
    set rowfinal [lrange $rowfinal 0 $r]
    set rowisopt [lrange $rowisopt 0 $r]
    set need_redisplay 1
    run drawvisible
}</pre>

<p>}</p>

<p>proc drawvisible {} {</p>

<pre>global canv linespc curview vrowmod selectedline targetrow targetid
global need_redisplay cscroll numcommits

set fs [$canv yview]
set ymax [lindex [$canv cget -scrollregion] 3]
if {$ymax eq {} || $ymax == 0 || $numcommits == 0} return
set f0 [lindex $fs 0]
set f1 [lindex $fs 1]
set y0 [expr {int($f0 * $ymax)}]
set y1 [expr {int($f1 * $ymax)}]

if {[info exists targetid]} {
    if {[commitinview $targetid $curview]} {
        set r [rowofcommit $targetid]
        if {$r != $targetrow} {
            # Fix up the scrollregion and change the scrolling position
            # now that our target row has moved.
            set diff [expr {($r - $targetrow) * $linespc}]
            set targetrow $r
            setcanvscroll
            set ymax [lindex [$canv cget -scrollregion] 3]
            incr y0 $diff
            incr y1 $diff
            set f0 [expr {$y0 / $ymax}]
            set f1 [expr {$y1 / $ymax}]
            allcanvs yview moveto $f0
            $cscroll set $f0 $f1
            set need_redisplay 1
        }
    } else {
        unset targetid
    }
}

set row [expr {int(($y0 - 3) / $linespc) - 1}]
set endrow [expr {int(($y1 - 3) / $linespc) + 1}]
if {$endrow &gt;= $vrowmod($curview)} {
    update_arcrows $curview
}
if {$selectedline ne {} &amp;&amp;
    $row &lt;= $selectedline &amp;&amp; $selectedline &lt;= $endrow} {
    set targetrow $selectedline
} elseif {[info exists targetid]} {
    set targetrow [expr {int(($row + $endrow) / 2)}]
}
if {[info exists targetrow]} {
    if {$targetrow &gt;= $numcommits} {
        set targetrow [expr {$numcommits - 1}]
    }
    set targetid [commitonrow $targetrow]
}
drawcommits $row $endrow</pre>

<p>}</p>

<p>proc clear_display {} {</p>

<pre>global iddrawn linesegs need_redisplay nrows_drawn
global vhighlights fhighlights nhighlights rhighlights
global linehtag linentag linedtag boldids boldnameids

allcanvs delete all
catch {unset iddrawn}
catch {unset linesegs}
catch {unset linehtag}
catch {unset linentag}
catch {unset linedtag}
set boldids {}
set boldnameids {}
catch {unset vhighlights}
catch {unset fhighlights}
catch {unset nhighlights}
catch {unset rhighlights}
set need_redisplay 0
set nrows_drawn 0</pre>

<p>}</p>

<p>proc findcrossings {id} {</p>

<pre>global rowidlist parentlist numcommits displayorder

set cross {}
set ccross {}
foreach {s e} [rowranges $id] {
    if {$e &gt;= $numcommits} {
        set e [expr {$numcommits - 1}]
    }
    if {$e &lt;= $s} continue
    for {set row $e} {[incr row -1] &gt;= $s} {} {
        set x [lsearch -exact [lindex $rowidlist $row] $id]
        if {$x &lt; 0} break
        set olds [lindex $parentlist $row]
        set kid [lindex $displayorder $row]
        set kidx [lsearch -exact [lindex $rowidlist $row] $kid]
        if {$kidx &lt; 0} continue
        set nextrow [lindex $rowidlist [expr {$row + 1}]]
        foreach p $olds {
            set px [lsearch -exact $nextrow $p]
            if {$px &lt; 0} continue
            if {($kidx &lt; $x &amp;&amp; $x &lt; $px) || ($px &lt; $x &amp;&amp; $x &lt; $kidx)} {
                if {[lsearch -exact $ccross $p] &gt;= 0} continue
                if {$x == $px + ($kidx &lt; $px? -1: 1)} {
                    lappend ccross $p
                } elseif {[lsearch -exact $cross $p] &lt; 0} {
                    lappend cross $p
                }
            }
        }
    }
}
return [concat $ccross {{}} $cross]</pre>

<p>}</p>

<p>proc assigncolor {id} {</p>

<pre>global colormap colors nextcolor
global parents children children curview

if {[info exists colormap($id)]} return
set ncolors [llength $colors]
if {[info exists children($curview,$id)]} {
    set kids $children($curview,$id)
} else {
    set kids {}
}
if {[llength $kids] == 1} {
    set child [lindex $kids 0]
    if {[info exists colormap($child)]
        &amp;&amp; [llength $parents($curview,$child)] == 1} {
        set colormap($id) $colormap($child)
        return
    }
}
set badcolors {}
set origbad {}
foreach x [findcrossings $id] {
    if {$x eq {}} {
        # delimiter between corner crossings and other crossings
        if {[llength $badcolors] &gt;= $ncolors - 1} break
        set origbad $badcolors
    }
    if {[info exists colormap($x)]
        &amp;&amp; [lsearch -exact $badcolors $colormap($x)] &lt; 0} {
        lappend badcolors $colormap($x)
    }
}
if {[llength $badcolors] &gt;= $ncolors} {
    set badcolors $origbad
}
set origbad $badcolors
if {[llength $badcolors] &lt; $ncolors - 1} {
    foreach child $kids {
        if {[info exists colormap($child)]
            &amp;&amp; [lsearch -exact $badcolors $colormap($child)] &lt; 0} {
            lappend badcolors $colormap($child)
        }
        foreach p $parents($curview,$child) {
            if {[info exists colormap($p)]
                &amp;&amp; [lsearch -exact $badcolors $colormap($p)] &lt; 0} {
                lappend badcolors $colormap($p)
            }
        }
    }
    if {[llength $badcolors] &gt;= $ncolors} {
        set badcolors $origbad
    }
}
for {set i 0} {$i &lt;= $ncolors} {incr i} {
    set c [lindex $colors $nextcolor]
    if {[incr nextcolor] &gt;= $ncolors} {
        set nextcolor 0
    }
    if {[lsearch -exact $badcolors $c]} break
}
set colormap($id) $c</pre>

<p>}</p>

<p>proc bindline {t id} {</p>

<pre>global canv

$canv bind $t &lt;Enter&gt; &quot;lineenter %x %y $id&quot;
$canv bind $t &lt;Motion&gt; &quot;linemotion %x %y $id&quot;
$canv bind $t &lt;Leave&gt; &quot;lineleave $id&quot;
$canv bind $t &lt;Button-1&gt; &quot;lineclick %x %y $id 1&quot;</pre>

<p>}</p>

<p>proc drawtags {id x xt y1} {</p>

<pre>global idtags idheads idotherrefs mainhead
global linespc lthickness
global canv rowtextx curview fgcolor bgcolor ctxbut
global headbgcolor headfgcolor headoutlinecolor remotebgcolor
global tagbgcolor tagfgcolor tagoutlinecolor
global reflinecolor

set marks {}
set ntags 0
set nheads 0
if {[info exists idtags($id)]} {
    set marks $idtags($id)
    set ntags [llength $marks]
}
if {[info exists idheads($id)]} {
    set marks [concat $marks $idheads($id)]
    set nheads [llength $idheads($id)]
}
if {[info exists idotherrefs($id)]} {
    set marks [concat $marks $idotherrefs($id)]
}
if {$marks eq {}} {
    return $xt
}

set delta [expr {int(0.5 * ($linespc - $lthickness))}]
set yt [expr {$y1 - 0.5 * $linespc}]
set yb [expr {$yt + $linespc - 1}]
set xvals {}
set wvals {}
set i -1
foreach tag $marks {
    incr i
    if {$i &gt;= $ntags &amp;&amp; $i &lt; $ntags + $nheads &amp;&amp; $tag eq $mainhead} {
        set wid [font measure mainfontbold $tag]
    } else {
        set wid [font measure mainfont $tag]
    }
    lappend xvals $xt
    lappend wvals $wid
    set xt [expr {$xt + $delta + $wid + $lthickness + $linespc}]
}
set t [$canv create line $x $y1 [lindex $xvals end] $y1 \
           -width $lthickness -fill $reflinecolor -tags tag.$id]
$canv lower $t
foreach tag $marks x $xvals wid $wvals {
    set tag_quoted [string map {% %%} $tag]
    set xl [expr {$x + $delta}]
    set xr [expr {$x + $delta + $wid + $lthickness}]
    set font mainfont
    if {[incr ntags -1] &gt;= 0} {
        # draw a tag
        set t [$canv create polygon $x [expr {$yt + $delta}] $xl $yt \
                   $xr $yt $xr $yb $xl $yb $x [expr {$yb - $delta}] \
                   -width 1 -outline $tagoutlinecolor -fill $tagbgcolor \
                   -tags tag.$id]
        $canv bind $t &lt;1&gt; [list showtag $tag_quoted 1]
        set rowtextx([rowofcommit $id]) [expr {$xr + $linespc}]
    } else {
        # draw a head or other ref
        if {[incr nheads -1] &gt;= 0} {
            set col $headbgcolor
            if {$tag eq $mainhead} {
                set font mainfontbold
            }
        } else {
            set col &quot;#ddddff&quot;
        }
        set xl [expr {$xl - $delta/2}]
        $canv create polygon $x $yt $xr $yt $xr $yb $x $yb \
            -width 1 -outline black -fill $col -tags tag.$id
        if {[regexp {^(remotes/.*/|remotes/)} $tag match remoteprefix]} {
            set rwid [font measure mainfont $remoteprefix]
            set xi [expr {$x + 1}]
            set yti [expr {$yt + 1}]
            set xri [expr {$x + $rwid}]
            $canv create polygon $xi $yti $xri $yti $xri $yb $xi $yb \
                    -width 0 -fill $remotebgcolor -tags tag.$id
        }
    }
    set t [$canv create text $xl $y1 -anchor w -text $tag -fill $headfgcolor \
               -font $font -tags [list tag.$id text]]
    if {$ntags &gt;= 0} {
        $canv bind $t &lt;1&gt; [list showtag $tag_quoted 1]
    } elseif {$nheads &gt;= 0} {
        $canv bind $t $ctxbut [list headmenu %X %Y $id $tag_quoted]
    }
}
return $xt</pre>

<p>}</p>

<p>proc drawnotesign {xt y} {</p>

<pre>global linespc canv fgcolor

set orad [expr {$linespc / 3}]
set t [$canv create rectangle [expr {$xt - $orad}] [expr {$y - $orad}] \
           [expr {$xt + $orad - 1}] [expr {$y + $orad - 1}] \
           -fill yellow -outline $fgcolor -width 1 -tags circle]
set xt [expr {$xt + $orad * 3}]
return $xt</pre>

<p>}</p>

<p>proc xcoord {i level ln} {</p>

<pre>global canvx0 xspc1 xspc2

set x [expr {$canvx0 + $i * $xspc1($ln)}]
if {$i &gt; 0 &amp;&amp; $i == $level} {
    set x [expr {$x + 0.5 * ($xspc2 - $xspc1($ln))}]
} elseif {$i &gt; $level} {
    set x [expr {$x + $xspc2 - $xspc1($ln)}]
}
return $x</pre>

<p>}</p>

<p>proc show_status {msg} {</p>

<pre>global canv fgcolor

clear_display
$canv create text 3 3 -anchor nw -text $msg -font mainfont \
    -tags text -fill $fgcolor</pre>

<p>}</p>

<p># Don&#39;t change the text pane cursor if it is currently the hand cursor,
# showing that we are over a sha1 ID link. proc settextcursor {c} {</p>

<pre>global ctext curtextcursor

if {[$ctext cget -cursor] == $curtextcursor} {
    $ctext config -cursor $c
}
set curtextcursor $c</pre>

<p>}</p>

<p>proc nowbusy {what {name {}}} {</p>

<pre>global isbusy busyname statusw

if {[array names isbusy] eq {}} {
    . config -cursor watch
    settextcursor watch
}
set isbusy($what) 1
set busyname($what) $name
if {$name ne {}} {
    $statusw conf -text $name
}</pre>

<p>}</p>

<p>proc notbusy {what} {</p>

<pre>global isbusy maincursor textcursor busyname statusw

catch {
    unset isbusy($what)
    if {$busyname($what) ne {} &amp;&amp;
        [$statusw cget -text] eq $busyname($what)} {
        $statusw conf -text {}
    }
}
if {[array names isbusy] eq {}} {
    . config -cursor $maincursor
    settextcursor $textcursor
}</pre>

<p>}</p>

<p>proc findmatches {f} {</p>

<pre>global findtype findstring
if {$findtype == [mc &quot;Regexp&quot;]} {
    set matches [regexp -indices -all -inline $findstring $f]
} else {
    set fs $findstring
    if {$findtype == [mc &quot;IgnCase&quot;]} {
        set f [string tolower $f]
        set fs [string tolower $fs]
    }
    set matches {}
    set i 0
    set l [string length $fs]
    while {[set j [string first $fs $f $i]] &gt;= 0} {
        lappend matches [list $j [expr {$j+$l-1}]]
        set i [expr {$j + $l}]
    }
}
return $matches</pre>

<p>}</p>

<p>proc dofind {{dirn 1} {wrap 1}} {</p>

<pre>global findstring findstartline findcurline selectedline numcommits
global gdttype filehighlight fh_serial find_dirn findallowwrap

if {[info exists find_dirn]} {
    if {$find_dirn == $dirn} return
    stopfinding
}
focus .
if {$findstring eq {} || $numcommits == 0} return
if {$selectedline eq {}} {
    set findstartline [lindex [visiblerows] [expr {$dirn &lt; 0}]]
} else {
    set findstartline $selectedline
}
set findcurline $findstartline
nowbusy finding [mc &quot;Searching&quot;]
if {$gdttype ne [mc &quot;containing:&quot;] &amp;&amp; ![info exists filehighlight]} {
    after cancel do_file_hl $fh_serial
    do_file_hl $fh_serial
}
set find_dirn $dirn
set findallowwrap $wrap
run findmore</pre>

<p>}</p>

<p>proc stopfinding {} {</p>

<pre>global find_dirn findcurline fprogcoord

if {[info exists find_dirn]} {
    unset find_dirn
    unset findcurline
    notbusy finding
    set fprogcoord 0
    adjustprogress
}
stopblaming</pre>

<p>}</p>

<p>proc findmore {} {</p>

<pre>global commitdata commitinfo numcommits findpattern findloc
global findstartline findcurline findallowwrap
global find_dirn gdttype fhighlights fprogcoord
global curview varcorder vrownum varccommits vrowmod

if {![info exists find_dirn]} {
    return 0
}
set fldtypes [list [mc &quot;Headline&quot;] [mc &quot;Author&quot;] &quot;&quot; [mc &quot;Committer&quot;] &quot;&quot; [mc &quot;Comments&quot;]]
set l $findcurline
set moretodo 0
if {$find_dirn &gt; 0} {
    incr l
    if {$l &gt;= $numcommits} {
        set l 0
    }
    if {$l &lt;= $findstartline} {
        set lim [expr {$findstartline + 1}]
    } else {
        set lim $numcommits
        set moretodo $findallowwrap
    }
} else {
    if {$l == 0} {
        set l $numcommits
    }
    incr l -1
    if {$l &gt;= $findstartline} {
        set lim [expr {$findstartline - 1}]
    } else {
        set lim -1
        set moretodo $findallowwrap
    }
}
set n [expr {($lim - $l) * $find_dirn}]
if {$n &gt; 500} {
    set n 500
    set moretodo 1
}
if {$l + ($find_dirn &gt; 0? $n: 1) &gt; $vrowmod($curview)} {
    update_arcrows $curview
}
set found 0
set domore 1
set ai [bsearch $vrownum($curview) $l]
set a [lindex $varcorder($curview) $ai]
set arow [lindex $vrownum($curview) $ai]
set ids [lindex $varccommits($curview,$a)]
set arowend [expr {$arow + [llength $ids]}]
if {$gdttype eq [mc &quot;containing:&quot;]} {
    for {} {$n &gt; 0} {incr n -1; incr l $find_dirn} {
        if {$l &lt; $arow || $l &gt;= $arowend} {
            incr ai $find_dirn
            set a [lindex $varcorder($curview) $ai]
            set arow [lindex $vrownum($curview) $ai]
            set ids [lindex $varccommits($curview,$a)]
            set arowend [expr {$arow + [llength $ids]}]
        }
        set id [lindex $ids [expr {$l - $arow}]]
        # shouldn&#39;t happen unless git log doesn&#39;t give all the commits...
        if {![info exists commitdata($id)] ||
            ![doesmatch $commitdata($id)]} {
            continue
        }
        if {![info exists commitinfo($id)]} {
            getcommit $id
        }
        set info $commitinfo($id)
        foreach f $info ty $fldtypes {
            if {$ty eq &quot;&quot;} continue
            if {($findloc eq [mc &quot;All fields&quot;] || $findloc eq $ty) &amp;&amp;
                [doesmatch $f]} {
                set found 1
                break
            }
        }
        if {$found} break
    }
} else {
    for {} {$n &gt; 0} {incr n -1; incr l $find_dirn} {
        if {$l &lt; $arow || $l &gt;= $arowend} {
            incr ai $find_dirn
            set a [lindex $varcorder($curview) $ai]
            set arow [lindex $vrownum($curview) $ai]
            set ids [lindex $varccommits($curview,$a)]
            set arowend [expr {$arow + [llength $ids]}]
        }
        set id [lindex $ids [expr {$l - $arow}]]
        if {![info exists fhighlights($id)]} {
            # this sets fhighlights($id) to -1
            askfilehighlight $l $id
        }
        if {$fhighlights($id) &gt; 0} {
            set found $domore
            break
        }
        if {$fhighlights($id) &lt; 0} {
            if {$domore} {
                set domore 0
                set findcurline [expr {$l - $find_dirn}]
            }
        }
    }
}
if {$found || ($domore &amp;&amp; !$moretodo)} {
    unset findcurline
    unset find_dirn
    notbusy finding
    set fprogcoord 0
    adjustprogress
    if {$found} {
        findselectline $l
    } else {
        bell
    }
    return 0
}
if {!$domore} {
    flushhighlights
} else {
    set findcurline [expr {$l - $find_dirn}]
}
set n [expr {($findcurline - $findstartline) * $find_dirn - 1}]
if {$n &lt; 0} {
    incr n $numcommits
}
set fprogcoord [expr {$n * 1.0 / $numcommits}]
adjustprogress
return $domore</pre>

<p>}</p>

<p>proc findselectline {l} {</p>

<pre>global findloc commentend ctext findcurline markingmatches gdttype

set markingmatches [expr {$gdttype eq [mc &quot;containing:&quot;]}]
set findcurline $l
selectline $l 1
if {$markingmatches &amp;&amp;
    ($findloc eq [mc &quot;All fields&quot;] || $findloc eq [mc &quot;Comments&quot;])} {
    # highlight the matches in the comments
    set f [$ctext get 1.0 $commentend]
    set matches [findmatches $f]
    foreach match $matches {
        set start [lindex $match 0]
        set end [expr {[lindex $match 1] + 1}]
        $ctext tag add found &quot;1.0 + $start c&quot; &quot;1.0 + $end c&quot;
    }
}
drawvisible</pre>

<p>}</p>

<p># mark the bits of a headline or author that match a find string proc
markmatches {canv l str tag matches font row} {</p>

<pre>global selectedline

set bbox [$canv bbox $tag]
set x0 [lindex $bbox 0]
set y0 [lindex $bbox 1]
set y1 [lindex $bbox 3]
foreach match $matches {
    set start [lindex $match 0]
    set end [lindex $match 1]
    if {$start &gt; $end} continue
    set xoff [font measure $font [string range $str 0 [expr {$start-1}]]]
    set xlen [font measure $font [string range $str 0 [expr {$end}]]]
    set t [$canv create rect [expr {$x0+$xoff}] $y0 \
               [expr {$x0+$xlen+2}] $y1 \
               -outline {} -tags [list match$l matches] -fill yellow]
    $canv lower $t
    if {$row == $selectedline} {
        $canv raise $t secsel
    }
}</pre>

<p>}</p>

<p>proc unmarkmatches {} {</p>

<pre>global markingmatches

allcanvs delete matches
set markingmatches 0
stopfinding</pre>

<p>}</p>

<p>proc selcanvline {w x y} {</p>

<pre>global canv canvy0 ctext linespc
global rowtextx
set ymax [lindex [$canv cget -scrollregion] 3]
if {$ymax == {}} return
set yfrac [lindex [$canv yview] 0]
set y [expr {$y + $yfrac * $ymax}]
set l [expr {int(($y - $canvy0) / $linespc + 0.5)}]
if {$l &lt; 0} {
    set l 0
}
if {$w eq $canv} {
    set xmax [lindex [$canv cget -scrollregion] 2]
    set xleft [expr {[lindex [$canv xview] 0] * $xmax}]
    if {![info exists rowtextx($l)] || $xleft + $x &lt; $rowtextx($l)} return
}
unmarkmatches
selectline $l 1</pre>

<p>}</p>

<p>proc commit_descriptor {p} {</p>

<pre>global commitinfo
if {![info exists commitinfo($p)]} {
    getcommit $p
}
set l &quot;...&quot;
if {[llength $commitinfo($p)] &gt; 1} {
    set l [lindex $commitinfo($p) 0]
}
return &quot;$p ($l)\n&quot;</pre>

<p>}</p>

<p># append some text to the ctext widget, and make any SHA1 ID # that we know
about be a clickable link. proc appendwithlinks {text tags} {</p>

<pre>global ctext linknum curview

set start [$ctext index &quot;end - 1c&quot;]
$ctext insert end $text $tags
set links [regexp -indices -all -inline {(?:\m|-g)[0-9a-f]{6,40}\M} $text]
foreach l $links {
    set s [lindex $l 0]
    set e [lindex $l 1]
    set linkid [string range $text $s $e]
    incr e
    $ctext tag delete link$linknum
    $ctext tag add link$linknum &quot;$start + $s c&quot; &quot;$start + $e c&quot;
    setlink $linkid link$linknum
    incr linknum
}</pre>

<p>}</p>

<p>proc setlink {id lk} {</p>

<pre>global curview ctext pendinglinks
global linkfgcolor

if {[string range $id 0 1] eq &quot;-g&quot;} {
  set id [string range $id 2 end]
}

set known 0
if {[string length $id] &lt; 40} {
    set matches [longid $id]
    if {[llength $matches] &gt; 0} {
        if {[llength $matches] &gt; 1} return
        set known 1
        set id [lindex $matches 0]
    }
} else {
    set known [commitinview $id $curview]
}
if {$known} {
    $ctext tag conf $lk -foreground $linkfgcolor -underline 1
    $ctext tag bind $lk &lt;1&gt; [list selbyid $id]
    $ctext tag bind $lk &lt;Enter&gt; {linkcursor %W 1}
    $ctext tag bind $lk &lt;Leave&gt; {linkcursor %W -1}
} else {
    lappend pendinglinks($id) $lk
    interestedin $id {makelink %P}
}</pre>

<p>}</p>

<p>proc appendshortlink {id {pre {}} {post {}}} {</p>

<pre>global ctext linknum

$ctext insert end $pre
$ctext tag delete link$linknum
$ctext insert end [string range $id 0 7] link$linknum
$ctext insert end $post
setlink $id link$linknum
incr linknum</pre>

<p>}</p>

<p>proc makelink {id} {</p>

<pre>global pendinglinks

if {![info exists pendinglinks($id)]} return
foreach lk $pendinglinks($id) {
    setlink $id $lk
}
unset pendinglinks($id)</pre>

<p>}</p>

<p>proc linkcursor {w inc} {</p>

<pre>global linkentercount curtextcursor

if {[incr linkentercount $inc] &gt; 0} {
    $w configure -cursor hand2
} else {
    $w configure -cursor $curtextcursor
    if {$linkentercount &lt; 0} {
        set linkentercount 0
    }
}</pre>

<p>}</p>

<p>proc viewnextline {dir} {</p>

<pre>global canv linespc

$canv delete hover
set ymax [lindex [$canv cget -scrollregion] 3]
set wnow [$canv yview]
set wtop [expr {[lindex $wnow 0] * $ymax}]
set newtop [expr {$wtop + $dir * $linespc}]
if {$newtop &lt; 0} {
    set newtop 0
} elseif {$newtop &gt; $ymax} {
    set newtop $ymax
}
allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]</pre>

<p>}</p>

<p># add a list of tag or branch names at position pos # returns the number of
names inserted proc appendrefs {pos ids var} {</p>

<pre>global ctext linknum curview $var maxrefs mainheadid

if {[catch {$ctext index $pos}]} {
    return 0
}
$ctext conf -state normal
$ctext delete $pos &quot;$pos lineend&quot;
set tags {}
foreach id $ids {
    foreach tag [set $var\($id\)] {
        lappend tags [list $tag $id]
    }
}

set sep {}
set tags [lsort -index 0 -decreasing $tags]
set nutags 0

if {[llength $tags] &gt; $maxrefs} {
    # If we are displaying heads, and there are too many,
    # see if there are some important heads to display.
    # Currently this means &quot;master&quot; and the current head.
    set itags {}
    if {$var eq &quot;idheads&quot;} {
        set utags {}
        foreach ti $tags {
            set hname [lindex $ti 0]
            set id [lindex $ti 1]
            if {($hname eq &quot;master&quot; || $id eq $mainheadid) &amp;&amp;
                [llength $itags] &lt; $maxrefs} {
                lappend itags $ti
            } else {
                lappend utags $ti
            }
        }
        set tags $utags
    }
    if {$itags ne {}} {
        set str [mc &quot;and many more&quot;]
        set sep &quot; &quot;
    } else {
        set str [mc &quot;many&quot;]
    }
    $ctext insert $pos &quot;$str ([llength $tags])&quot;
    set nutags [llength $tags]
    set tags $itags
}

foreach ti $tags {
    set id [lindex $ti 1]
    set lk link$linknum
    incr linknum
    $ctext tag delete $lk
    $ctext insert $pos $sep
    $ctext insert $pos [lindex $ti 0] $lk
    setlink $id $lk
    set sep &quot;, &quot;
}
$ctext tag add wwrap &quot;$pos linestart&quot; &quot;$pos lineend&quot;
$ctext conf -state disabled
return [expr {[llength $tags] + $nutags}]</pre>

<p>}</p>

<p># called when we have finished computing the nearby tags proc dispneartags
{delay} {</p>

<pre>global selectedline currentid showneartags tagphase

if {$selectedline eq {} || !$showneartags} return
after cancel dispnexttag
if {$delay} {
    after 200 dispnexttag
    set tagphase -1
} else {
    after idle dispnexttag
    set tagphase 0
}</pre>

<p>}</p>

<p>proc dispnexttag {} {</p>

<pre>global selectedline currentid showneartags tagphase ctext

if {$selectedline eq {} || !$showneartags} return
switch -- $tagphase {
    0 {
        set dtags [desctags $currentid]
        if {$dtags ne {}} {
            appendrefs precedes $dtags idtags
        }
    }
    1 {
        set atags [anctags $currentid]
        if {$atags ne {}} {
            appendrefs follows $atags idtags
        }
    }
    2 {
        set dheads [descheads $currentid]
        if {$dheads ne {}} {
            if {[appendrefs branch $dheads idheads] &gt; 1
                &amp;&amp; [$ctext get &quot;branch -3c&quot;] eq &quot;h&quot;} {
                # turn &quot;Branch&quot; into &quot;Branches&quot;
                $ctext conf -state normal
                $ctext insert &quot;branch -2c&quot; &quot;es&quot;
                $ctext conf -state disabled
            }
        }
    }
}
if {[incr tagphase] &lt;= 2} {
    after idle dispnexttag
}</pre>

<p>}</p>

<p>proc make_secsel {id} {</p>

<pre>global linehtag linentag linedtag canv canv2 canv3

if {![info exists linehtag($id)]} return
$canv delete secsel
set t [eval $canv create rect [$canv bbox $linehtag($id)] -outline {{}} \
           -tags secsel -fill [$canv cget -selectbackground]]
$canv lower $t
$canv2 delete secsel
set t [eval $canv2 create rect [$canv2 bbox $linentag($id)] -outline {{}} \
           -tags secsel -fill [$canv2 cget -selectbackground]]
$canv2 lower $t
$canv3 delete secsel
set t [eval $canv3 create rect [$canv3 bbox $linedtag($id)] -outline {{}} \
           -tags secsel -fill [$canv3 cget -selectbackground]]
$canv3 lower $t</pre>

<p>}</p>

<p>proc make_idmark {id} {</p>

<pre>global linehtag canv fgcolor

if {![info exists linehtag($id)]} return
$canv delete markid
set t [eval $canv create rect [$canv bbox $linehtag($id)] \
           -tags markid -outline $fgcolor]
$canv raise $t</pre>

<p>}</p>

<p>proc selectline {l isnew {desired_loc {}}} {</p>

<pre>global canv ctext commitinfo selectedline
global canvy0 linespc parents children curview
global currentid sha1entry
global commentend idtags linknum
global mergemax numcommits pending_select
global cmitmode showneartags allcommits
global targetrow targetid lastscrollrows
global autoselect autosellen jump_to_here

catch {unset pending_select}
$canv delete hover
normalline
unsel_reflist
stopfinding
if {$l &lt; 0 || $l &gt;= $numcommits} return
set id [commitonrow $l]
set targetid $id
set targetrow $l
set selectedline $l
set currentid $id
if {$lastscrollrows &lt; $numcommits} {
    setcanvscroll
}

set y [expr {$canvy0 + $l * $linespc}]
set ymax [lindex [$canv cget -scrollregion] 3]
set ytop [expr {$y - $linespc - 1}]
set ybot [expr {$y + $linespc + 1}]
set wnow [$canv yview]
set wtop [expr {[lindex $wnow 0] * $ymax}]
set wbot [expr {[lindex $wnow 1] * $ymax}]
set wh [expr {$wbot - $wtop}]
set newtop $wtop
if {$ytop &lt; $wtop} {
    if {$ybot &lt; $wtop} {
        set newtop [expr {$y - $wh / 2.0}]
    } else {
        set newtop $ytop
        if {$newtop &gt; $wtop - $linespc} {
            set newtop [expr {$wtop - $linespc}]
        }
    }
} elseif {$ybot &gt; $wbot} {
    if {$ytop &gt; $wbot} {
        set newtop [expr {$y - $wh / 2.0}]
    } else {
        set newtop [expr {$ybot - $wh}]
        if {$newtop &lt; $wtop + $linespc} {
            set newtop [expr {$wtop + $linespc}]
        }
    }
}
if {$newtop != $wtop} {
    if {$newtop &lt; 0} {
        set newtop 0
    }
    allcanvs yview moveto [expr {$newtop * 1.0 / $ymax}]
    drawvisible
}

make_secsel $id

if {$isnew} {
    addtohistory [list selbyid $id 0] savecmitpos
}

$sha1entry delete 0 end
$sha1entry insert 0 $id
if {$autoselect} {
    $sha1entry selection range 0 $autosellen
}
rhighlight_sel $id

$ctext conf -state normal
clear_ctext
set linknum 0
if {![info exists commitinfo($id)]} {
    getcommit $id
}
set info $commitinfo($id)
set date [formatdate [lindex $info 2]]
$ctext insert end &quot;[mc &quot;Author&quot;]: [lindex $info 1]  $date\n&quot;
set date [formatdate [lindex $info 4]]
$ctext insert end &quot;[mc &quot;Committer&quot;]: [lindex $info 3]  $date\n&quot;
if {[info exists idtags($id)]} {
    $ctext insert end [mc &quot;Tags:&quot;]
    foreach tag $idtags($id) {
        $ctext insert end &quot; $tag&quot;
    }
    $ctext insert end &quot;\n&quot;
}

set headers {}
set olds $parents($curview,$id)
if {[llength $olds] &gt; 1} {
    set np 0
    foreach p $olds {
        if {$np &gt;= $mergemax} {
            set tag mmax
        } else {
            set tag m$np
        }
        $ctext insert end &quot;[mc &quot;Parent&quot;]: &quot; $tag
        appendwithlinks [commit_descriptor $p] {}
        incr np
    }
} else {
    foreach p $olds {
        append headers &quot;[mc &quot;Parent&quot;]: [commit_descriptor $p]&quot;
    }
}

foreach c $children($curview,$id) {
    append headers &quot;[mc &quot;Child&quot;]:  [commit_descriptor $c]&quot;
}

# make anything that looks like a SHA1 ID be a clickable link
appendwithlinks $headers {}
if {$showneartags} {
    if {![info exists allcommits]} {
        getallcommits
    }
    $ctext insert end &quot;[mc &quot;Branch&quot;]: &quot;
    $ctext mark set branch &quot;end -1c&quot;
    $ctext mark gravity branch left
    $ctext insert end &quot;\n[mc &quot;Follows&quot;]: &quot;
    $ctext mark set follows &quot;end -1c&quot;
    $ctext mark gravity follows left
    $ctext insert end &quot;\n[mc &quot;Precedes&quot;]: &quot;
    $ctext mark set precedes &quot;end -1c&quot;
    $ctext mark gravity precedes left
    $ctext insert end &quot;\n&quot;
    dispneartags 1
}
$ctext insert end &quot;\n&quot;
set comment [lindex $info 5]
if {[string first &quot;\r&quot; $comment] &gt;= 0} {
    set comment [string map {&quot;\r&quot; &quot;\n    &quot;} $comment]
}
appendwithlinks $comment {comment}

$ctext tag remove found 1.0 end
$ctext conf -state disabled
set commentend [$ctext index &quot;end - 1c&quot;]

set jump_to_here $desired_loc
init_flist [mc &quot;Comments&quot;]
if {$cmitmode eq &quot;tree&quot;} {
    gettree $id
} elseif {[llength $olds] &lt;= 1} {
    startdiff $id
} else {
    mergediff $id
}</pre>

<p>}</p>

<p>proc selfirstline {} {</p>

<pre>unmarkmatches
selectline 0 1</pre>

<p>}</p>

<p>proc sellastline {} {</p>

<pre>global numcommits
unmarkmatches
set l [expr {$numcommits - 1}]
selectline $l 1</pre>

<p>}</p>

<p>proc selnextline {dir} {</p>

<pre>global selectedline
focus .
if {$selectedline eq {}} return
set l [expr {$selectedline + $dir}]
unmarkmatches
selectline $l 1</pre>

<p>}</p>

<p>proc selnextpage {dir} {</p>

<pre>global canv linespc selectedline numcommits

set lpp [expr {([winfo height $canv] - 2) / $linespc}]
if {$lpp &lt; 1} {
    set lpp 1
}
allcanvs yview scroll [expr {$dir * $lpp}] units
drawvisible
if {$selectedline eq {}} return
set l [expr {$selectedline + $dir * $lpp}]
if {$l &lt; 0} {
    set l 0
} elseif {$l &gt;= $numcommits} {
    set l [expr $numcommits - 1]
}
unmarkmatches
selectline $l 1</pre>

<p>}</p>

<p>proc unselectline {} {</p>

<pre>global selectedline currentid

set selectedline {}
catch {unset currentid}
allcanvs delete secsel
rhighlight_none</pre>

<p>}</p>

<p>proc reselectline {} {</p>

<pre>global selectedline

if {$selectedline ne {}} {
    selectline $selectedline 0
}</pre>

<p>}</p>

<p>proc addtohistory {cmd {saveproc {}}} {</p>

<pre>global history historyindex curview

unset_posvars
save_position
set elt [list $curview $cmd $saveproc {}]
if {$historyindex &gt; 0
    &amp;&amp; [lindex $history [expr {$historyindex - 1}]] == $elt} {
    return
}

if {$historyindex &lt; [llength $history]} {
    set history [lreplace $history $historyindex end $elt]
} else {
    lappend history $elt
}
incr historyindex
if {$historyindex &gt; 1} {
    .tf.bar.leftbut conf -state normal
} else {
    .tf.bar.leftbut conf -state disabled
}
.tf.bar.rightbut conf -state disabled</pre>

<p>}</p>

<p># save the scrolling position of the diff display pane proc save_position
{} {</p>

<pre>global historyindex history

if {$historyindex &lt; 1} return
set hi [expr {$historyindex - 1}]
set fn [lindex $history $hi 2]
if {$fn ne {}} {
    lset history $hi 3 [eval $fn]
}</pre>

<p>}</p>

<p>proc unset_posvars {} {</p>

<pre>global last_posvars

if {[info exists last_posvars]} {
    foreach {var val} $last_posvars {
        global $var
        catch {unset $var}
    }
    unset last_posvars
}</pre>

<p>}</p>

<p>proc godo {elt} {</p>

<pre>global curview last_posvars

set view [lindex $elt 0]
set cmd [lindex $elt 1]
set pv [lindex $elt 3]
if {$curview != $view} {
    showview $view
}
unset_posvars
foreach {var val} $pv {
    global $var
    set $var $val
}
set last_posvars $pv
eval $cmd</pre>

<p>}</p>

<p>proc goback {} {</p>

<pre>global history historyindex
focus .

if {$historyindex &gt; 1} {
    save_position
    incr historyindex -1
    godo [lindex $history [expr {$historyindex - 1}]]
    .tf.bar.rightbut conf -state normal
}
if {$historyindex &lt;= 1} {
    .tf.bar.leftbut conf -state disabled
}</pre>

<p>}</p>

<p>proc goforw {} {</p>

<pre>global history historyindex
focus .

if {$historyindex &lt; [llength $history]} {
    save_position
    set cmd [lindex $history $historyindex]
    incr historyindex
    godo $cmd
    .tf.bar.leftbut conf -state normal
}
if {$historyindex &gt;= [llength $history]} {
    .tf.bar.rightbut conf -state disabled
}</pre>

<p>}</p>

<p>proc gettree {id} {</p>

<pre>global treefilelist treeidlist diffids diffmergeid treepending
global nullid nullid2

set diffids $id
catch {unset diffmergeid}
if {![info exists treefilelist($id)]} {
    if {![info exists treepending]} {
        if {$id eq $nullid} {
            set cmd [list | git ls-files]
        } elseif {$id eq $nullid2} {
            set cmd [list | git ls-files --stage -t]
        } else {
            set cmd [list | git ls-tree -r $id]
        }
        if {[catch {set gtf [open $cmd r]}]} {
            return
        }
        set treepending $id
        set treefilelist($id) {}
        set treeidlist($id) {}
        fconfigure $gtf -blocking 0 -encoding binary
        filerun $gtf [list gettreeline $gtf $id]
    }
} else {
    setfilelist $id
}</pre>

<p>}</p>

<p>proc gettreeline {gtf id} {</p>

<pre>global treefilelist treeidlist treepending cmitmode diffids nullid nullid2

set nl 0
while {[incr nl] &lt;= 1000 &amp;&amp; [gets $gtf line] &gt;= 0} {
    if {$diffids eq $nullid} {
        set fname $line
    } else {
        set i [string first &quot;\t&quot; $line]
        if {$i &lt; 0} continue
        set fname [string range $line [expr {$i+1}] end]
        set line [string range $line 0 [expr {$i-1}]]
        if {$diffids ne $nullid2 &amp;&amp; [lindex $line 1] ne &quot;blob&quot;} continue
        set sha1 [lindex $line 2]
        lappend treeidlist($id) $sha1
    }
    if {[string index $fname 0] eq &quot;\&quot;&quot;} {
        set fname [lindex $fname 0]
    }
    set fname [encoding convertfrom $fname]
    lappend treefilelist($id) $fname
}
if {![eof $gtf]} {
    return [expr {$nl &gt;= 1000? 2: 1}]
}
close $gtf
unset treepending
if {$cmitmode ne &quot;tree&quot;} {
    if {![info exists diffmergeid]} {
        gettreediffs $diffids
    }
} elseif {$id ne $diffids} {
    gettree $diffids
} else {
    setfilelist $id
}
return 0</pre>

<p>}</p>

<p>proc showfile {f} {</p>

<pre>global treefilelist treeidlist diffids nullid nullid2
global ctext_file_names ctext_file_lines
global ctext commentend

set i [lsearch -exact $treefilelist($diffids) $f]
if {$i &lt; 0} {
    puts &quot;oops, $f not in list for id $diffids&quot;
    return
}
if {$diffids eq $nullid} {
    if {[catch {set bf [open $f r]} err]} {
        puts &quot;oops, can&#39;t read $f: $err&quot;
        return
    }
} else {
    set blob [lindex $treeidlist($diffids) $i]
    if {[catch {set bf [open [concat | git cat-file blob $blob] r]} err]} {
        puts &quot;oops, error reading blob $blob: $err&quot;
        return
    }
}
fconfigure $bf -blocking 0 -encoding [get_path_encoding $f]
filerun $bf [list getblobline $bf $diffids]
$ctext config -state normal
clear_ctext $commentend
lappend ctext_file_names $f
lappend ctext_file_lines [lindex [split $commentend &quot;.&quot;] 0]
$ctext insert end &quot;\n&quot;
$ctext insert end &quot;$f\n&quot; filesep
$ctext config -state disabled
$ctext yview $commentend
settabs 0</pre>

<p>}</p>

<p>proc getblobline {bf id} {</p>

<pre>global diffids cmitmode ctext

if {$id ne $diffids || $cmitmode ne &quot;tree&quot;} {
    catch {close $bf}
    return 0
}
$ctext config -state normal
set nl 0
while {[incr nl] &lt;= 1000 &amp;&amp; [gets $bf line] &gt;= 0} {
    $ctext insert end &quot;$line\n&quot;
}
if {[eof $bf]} {
    global jump_to_here ctext_file_names commentend

    # delete last newline
    $ctext delete &quot;end - 2c&quot; &quot;end - 1c&quot;
    close $bf
    if {$jump_to_here ne {} &amp;&amp;
        [lindex $jump_to_here 0] eq [lindex $ctext_file_names 0]} {
        set lnum [expr {[lindex $jump_to_here 1] +
                        [lindex [split $commentend .] 0]}]
        mark_ctext_line $lnum
    }
    $ctext config -state disabled
    return 0
}
$ctext config -state disabled
return [expr {$nl &gt;= 1000? 2: 1}]</pre>

<p>}</p>

<p>proc mark_ctext_line {lnum} {</p>

<pre>global ctext markbgcolor

$ctext tag delete omark
$ctext tag add omark $lnum.0 &quot;$lnum.0 + 1 line&quot;
$ctext tag conf omark -background $markbgcolor
$ctext see $lnum.0</pre>

<p>}</p>

<p>proc mergediff {id} {</p>

<pre>global diffmergeid
global diffids treediffs
global parents curview

set diffmergeid $id
set diffids $id
set treediffs($id) {}
set np [llength $parents($curview,$id)]
settabs $np
getblobdiffs $id</pre>

<p>}</p>

<p>proc startdiff {ids} {</p>

<pre>global treediffs diffids treepending diffmergeid nullid nullid2

settabs 1
set diffids $ids
catch {unset diffmergeid}
if {![info exists treediffs($ids)] ||
    [lsearch -exact $ids $nullid] &gt;= 0 ||
    [lsearch -exact $ids $nullid2] &gt;= 0} {
    if {![info exists treepending]} {
        gettreediffs $ids
    }
} else {
    addtocflist $ids
}</pre>

<p>}</p>

<p># If the filename (name) is under any of the passed filter paths # then
return true to include the file in the listing. proc path_filter {filter
name} {</p>

<pre>set worktree [gitworktree]
foreach p $filter {
    set fq_p [file normalize $p]
    set fq_n [file normalize [file join $worktree $name]]
    if {[string match [file normalize $fq_p]* $fq_n]} {
        return 1
    }
}
return 0</pre>

<p>}</p>

<p>proc addtocflist {ids} {</p>

<pre>global treediffs

add_flist $treediffs($ids)
getblobdiffs $ids</pre>

<p>}</p>

<p>proc diffcmd {ids flags} {</p>

<pre>global log_showroot nullid nullid2

set i [lsearch -exact $ids $nullid]
set j [lsearch -exact $ids $nullid2]
if {$i &gt;= 0} {
    if {[llength $ids] &gt; 1 &amp;&amp; $j &lt; 0} {
        # comparing working directory with some specific revision
        set cmd [concat | git diff-index $flags]
        if {$i == 0} {
            lappend cmd -R [lindex $ids 1]
        } else {
            lappend cmd [lindex $ids 0]
        }
    } else {
        # comparing working directory with index
        set cmd [concat | git diff-files $flags]
        if {$j == 1} {
            lappend cmd -R
        }
    }
} elseif {$j &gt;= 0} {
    set cmd [concat | git diff-index --cached $flags]
    if {[llength $ids] &gt; 1} {
        # comparing index with specific revision
        if {$j == 0} {
            lappend cmd -R [lindex $ids 1]
        } else {
            lappend cmd [lindex $ids 0]
        }
    } else {
        # comparing index with HEAD
        lappend cmd HEAD
    }
} else {
    if {$log_showroot} {
        lappend flags --root
    }
    set cmd [concat | git diff-tree -r $flags $ids]
}
return $cmd</pre>

<p>}</p>

<p>proc gettreediffs {ids} {</p>

<pre>global treediff treepending limitdiffs vfilelimit curview

set cmd [diffcmd $ids {--no-commit-id}]
if {$limitdiffs &amp;&amp; $vfilelimit($curview) ne {}} {
        set cmd [concat $cmd -- $vfilelimit($curview)]
}
if {[catch {set gdtf [open $cmd r]}]} return

set treepending $ids
set treediff {}
fconfigure $gdtf -blocking 0 -encoding binary
filerun $gdtf [list gettreediffline $gdtf $ids]</pre>

<p>}</p>

<p>proc gettreediffline {gdtf ids} {</p>

<pre>global treediff treediffs treepending diffids diffmergeid
global cmitmode vfilelimit curview limitdiffs perfile_attrs

set nr 0
set sublist {}
set max 1000
if {$perfile_attrs} {
    # cache_gitattr is slow, and even slower on win32 where we
    # have to invoke it for only about 30 paths at a time
    set max 500
    if {[tk windowingsystem] == &quot;win32&quot;} {
        set max 120
    }
}
while {[incr nr] &lt;= $max &amp;&amp; [gets $gdtf line] &gt;= 0} {
    set i [string first &quot;\t&quot; $line]
    if {$i &gt;= 0} {
        set file [string range $line [expr {$i+1}] end]
        if {[string index $file 0] eq &quot;\&quot;&quot;} {
            set file [lindex $file 0]
        }
        set file [encoding convertfrom $file]
        if {$file ne [lindex $treediff end]} {
            lappend treediff $file
            lappend sublist $file
        }
    }
}
if {$perfile_attrs} {
    cache_gitattr encoding $sublist
}
if {![eof $gdtf]} {
    return [expr {$nr &gt;= $max? 2: 1}]
}
close $gdtf
set treediffs($ids) $treediff
unset treepending
if {$cmitmode eq &quot;tree&quot; &amp;&amp; [llength $diffids] == 1} {
    gettree $diffids
} elseif {$ids != $diffids} {
    if {![info exists diffmergeid]} {
        gettreediffs $diffids
    }
} else {
    addtocflist $ids
}
return 0</pre>

<p>}</p>

<p># empty string or positive integer proc diffcontextvalidate {v} {</p>

<pre>return [regexp {^(|[1-9][0-9]*)$} $v]</pre>

<p>}</p>

<p>proc diffcontextchange {n1 n2 op} {</p>

<pre>global diffcontextstring diffcontext

if {[string is integer -strict $diffcontextstring]} {
    if {$diffcontextstring &gt;= 0} {
        set diffcontext $diffcontextstring
        reselectline
    }
}</pre>

<p>}</p>

<p>proc changeignorespace {} {</p>

<pre>reselectline</pre>

<p>}</p>

<p>proc changeworddiff {name ix op} {</p>

<pre>reselectline</pre>

<p>}</p>

<p>proc getblobdiffs {ids} {</p>

<pre>global blobdifffd diffids env
global diffinhdr treediffs
global diffcontext
global ignorespace
global worddiff
global limitdiffs vfilelimit curview
global diffencoding targetline diffnparents
global git_version currdiffsubmod

set textconv {}
if {[package vcompare $git_version &quot;1.6.1&quot;] &gt;= 0} {
    set textconv &quot;--textconv&quot;
}
set submodule {}
if {[package vcompare $git_version &quot;1.6.6&quot;] &gt;= 0} {
    set submodule &quot;--submodule&quot;
}
set cmd [diffcmd $ids &quot;-p $textconv $submodule  -C --cc --no-commit-id -U$diffcontext&quot;]
if {$ignorespace} {
    append cmd &quot; -w&quot;
}
if {$worddiff ne [mc &quot;Line diff&quot;]} {
    append cmd &quot; --word-diff=porcelain&quot;
}
if {$limitdiffs &amp;&amp; $vfilelimit($curview) ne {}} {
    set cmd [concat $cmd -- $vfilelimit($curview)]
}
if {[catch {set bdf [open $cmd r]} err]} {
    error_popup [mc &quot;Error getting diffs: %s&quot; $err]
    return
}
set targetline {}
set diffnparents 0
set diffinhdr 0
set diffencoding [get_path_encoding {}]
fconfigure $bdf -blocking 0 -encoding binary -eofchar {}
set blobdifffd($ids) $bdf
set currdiffsubmod &quot;&quot;
filerun $bdf [list getblobdiffline $bdf $diffids]</pre>

<p>}</p>

<p>proc savecmitpos {} {</p>

<pre>global ctext cmitmode

if {$cmitmode eq &quot;tree&quot;} {
    return {}
}
return [list target_scrollpos [$ctext index @0,0]]</pre>

<p>}</p>

<p>proc savectextpos {} {</p>

<pre>global ctext

return [list target_scrollpos [$ctext index @0,0]]</pre>

<p>}</p>

<p>proc maybe_scroll_ctext {ateof} {</p>

<pre>global ctext target_scrollpos

if {![info exists target_scrollpos]} return
if {!$ateof} {
    set nlines [expr {[winfo height $ctext]
                      / [font metrics textfont -linespace]}]
    if {[$ctext compare &quot;$target_scrollpos + $nlines lines&quot; &lt;= end]} return
}
$ctext yview $target_scrollpos
unset target_scrollpos</pre>

<p>}</p>

<p>proc setinlist {var i val} {</p>

<pre>global $var

while {[llength [set $var]] &lt; $i} {
    lappend $var {}
}
if {[llength [set $var]] == $i} {
    lappend $var $val
} else {
    lset $var $i $val
}</pre>

<p>}</p>

<p>proc makediffhdr {fname ids} {</p>

<pre>global ctext curdiffstart treediffs diffencoding
global ctext_file_names jump_to_here targetline diffline

set fname [encoding convertfrom $fname]
set diffencoding [get_path_encoding $fname]
set i [lsearch -exact $treediffs($ids) $fname]
if {$i &gt;= 0} {
    setinlist difffilestart $i $curdiffstart
}
lset ctext_file_names end $fname
set l [expr {(78 - [string length $fname]) / 2}]
set pad [string range &quot;----------------------------------------&quot; 1 $l]
$ctext insert $curdiffstart &quot;$pad $fname $pad&quot; filesep
set targetline {}
if {$jump_to_here ne {} &amp;&amp; [lindex $jump_to_here 0] eq $fname} {
    set targetline [lindex $jump_to_here 1]
}
set diffline 0</pre>

<p>}</p>

<p>proc getblobdiffline {bdf ids} {</p>

<pre>global diffids blobdifffd ctext curdiffstart
global diffnexthead diffnextnote difffilestart
global ctext_file_names ctext_file_lines
global diffinhdr treediffs mergemax diffnparents
global diffencoding jump_to_here targetline diffline currdiffsubmod
global worddiff

set nr 0
$ctext conf -state normal
while {[incr nr] &lt;= 1000 &amp;&amp; [gets $bdf line] &gt;= 0} {
    if {$ids != $diffids || $bdf != $blobdifffd($ids)} {
        catch {close $bdf}
        return 0
    }
    if {![string compare -length 5 &quot;diff &quot; $line]} {
        if {![regexp {^diff (--cc|--git) } $line m type]} {
            set line [encoding convertfrom $line]
            $ctext insert end &quot;$line\n&quot; hunksep
            continue
        }
        # start of a new file
        set diffinhdr 1
        $ctext insert end &quot;\n&quot;
        set curdiffstart [$ctext index &quot;end - 1c&quot;]
        lappend ctext_file_names &quot;&quot;
        lappend ctext_file_lines [lindex [split $curdiffstart &quot;.&quot;] 0]
        $ctext insert end &quot;\n&quot; filesep

        if {$type eq &quot;--cc&quot;} {
            # start of a new file in a merge diff
            set fname [string range $line 10 end]
            if {[lsearch -exact $treediffs($ids) $fname] &lt; 0} {
                lappend treediffs($ids) $fname
                add_flist [list $fname]
            }

        } else {
            set line [string range $line 11 end]
            # If the name hasn&#39;t changed the length will be odd,
            # the middle char will be a space, and the two bits either
            # side will be a/name and b/name, or &quot;a/name&quot; and &quot;b/name&quot;.
            # If the name has changed we&#39;ll get &quot;rename from&quot; and
            # &quot;rename to&quot; or &quot;copy from&quot; and &quot;copy to&quot; lines following
            # this, and we&#39;ll use them to get the filenames.
            # This complexity is necessary because spaces in the
            # filename(s) don&#39;t get escaped.
            set l [string length $line]
            set i [expr {$l / 2}]
            if {!(($l &amp; 1) &amp;&amp; [string index $line $i] eq &quot; &quot; &amp;&amp;
                  [string range $line 2 [expr {$i - 1}]] eq \
                      [string range $line [expr {$i + 3}] end])} {
                continue
            }
            # unescape if quoted and chop off the a/ from the front
            if {[string index $line 0] eq &quot;\&quot;&quot;} {
                set fname [string range [lindex $line 0] 2 end]
            } else {
                set fname [string range $line 2 [expr {$i - 1}]]
            }
        }
        makediffhdr $fname $ids

    } elseif {![string compare -length 16 &quot;* Unmerged path &quot; $line]} {
        set fname [encoding convertfrom [string range $line 16 end]]
        $ctext insert end &quot;\n&quot;
        set curdiffstart [$ctext index &quot;end - 1c&quot;]
        lappend ctext_file_names $fname
        lappend ctext_file_lines [lindex [split $curdiffstart &quot;.&quot;] 0]
        $ctext insert end &quot;$line\n&quot; filesep
        set i [lsearch -exact $treediffs($ids) $fname]
        if {$i &gt;= 0} {
            setinlist difffilestart $i $curdiffstart
        }

    } elseif {![string compare -length 2 &quot;@@&quot; $line]} {
        regexp {^@@+} $line ats
        set line [encoding convertfrom $diffencoding $line]
        $ctext insert end &quot;$line\n&quot; hunksep
        if {[regexp { \+(\d+),\d+ @@} $line m nl]} {
            set diffline $nl
        }
        set diffnparents [expr {[string length $ats] - 1}]
        set diffinhdr 0

    } elseif {![string compare -length 10 &quot;Submodule &quot; $line]} {
        # start of a new submodule
        if {[regexp -indices &quot;\[0-9a-f\]+\\.\\.&quot; $line nameend]} {
            set fname [string range $line 10 [expr [lindex $nameend 0] - 2]]
        } else {
            set fname [string range $line 10 [expr [string first &quot;contains &quot; $line] - 2]]
        }
        if {$currdiffsubmod != $fname} {
            $ctext insert end &quot;\n&quot;;     # Add newline after commit message
        }
        set curdiffstart [$ctext index &quot;end - 1c&quot;]
        lappend ctext_file_names &quot;&quot;
        if {$currdiffsubmod != $fname} {
            lappend ctext_file_lines $fname
            makediffhdr $fname $ids
            set currdiffsubmod $fname
            $ctext insert end &quot;\n$line\n&quot; filesep
        } else {
            $ctext insert end &quot;$line\n&quot; filesep
        }
    } elseif {![string compare -length 3 &quot;  &gt;&quot; $line]} {
        set $currdiffsubmod &quot;&quot;
        set line [encoding convertfrom $diffencoding $line]
        $ctext insert end &quot;$line\n&quot; dresult
    } elseif {![string compare -length 3 &quot;  &lt;&quot; $line]} {
        set $currdiffsubmod &quot;&quot;
        set line [encoding convertfrom $diffencoding $line]
        $ctext insert end &quot;$line\n&quot; d0
    } elseif {$diffinhdr} {
        if {![string compare -length 12 &quot;rename from &quot; $line]} {
            set fname [string range $line [expr 6 + [string first &quot; from &quot; $line] ] end]
            if {[string index $fname 0] eq &quot;\&quot;&quot;} {
                set fname [lindex $fname 0]
            }
            set fname [encoding convertfrom $fname]
            set i [lsearch -exact $treediffs($ids) $fname]
            if {$i &gt;= 0} {
                setinlist difffilestart $i $curdiffstart
            }
        } elseif {![string compare -length 10 $line &quot;rename to &quot;] ||
                  ![string compare -length 8 $line &quot;copy to &quot;]} {
            set fname [string range $line [expr 4 + [string first &quot; to &quot; $line] ] end]
            if {[string index $fname 0] eq &quot;\&quot;&quot;} {
                set fname [lindex $fname 0]
            }
            makediffhdr $fname $ids
        } elseif {[string compare -length 3 $line &quot;---&quot;] == 0} {
            # do nothing
            continue
        } elseif {[string compare -length 3 $line &quot;+++&quot;] == 0} {
            set diffinhdr 0
            continue
        }
        $ctext insert end &quot;$line\n&quot; filesep

    } else {
        set line [string map {\x1A ^Z} \
                      [encoding convertfrom $diffencoding $line]]
        # parse the prefix - one &#39; &#39;, &#39;-&#39; or &#39;+&#39; for each parent
        set prefix [string range $line 0 [expr {$diffnparents - 1}]]
        set tag [expr {$diffnparents &gt; 1? &quot;m&quot;: &quot;d&quot;}]
        set dowords [expr {$worddiff ne [mc &quot;Line diff&quot;] &amp;&amp; $diffnparents == 1}]
        set words_pre_markup &quot;&quot;
        set words_post_markup &quot;&quot;
        if {[string trim $prefix &quot; -+&quot;] eq {}} {
            # prefix only has &quot; &quot;, &quot;-&quot; and &quot;+&quot; in it: normal diff line
            set num [string first &quot;-&quot; $prefix]
            if {$dowords} {
                set line [string range $line 1 end]
            }
            if {$num &gt;= 0} {
                # removed line, first parent with line is $num
                if {$num &gt;= $mergemax} {
                    set num &quot;max&quot;
                }
                if {$dowords &amp;&amp; $worddiff eq [mc &quot;Markup words&quot;]} {
                    $ctext insert end &quot;\[-$line-\]&quot; $tag$num
                } else {
                    $ctext insert end &quot;$line&quot; $tag$num
                }
                if {!$dowords} {
                    $ctext insert end &quot;\n&quot; $tag$num
                }
            } else {
                set tags {}
                if {[string first &quot;+&quot; $prefix] &gt;= 0} {
                    # added line
                    lappend tags ${tag}result
                    if {$diffnparents &gt; 1} {
                        set num [string first &quot; &quot; $prefix]
                        if {$num &gt;= 0} {
                            if {$num &gt;= $mergemax} {
                                set num &quot;max&quot;
                            }
                            lappend tags m$num
                        }
                    }
                    set words_pre_markup &quot;{+&quot;
                    set words_post_markup &quot;+}&quot;
                }
                if {$targetline ne {}} {
                    if {$diffline == $targetline} {
                        set seehere [$ctext index &quot;end - 1 chars&quot;]
                        set targetline {}
                    } else {
                        incr diffline
                    }
                }
                if {$dowords &amp;&amp; $worddiff eq [mc &quot;Markup words&quot;]} {
                    $ctext insert end &quot;$words_pre_markup$line$words_post_markup&quot; $tags
                } else {
                    $ctext insert end &quot;$line&quot; $tags
                }
                if {!$dowords} {
                    $ctext insert end &quot;\n&quot; $tags
                }
            }
        } elseif {$dowords &amp;&amp; $prefix eq &quot;~&quot;} {
            $ctext insert end &quot;\n&quot; {}
        } else {
            # &quot;\ No newline at end of file&quot;,
            # or something else we don&#39;t recognize
            $ctext insert end &quot;$line\n&quot; hunksep
        }
    }
}
if {[info exists seehere]} {
    mark_ctext_line [lindex [split $seehere .] 0]
}
maybe_scroll_ctext [eof $bdf]
$ctext conf -state disabled
if {[eof $bdf]} {
    catch {close $bdf}
    return 0
}
return [expr {$nr &gt;= 1000? 2: 1}]</pre>

<p>}</p>

<p>proc changediffdisp {} {</p>

<pre>global ctext diffelide

$ctext tag conf d0 -elide [lindex $diffelide 0]
$ctext tag conf dresult -elide [lindex $diffelide 1]</pre>

<p>}</p>

<p>proc highlightfile {cline} {</p>

<pre>global cflist cflist_top

if {![info exists cflist_top]} return

$cflist tag remove highlight $cflist_top.0 &quot;$cflist_top.0 lineend&quot;
$cflist tag add highlight $cline.0 &quot;$cline.0 lineend&quot;
$cflist see $cline.0
set cflist_top $cline</pre>

<p>}</p>

<p>proc highlightfile_for_scrollpos {topidx} {</p>

<pre>global cmitmode difffilestart

if {$cmitmode eq &quot;tree&quot;} return
if {![info exists difffilestart]} return

set top [lindex [split $topidx .] 0]
if {$difffilestart eq {} || $top &lt; [lindex $difffilestart 0]} {
    highlightfile 0
} else {
    highlightfile [expr {[bsearch $difffilestart $top] + 2}]
}</pre>

<p>}</p>

<p>proc prevfile {} {</p>

<pre>global difffilestart ctext cmitmode

if {$cmitmode eq &quot;tree&quot;} return
set prev 0.0
set here [$ctext index @0,0]
foreach loc $difffilestart {
    if {[$ctext compare $loc &gt;= $here]} {
        $ctext yview $prev
        return
    }
    set prev $loc
}
$ctext yview $prev</pre>

<p>}</p>

<p>proc nextfile {} {</p>

<pre>global difffilestart ctext cmitmode

if {$cmitmode eq &quot;tree&quot;} return
set here [$ctext index @0,0]
foreach loc $difffilestart {
    if {[$ctext compare $loc &gt; $here]} {
        $ctext yview $loc
        return
    }
}</pre>

<p>}</p>

<p>proc clear_ctext {{first 1.0}} {</p>

<pre>global ctext smarktop smarkbot
global ctext_file_names ctext_file_lines
global pendinglinks

set l [lindex [split $first .] 0]
if {![info exists smarktop] || [$ctext compare $first &lt; $smarktop.0]} {
    set smarktop $l
}
if {![info exists smarkbot] || [$ctext compare $first &lt; $smarkbot.0]} {
    set smarkbot $l
}
$ctext delete $first end
if {$first eq &quot;1.0&quot;} {
    catch {unset pendinglinks}
}
set ctext_file_names {}
set ctext_file_lines {}</pre>

<p>}</p>

<p>proc settabs {{firstab {}}} {</p>

<pre>global firsttabstop tabstop ctext have_tk85

if {$firstab ne {} &amp;&amp; $have_tk85} {
    set firsttabstop $firstab
}
set w [font measure textfont &quot;0&quot;]
if {$firsttabstop != 0} {
    $ctext conf -tabs [list [expr {($firsttabstop + $tabstop) * $w}] \
                           [expr {($firsttabstop + 2 * $tabstop) * $w}]]
} elseif {$have_tk85 || $tabstop != 8} {
    $ctext conf -tabs [expr {$tabstop * $w}]
} else {
    $ctext conf -tabs {}
}</pre>

<p>}</p>

<p>proc incrsearch {name ix op} {</p>

<pre>global ctext searchstring searchdirn

if {[catch {$ctext index anchor}]} {
    # no anchor set, use start of selection, or of visible area
    set sel [$ctext tag ranges sel]
    if {$sel ne {}} {
        $ctext mark set anchor [lindex $sel 0]
    } elseif {$searchdirn eq &quot;-forwards&quot;} {
        $ctext mark set anchor @0,0
    } else {
        $ctext mark set anchor @0,[winfo height $ctext]
    }
}
if {$searchstring ne {}} {
    set here [$ctext search -count mlen $searchdirn -- $searchstring anchor]
    if {$here ne {}} {
        $ctext see $here
        set mend &quot;$here + $mlen c&quot;
        $ctext tag remove sel 1.0 end
        $ctext tag add sel $here $mend
        suppress_highlighting_file_for_current_scrollpos
        highlightfile_for_scrollpos $here
    }
}
rehighlight_search_results</pre>

<p>}</p>

<p>proc dosearch {} {</p>

<pre>global sstring ctext searchstring searchdirn

focus $sstring
$sstring icursor end
set searchdirn -forwards
if {$searchstring ne {}} {
    set sel [$ctext tag ranges sel]
    if {$sel ne {}} {
        set start &quot;[lindex $sel 0] + 1c&quot;
    } elseif {[catch {set start [$ctext index anchor]}]} {
        set start &quot;@0,0&quot;
    }
    set match [$ctext search -count mlen -- $searchstring $start]
    $ctext tag remove sel 1.0 end
    if {$match eq {}} {
        bell
        return
    }
    $ctext see $match
    suppress_highlighting_file_for_current_scrollpos
    highlightfile_for_scrollpos $match
    set mend &quot;$match + $mlen c&quot;
    $ctext tag add sel $match $mend
    $ctext mark unset anchor
    rehighlight_search_results
}</pre>

<p>}</p>

<p>proc dosearchback {} {</p>

<pre>global sstring ctext searchstring searchdirn

focus $sstring
$sstring icursor end
set searchdirn -backwards
if {$searchstring ne {}} {
    set sel [$ctext tag ranges sel]
    if {$sel ne {}} {
        set start [lindex $sel 0]
    } elseif {[catch {set start [$ctext index anchor]}]} {
        set start @0,[winfo height $ctext]
    }
    set match [$ctext search -backwards -count ml -- $searchstring $start]
    $ctext tag remove sel 1.0 end
    if {$match eq {}} {
        bell
        return
    }
    $ctext see $match
    suppress_highlighting_file_for_current_scrollpos
    highlightfile_for_scrollpos $match
    set mend &quot;$match + $ml c&quot;
    $ctext tag add sel $match $mend
    $ctext mark unset anchor
    rehighlight_search_results
}</pre>

<p>}</p>

<p>proc rehighlight_search_results {} {</p>

<pre>global ctext searchstring

$ctext tag remove found 1.0 end
$ctext tag remove currentsearchhit 1.0 end

if {$searchstring ne {}} {
    searchmarkvisible 1
}</pre>

<p>}</p>

<p>proc searchmark {first last} {</p>

<pre>global ctext searchstring

set sel [$ctext tag ranges sel]

set mend $first.0
while {1} {
    set match [$ctext search -count mlen -- $searchstring $mend $last.end]
    if {$match eq {}} break
    set mend &quot;$match + $mlen c&quot;
    if {$sel ne {} &amp;&amp; [$ctext compare $match == [lindex $sel 0]]} {
        $ctext tag add currentsearchhit $match $mend
    } else {
        $ctext tag add found $match $mend
    }
}</pre>

<p>}</p>

<p>proc searchmarkvisible {doall} {</p>

<pre>global ctext smarktop smarkbot

set topline [lindex [split [$ctext index @0,0] .] 0]
set botline [lindex [split [$ctext index @0,[winfo height $ctext]] .] 0]
if {$doall || $botline &lt; $smarktop || $topline &gt; $smarkbot} {
    # no overlap with previous
    searchmark $topline $botline
    set smarktop $topline
    set smarkbot $botline
} else {
    if {$topline &lt; $smarktop} {
        searchmark $topline [expr {$smarktop-1}]
        set smarktop $topline
    }
    if {$botline &gt; $smarkbot} {
        searchmark [expr {$smarkbot+1}] $botline
        set smarkbot $botline
    }
}</pre>

<p>}</p>

<p>proc suppress_highlighting_file_for_current_scrollpos {} {</p>

<pre>global ctext suppress_highlighting_file_for_this_scrollpos

set suppress_highlighting_file_for_this_scrollpos [$ctext index @0,0]</pre>

<p>}</p>

<p>proc scrolltext {f0 f1} {</p>

<pre>global searchstring cmitmode ctext
global suppress_highlighting_file_for_this_scrollpos

set topidx [$ctext index @0,0]
if {![info exists suppress_highlighting_file_for_this_scrollpos]
    || $topidx ne $suppress_highlighting_file_for_this_scrollpos} {
    highlightfile_for_scrollpos $topidx
}

catch {unset suppress_highlighting_file_for_this_scrollpos}

.bleft.bottom.sb set $f0 $f1
if {$searchstring ne {}} {
    searchmarkvisible 0
}</pre>

<p>}</p>

<p>proc setcoords {} {</p>

<pre>global linespc charspc canvx0 canvy0
global xspc1 xspc2 lthickness

set linespc [font metrics mainfont -linespace]
set charspc [font measure mainfont &quot;m&quot;]
set canvy0 [expr {int(3 + 0.5 * $linespc)}]
set canvx0 [expr {int(3 + 0.5 * $linespc)}]
set lthickness [expr {int($linespc / 9) + 1}]
set xspc1(0) $linespc
set xspc2 $linespc</pre>

<p>}</p>

<p>proc redisplay {} {</p>

<pre>global canv
global selectedline

set ymax [lindex [$canv cget -scrollregion] 3]
if {$ymax eq {} || $ymax == 0} return
set span [$canv yview]
clear_display
setcanvscroll
allcanvs yview moveto [lindex $span 0]
drawvisible
if {$selectedline ne {}} {
    selectline $selectedline 0
    allcanvs yview moveto [lindex $span 0]
}</pre>

<p>}</p>

<p>proc parsefont {f n} {</p>

<pre>global fontattr

set fontattr($f,family) [lindex $n 0]
set s [lindex $n 1]
if {$s eq {} || $s == 0} {
    set s 10
} elseif {$s &lt; 0} {
    set s [expr {int(-$s / [winfo fpixels . 1p] + 0.5)}]
}
set fontattr($f,size) $s
set fontattr($f,weight) normal
set fontattr($f,slant) roman
foreach style [lrange $n 2 end] {
    switch -- $style {
        &quot;normal&quot; -
        &quot;bold&quot;   {set fontattr($f,weight) $style}
        &quot;roman&quot; -
        &quot;italic&quot; {set fontattr($f,slant) $style}
    }
}</pre>

<p>}</p>

<p>proc fontflags {f {isbold 0}} {</p>

<pre>global fontattr

return [list -family $fontattr($f,family) -size $fontattr($f,size) \
            -weight [expr {$isbold? &quot;bold&quot;: $fontattr($f,weight)}] \
            -slant $fontattr($f,slant)]</pre>

<p>}</p>

<p>proc fontname {f} {</p>

<pre>global fontattr

set n [list $fontattr($f,family) $fontattr($f,size)]
if {$fontattr($f,weight) eq &quot;bold&quot;} {
    lappend n &quot;bold&quot;
}
if {$fontattr($f,slant) eq &quot;italic&quot;} {
    lappend n &quot;italic&quot;
}
return $n</pre>

<p>}</p>

<p>proc incrfont {inc} {</p>

<pre>global mainfont textfont ctext canv cflist showrefstop
global stopped entries fontattr

unmarkmatches
set s $fontattr(mainfont,size)
incr s $inc
if {$s &lt; 1} {
    set s 1
}
set fontattr(mainfont,size) $s
font config mainfont -size $s
font config mainfontbold -size $s
set mainfont [fontname mainfont]
set s $fontattr(textfont,size)
incr s $inc
if {$s &lt; 1} {
    set s 1
}
set fontattr(textfont,size) $s
font config textfont -size $s
font config textfontbold -size $s
set textfont [fontname textfont]
setcoords
settabs
redisplay</pre>

<p>}</p>

<p>proc clearsha1 {} {</p>

<pre>global sha1entry sha1string
if {[string length $sha1string] == 40} {
    $sha1entry delete 0 end
}</pre>

<p>}</p>

<p>proc sha1change {n1 n2 op} {</p>

<pre>global sha1string currentid sha1but
if {$sha1string == {}
    || ([info exists currentid] &amp;&amp; $sha1string == $currentid)} {
    set state disabled
} else {
    set state normal
}
if {[$sha1but cget -state] == $state} return
if {$state == &quot;normal&quot;} {
    $sha1but conf -state normal -relief raised -text &quot;[mc &quot;Goto:&quot;] &quot;
} else {
    $sha1but conf -state disabled -relief flat -text &quot;[mc &quot;SHA1 ID:&quot;] &quot;
}</pre>

<p>}</p>

<p>proc gotocommit {} {</p>

<pre>global sha1string tagids headids curview varcid

if {$sha1string == {}
    || ([info exists currentid] &amp;&amp; $sha1string == $currentid)} return
if {[info exists tagids($sha1string)]} {
    set id $tagids($sha1string)
} elseif {[info exists headids($sha1string)]} {
    set id $headids($sha1string)
} else {
    set id [string tolower $sha1string]
    if {[regexp {^[0-9a-f]{4,39}$} $id]} {
        set matches [longid $id]
        if {$matches ne {}} {
            if {[llength $matches] &gt; 1} {
                error_popup [mc &quot;Short SHA1 id %s is ambiguous&quot; $id]
                return
            }
            set id [lindex $matches 0]
        }
    } else {
        if {[catch {set id [exec git rev-parse --verify $sha1string]}]} {
            error_popup [mc &quot;Revision %s is not known&quot; $sha1string]
            return
        }
    }
}
if {[commitinview $id $curview]} {
    selectline [rowofcommit $id] 1
    return
}
if {[regexp {^[0-9a-fA-F]{4,}$} $sha1string]} {
    set msg [mc &quot;SHA1 id %s is not known&quot; $sha1string]
} else {
    set msg [mc &quot;Revision %s is not in the current view&quot; $sha1string]
}
error_popup $msg</pre>

<p>}</p>

<p>proc lineenter {x y id} {</p>

<pre>global hoverx hovery hoverid hovertimer
global commitinfo canv

if {![info exists commitinfo($id)] &amp;&amp; ![getcommit $id]} return
set hoverx $x
set hovery $y
set hoverid $id
if {[info exists hovertimer]} {
    after cancel $hovertimer
}
set hovertimer [after 500 linehover]
$canv delete hover</pre>

<p>}</p>

<p>proc linemotion {x y id} {</p>

<pre>global hoverx hovery hoverid hovertimer

if {[info exists hoverid] &amp;&amp; $id == $hoverid} {
    set hoverx $x
    set hovery $y
    if {[info exists hovertimer]} {
        after cancel $hovertimer
    }
    set hovertimer [after 500 linehover]
}</pre>

<p>}</p>

<p>proc lineleave {id} {</p>

<pre>global hoverid hovertimer canv

if {[info exists hoverid] &amp;&amp; $id == $hoverid} {
    $canv delete hover
    if {[info exists hovertimer]} {
        after cancel $hovertimer
        unset hovertimer
    }
    unset hoverid
}</pre>

<p>}</p>

<p>proc linehover {} {</p>

<pre>global hoverx hovery hoverid hovertimer
global canv linespc lthickness
global linehoverbgcolor linehoverfgcolor linehoveroutlinecolor

global commitinfo

set text [lindex $commitinfo($hoverid) 0]
set ymax [lindex [$canv cget -scrollregion] 3]
if {$ymax == {}} return
set yfrac [lindex [$canv yview] 0]
set x [expr {$hoverx + 2 * $linespc}]
set y [expr {$hovery + $yfrac * $ymax - $linespc / 2}]
set x0 [expr {$x - 2 * $lthickness}]
set y0 [expr {$y - 2 * $lthickness}]
set x1 [expr {$x + [font measure mainfont $text] + 2 * $lthickness}]
set y1 [expr {$y + $linespc + 2 * $lthickness}]
set t [$canv create rectangle $x0 $y0 $x1 $y1 \
           -fill $linehoverbgcolor -outline $linehoveroutlinecolor \
           -width 1 -tags hover]
$canv raise $t
set t [$canv create text $x $y -anchor nw -text $text -tags hover \
           -font mainfont -fill $linehoverfgcolor]
$canv raise $t</pre>

<p>}</p>

<p>proc clickisonarrow {id y} {</p>

<pre>global lthickness

set ranges [rowranges $id]
set thresh [expr {2 * $lthickness + 6}]
set n [expr {[llength $ranges] - 1}]
for {set i 1} {$i &lt; $n} {incr i} {
    set row [lindex $ranges $i]
    if {abs([yc $row] - $y) &lt; $thresh} {
        return $i
    }
}
return {}</pre>

<p>}</p>

<p>proc arrowjump {id n y} {</p>

<pre>global canv

# 1 &lt;-&gt; 2, 3 &lt;-&gt; 4, etc...
set n [expr {(($n - 1) ^ 1) + 1}]
set row [lindex [rowranges $id] $n]
set yt [yc $row]
set ymax [lindex [$canv cget -scrollregion] 3]
if {$ymax eq {} || $ymax &lt;= 0} return
set view [$canv yview]
set yspan [expr {[lindex $view 1] - [lindex $view 0]}]
set yfrac [expr {$yt / $ymax - $yspan / 2}]
if {$yfrac &lt; 0} {
    set yfrac 0
}
allcanvs yview moveto $yfrac</pre>

<p>}</p>

<p>proc lineclick {x y id isnew} {</p>

<pre>global ctext commitinfo children canv thickerline curview

if {![info exists commitinfo($id)] &amp;&amp; ![getcommit $id]} return
unmarkmatches
unselectline
normalline
$canv delete hover
# draw this line thicker than normal
set thickerline $id
drawlines $id
if {$isnew} {
    set ymax [lindex [$canv cget -scrollregion] 3]
    if {$ymax eq {}} return
    set yfrac [lindex [$canv yview] 0]
    set y [expr {$y + $yfrac * $ymax}]
}
set dirn [clickisonarrow $id $y]
if {$dirn ne {}} {
    arrowjump $id $dirn $y
    return
}

if {$isnew} {
    addtohistory [list lineclick $x $y $id 0] savectextpos
}
# fill the details pane with info about this line
$ctext conf -state normal
clear_ctext
settabs 0
$ctext insert end &quot;[mc &quot;Parent&quot;]:\t&quot;
$ctext insert end $id link0
setlink $id link0
set info $commitinfo($id)
$ctext insert end &quot;\n\t[lindex $info 0]\n&quot;
$ctext insert end &quot;\t[mc &quot;Author&quot;]:\t[lindex $info 1]\n&quot;
set date [formatdate [lindex $info 2]]
$ctext insert end &quot;\t[mc &quot;Date&quot;]:\t$date\n&quot;
set kids $children($curview,$id)
if {$kids ne {}} {
    $ctext insert end &quot;\n[mc &quot;Children&quot;]:&quot;
    set i 0
    foreach child $kids {
        incr i
        if {![info exists commitinfo($child)] &amp;&amp; ![getcommit $child]} continue
        set info $commitinfo($child)
        $ctext insert end &quot;\n\t&quot;
        $ctext insert end $child link$i
        setlink $child link$i
        $ctext insert end &quot;\n\t[lindex $info 0]&quot;
        $ctext insert end &quot;\n\t[mc &quot;Author&quot;]:\t[lindex $info 1]&quot;
        set date [formatdate [lindex $info 2]]
        $ctext insert end &quot;\n\t[mc &quot;Date&quot;]:\t$date\n&quot;
    }
}
maybe_scroll_ctext 1
$ctext conf -state disabled
init_flist {}</pre>

<p>}</p>

<p>proc normalline {} {</p>

<pre>global thickerline
if {[info exists thickerline]} {
    set id $thickerline
    unset thickerline
    drawlines $id
}</pre>

<p>}</p>

<p>proc selbyid {id {isnew 1}} {</p>

<pre>global curview
if {[commitinview $id $curview]} {
    selectline [rowofcommit $id] $isnew
}</pre>

<p>}</p>

<p>proc mstime {} {</p>

<pre>global startmstime
if {![info exists startmstime]} {
    set startmstime [clock clicks -milliseconds]
}
return [format &quot;%.3f&quot; [expr {([clock click -milliseconds] - $startmstime) / 1000.0}]]</pre>

<p>}</p>

<p>proc rowmenu {x y id} {</p>

<pre>global rowctxmenu selectedline rowmenuid curview
global nullid nullid2 fakerowmenu mainhead markedid

stopfinding
set rowmenuid $id
if {$selectedline eq {} || [rowofcommit $id] eq $selectedline} {
    set state disabled
} else {
    set state normal
}
if {[info exists markedid] &amp;&amp; $markedid ne $id} {
    set mstate normal
} else {
    set mstate disabled
}
if {$id ne $nullid &amp;&amp; $id ne $nullid2} {
    set menu $rowctxmenu
    if {$mainhead ne {}} {
        $menu entryconfigure 7 -label [mc &quot;Reset %s branch to here&quot; $mainhead] -state normal
    } else {
        $menu entryconfigure 7 -label [mc &quot;Detached head: can&#39;t reset&quot; $mainhead] -state disabled
    }
    $menu entryconfigure 9 -state $mstate
    $menu entryconfigure 10 -state $mstate
    $menu entryconfigure 11 -state $mstate
} else {
    set menu $fakerowmenu
}
$menu entryconfigure [mca &quot;Diff this -&gt; selected&quot;] -state $state
$menu entryconfigure [mca &quot;Diff selected -&gt; this&quot;] -state $state
$menu entryconfigure [mca &quot;Make patch&quot;] -state $state
$menu entryconfigure [mca &quot;Diff this -&gt; marked commit&quot;] -state $mstate
$menu entryconfigure [mca &quot;Diff marked commit -&gt; this&quot;] -state $mstate
tk_popup $menu $x $y</pre>

<p>}</p>

<p>proc markhere {} {</p>

<pre>global rowmenuid markedid canv

set markedid $rowmenuid
make_idmark $markedid</pre>

<p>}</p>

<p>proc gotomark {} {</p>

<pre>global markedid

if {[info exists markedid]} {
    selbyid $markedid
}</pre>

<p>}</p>

<p>proc replace_by_kids {l r} {</p>

<pre>global curview children

set id [commitonrow $r]
set l [lreplace $l 0 0]
foreach kid $children($curview,$id) {
    lappend l [rowofcommit $kid]
}
return [lsort -integer -decreasing -unique $l]</pre>

<p>}</p>

<p>proc find_common_desc {} {</p>

<pre>global markedid rowmenuid curview children

if {![info exists markedid]} return
if {![commitinview $markedid $curview] ||
    ![commitinview $rowmenuid $curview]} return
#set t1 [clock clicks -milliseconds]
set l1 [list [rowofcommit $markedid]]
set l2 [list [rowofcommit $rowmenuid]]
while 1 {
    set r1 [lindex $l1 0]
    set r2 [lindex $l2 0]
    if {$r1 eq {} || $r2 eq {}} break
    if {$r1 == $r2} {
        selectline $r1 1
        break
    }
    if {$r1 &gt; $r2} {
        set l1 [replace_by_kids $l1 $r1]
    } else {
        set l2 [replace_by_kids $l2 $r2]
    }
}
#set t2 [clock clicks -milliseconds]
#puts &quot;took [expr {$t2-$t1}]ms&quot;</pre>

<p>}</p>

<p>proc compare_commits {} {</p>

<pre>global markedid rowmenuid curview children

if {![info exists markedid]} return
if {![commitinview $markedid $curview]} return
addtohistory [list do_cmp_commits $markedid $rowmenuid]
do_cmp_commits $markedid $rowmenuid</pre>

<p>}</p>

<p>proc getpatchid {id} {</p>

<pre>global patchids

if {![info exists patchids($id)]} {
    set cmd [diffcmd [list $id] {-p --root}]
    # trim off the initial &quot;|&quot;
    set cmd [lrange $cmd 1 end]
    if {[catch {
        set x [eval exec $cmd | git patch-id]
        set patchids($id) [lindex $x 0]
    }]} {
        set patchids($id) &quot;error&quot;
    }
}
return $patchids($id)</pre>

<p>}</p>

<p>proc do_cmp_commits {a b} {</p>

<pre>global ctext curview parents children patchids commitinfo

$ctext conf -state normal
clear_ctext
init_flist {}
for {set i 0} {$i &lt; 100} {incr i} {
    set skipa 0
    set skipb 0
    if {[llength $parents($curview,$a)] &gt; 1} {
        appendshortlink $a [mc &quot;Skipping merge commit &quot;] &quot;\n&quot;
        set skipa 1
    } else {
        set patcha [getpatchid $a]
    }
    if {[llength $parents($curview,$b)] &gt; 1} {
        appendshortlink $b [mc &quot;Skipping merge commit &quot;] &quot;\n&quot;
        set skipb 1
    } else {
        set patchb [getpatchid $b]
    }
    if {!$skipa &amp;&amp; !$skipb} {
        set heada [lindex $commitinfo($a) 0]
        set headb [lindex $commitinfo($b) 0]
        if {$patcha eq &quot;error&quot;} {
            appendshortlink $a [mc &quot;Error getting patch ID for &quot;] \
                [mc &quot; - stopping\n&quot;]
            break
        }
        if {$patchb eq &quot;error&quot;} {
            appendshortlink $b [mc &quot;Error getting patch ID for &quot;] \
                [mc &quot; - stopping\n&quot;]
            break
        }
        if {$patcha eq $patchb} {
            if {$heada eq $headb} {
                appendshortlink $a [mc &quot;Commit &quot;]
                appendshortlink $b &quot; == &quot; &quot;  $heada\n&quot;
            } else {
                appendshortlink $a [mc &quot;Commit &quot;] &quot;  $heada\n&quot;
                appendshortlink $b [mc &quot; is the same patch as\n       &quot;] \
                    &quot;  $headb\n&quot;
            }
            set skipa 1
            set skipb 1
        } else {
            $ctext insert end &quot;\n&quot;
            appendshortlink $a [mc &quot;Commit &quot;] &quot;  $heada\n&quot;
            appendshortlink $b [mc &quot; differs from\n       &quot;] \
                &quot;  $headb\n&quot;
            $ctext insert end [mc &quot;Diff of commits:\n\n&quot;]
            $ctext conf -state disabled
            update
            diffcommits $a $b
            return
        }
    }
    if {$skipa} {
        set kids [real_children $curview,$a]
        if {[llength $kids] != 1} {
            $ctext insert end &quot;\n&quot;
            appendshortlink $a [mc &quot;Commit &quot;] \
                [mc &quot; has %s children - stopping\n&quot; [llength $kids]]
            break
        }
        set a [lindex $kids 0]
    }
    if {$skipb} {
        set kids [real_children $curview,$b]
        if {[llength $kids] != 1} {
            appendshortlink $b [mc &quot;Commit &quot;] \
                [mc &quot; has %s children - stopping\n&quot; [llength $kids]]
            break
        }
        set b [lindex $kids 0]
    }
}
$ctext conf -state disabled</pre>

<p>}</p>

<p>proc diffcommits {a b} {</p>

<pre>global diffcontext diffids blobdifffd diffinhdr currdiffsubmod

set tmpdir [gitknewtmpdir]
set fna [file join $tmpdir &quot;commit-[string range $a 0 7]&quot;]
set fnb [file join $tmpdir &quot;commit-[string range $b 0 7]&quot;]
if {[catch {
    exec git diff-tree -p --pretty $a &gt;$fna
    exec git diff-tree -p --pretty $b &gt;$fnb
} err]} {
    error_popup [mc &quot;Error writing commit to file: %s&quot; $err]
    return
}
if {[catch {
    set fd [open &quot;| diff -U$diffcontext $fna $fnb&quot; r]
} err]} {
    error_popup [mc &quot;Error diffing commits: %s&quot; $err]
    return
}
set diffids [list commits $a $b]
set blobdifffd($diffids) $fd
set diffinhdr 0
set currdiffsubmod &quot;&quot;
filerun $fd [list getblobdiffline $fd $diffids]</pre>

<p>}</p>

<p>proc diffvssel {dirn} {</p>

<pre>global rowmenuid selectedline

if {$selectedline eq {}} return
if {$dirn} {
    set oldid [commitonrow $selectedline]
    set newid $rowmenuid
} else {
    set oldid $rowmenuid
    set newid [commitonrow $selectedline]
}
addtohistory [list doseldiff $oldid $newid] savectextpos
doseldiff $oldid $newid</pre>

<p>}</p>

<p>proc diffvsmark {dirn} {</p>

<pre>global rowmenuid markedid

if {![info exists markedid]} return
if {$dirn} {
    set oldid $markedid
    set newid $rowmenuid
} else {
    set oldid $rowmenuid
    set newid $markedid
}
addtohistory [list doseldiff $oldid $newid] savectextpos
doseldiff $oldid $newid</pre>

<p>}</p>

<p>proc doseldiff {oldid newid} {</p>

<pre>global ctext
global commitinfo

$ctext conf -state normal
clear_ctext
init_flist [mc &quot;Top&quot;]
$ctext insert end &quot;[mc &quot;From&quot;] &quot;
$ctext insert end $oldid link0
setlink $oldid link0
$ctext insert end &quot;\n     &quot;
$ctext insert end [lindex $commitinfo($oldid) 0]
$ctext insert end &quot;\n\n[mc &quot;To&quot;]   &quot;
$ctext insert end $newid link1
setlink $newid link1
$ctext insert end &quot;\n     &quot;
$ctext insert end [lindex $commitinfo($newid) 0]
$ctext insert end &quot;\n&quot;
$ctext conf -state disabled
$ctext tag remove found 1.0 end
startdiff [list $oldid $newid]</pre>

<p>}</p>

<p>proc mkpatch {} {</p>

<pre>global rowmenuid currentid commitinfo patchtop patchnum NS

if {![info exists currentid]} return
set oldid $currentid
set oldhead [lindex $commitinfo($oldid) 0]
set newid $rowmenuid
set newhead [lindex $commitinfo($newid) 0]
set top .patch
set patchtop $top
catch {destroy $top}
ttk_toplevel $top
make_transient $top .
${NS}::label $top.title -text [mc &quot;Generate patch&quot;]
grid $top.title - -pady 10
${NS}::label $top.from -text [mc &quot;From:&quot;]
${NS}::entry $top.fromsha1 -width 40
$top.fromsha1 insert 0 $oldid
$top.fromsha1 conf -state readonly
grid $top.from $top.fromsha1 -sticky w
${NS}::entry $top.fromhead -width 60
$top.fromhead insert 0 $oldhead
$top.fromhead conf -state readonly
grid x $top.fromhead -sticky w
${NS}::label $top.to -text [mc &quot;To:&quot;]
${NS}::entry $top.tosha1 -width 40
$top.tosha1 insert 0 $newid
$top.tosha1 conf -state readonly
grid $top.to $top.tosha1 -sticky w
${NS}::entry $top.tohead -width 60
$top.tohead insert 0 $newhead
$top.tohead conf -state readonly
grid x $top.tohead -sticky w
${NS}::button $top.rev -text [mc &quot;Reverse&quot;] -command mkpatchrev
grid $top.rev x -pady 10 -padx 5
${NS}::label $top.flab -text [mc &quot;Output file:&quot;]
${NS}::entry $top.fname -width 60
$top.fname insert 0 [file normalize &quot;patch$patchnum.patch&quot;]
incr patchnum
grid $top.flab $top.fname -sticky w
${NS}::frame $top.buts
${NS}::button $top.buts.gen -text [mc &quot;Generate&quot;] -command mkpatchgo
${NS}::button $top.buts.can -text [mc &quot;Cancel&quot;] -command mkpatchcan
bind $top &lt;Key-Return&gt; mkpatchgo
bind $top &lt;Key-Escape&gt; mkpatchcan
grid $top.buts.gen $top.buts.can
grid columnconfigure $top.buts 0 -weight 1 -uniform a
grid columnconfigure $top.buts 1 -weight 1 -uniform a
grid $top.buts - -pady 10 -sticky ew
focus $top.fname</pre>

<p>}</p>

<p>proc mkpatchrev {} {</p>

<pre>global patchtop

set oldid [$patchtop.fromsha1 get]
set oldhead [$patchtop.fromhead get]
set newid [$patchtop.tosha1 get]
set newhead [$patchtop.tohead get]
foreach e [list fromsha1 fromhead tosha1 tohead] \
        v [list $newid $newhead $oldid $oldhead] {
    $patchtop.$e conf -state normal
    $patchtop.$e delete 0 end
    $patchtop.$e insert 0 $v
    $patchtop.$e conf -state readonly
}</pre>

<p>}</p>

<p>proc mkpatchgo {} {</p>

<pre>global patchtop nullid nullid2

set oldid [$patchtop.fromsha1 get]
set newid [$patchtop.tosha1 get]
set fname [$patchtop.fname get]
set cmd [diffcmd [list $oldid $newid] -p]
# trim off the initial &quot;|&quot;
set cmd [lrange $cmd 1 end]
lappend cmd &gt;$fname &amp;
if {[catch {eval exec $cmd} err]} {
    error_popup &quot;[mc &quot;Error creating patch:&quot;] $err&quot; $patchtop
}
catch {destroy $patchtop}
unset patchtop</pre>

<p>}</p>

<p>proc mkpatchcan {} {</p>

<pre>global patchtop

catch {destroy $patchtop}
unset patchtop</pre>

<p>}</p>

<p>proc mktag {} {</p>

<pre>global rowmenuid mktagtop commitinfo NS

set top .maketag
set mktagtop $top
catch {destroy $top}
ttk_toplevel $top
make_transient $top .
${NS}::label $top.title -text [mc &quot;Create tag&quot;]
grid $top.title - -pady 10
${NS}::label $top.id -text [mc &quot;ID:&quot;]
${NS}::entry $top.sha1 -width 40
$top.sha1 insert 0 $rowmenuid
$top.sha1 conf -state readonly
grid $top.id $top.sha1 -sticky w
${NS}::entry $top.head -width 60
$top.head insert 0 [lindex $commitinfo($rowmenuid) 0]
$top.head conf -state readonly
grid x $top.head -sticky w
${NS}::label $top.tlab -text [mc &quot;Tag name:&quot;]
${NS}::entry $top.tag -width 60
grid $top.tlab $top.tag -sticky w
${NS}::label $top.op -text [mc &quot;Tag message is optional&quot;]
grid $top.op -columnspan 2 -sticky we
${NS}::label $top.mlab -text [mc &quot;Tag message:&quot;]
${NS}::entry $top.msg -width 60
grid $top.mlab $top.msg -sticky w
${NS}::frame $top.buts
${NS}::button $top.buts.gen -text [mc &quot;Create&quot;] -command mktaggo
${NS}::button $top.buts.can -text [mc &quot;Cancel&quot;] -command mktagcan
bind $top &lt;Key-Return&gt; mktaggo
bind $top &lt;Key-Escape&gt; mktagcan
grid $top.buts.gen $top.buts.can
grid columnconfigure $top.buts 0 -weight 1 -uniform a
grid columnconfigure $top.buts 1 -weight 1 -uniform a
grid $top.buts - -pady 10 -sticky ew
focus $top.tag</pre>

<p>}</p>

<p>proc domktag {} {</p>

<pre>global mktagtop env tagids idtags

set id [$mktagtop.sha1 get]
set tag [$mktagtop.tag get]
set msg [$mktagtop.msg get]
if {$tag == {}} {
    error_popup [mc &quot;No tag name specified&quot;] $mktagtop
    return 0
}
if {[info exists tagids($tag)]} {
    error_popup [mc &quot;Tag \&quot;%s\&quot; already exists&quot; $tag] $mktagtop
    return 0
}
if {[catch {
    if {$msg != {}} {
        exec git tag -a -m $msg $tag $id
    } else {
        exec git tag $tag $id
    }
} err]} {
    error_popup &quot;[mc &quot;Error creating tag:&quot;] $err&quot; $mktagtop
    return 0
}

set tagids($tag) $id
lappend idtags($id) $tag
redrawtags $id
addedtag $id
dispneartags 0
run refill_reflist
return 1</pre>

<p>}</p>

<p>proc redrawtags {id} {</p>

<pre>global canv linehtag idpos currentid curview cmitlisted markedid
global canvxmax iddrawn circleitem mainheadid circlecolors
global mainheadcirclecolor

if {![commitinview $id $curview]} return
if {![info exists iddrawn($id)]} return
set row [rowofcommit $id]
if {$id eq $mainheadid} {
    set ofill $mainheadcirclecolor
} else {
    set ofill [lindex $circlecolors $cmitlisted($curview,$id)]
}
$canv itemconf $circleitem($row) -fill $ofill
$canv delete tag.$id
set xt [eval drawtags $id $idpos($id)]
$canv coords $linehtag($id) $xt [lindex $idpos($id) 2]
set text [$canv itemcget $linehtag($id) -text]
set font [$canv itemcget $linehtag($id) -font]
set xr [expr {$xt + [font measure $font $text]}]
if {$xr &gt; $canvxmax} {
    set canvxmax $xr
    setcanvscroll
}
if {[info exists currentid] &amp;&amp; $currentid == $id} {
    make_secsel $id
}
if {[info exists markedid] &amp;&amp; $markedid eq $id} {
    make_idmark $id
}</pre>

<p>}</p>

<p>proc mktagcan {} {</p>

<pre>global mktagtop

catch {destroy $mktagtop}
unset mktagtop</pre>

<p>}</p>

<p>proc mktaggo {} {</p>

<pre>if {![domktag]} return
mktagcan</pre>

<p>}</p>

<p>proc writecommit {} {</p>

<pre>global rowmenuid wrcomtop commitinfo wrcomcmd NS

set top .writecommit
set wrcomtop $top
catch {destroy $top}
ttk_toplevel $top
make_transient $top .
${NS}::label $top.title -text [mc &quot;Write commit to file&quot;]
grid $top.title - -pady 10
${NS}::label $top.id -text [mc &quot;ID:&quot;]
${NS}::entry $top.sha1 -width 40
$top.sha1 insert 0 $rowmenuid
$top.sha1 conf -state readonly
grid $top.id $top.sha1 -sticky w
${NS}::entry $top.head -width 60
$top.head insert 0 [lindex $commitinfo($rowmenuid) 0]
$top.head conf -state readonly
grid x $top.head -sticky w
${NS}::label $top.clab -text [mc &quot;Command:&quot;]
${NS}::entry $top.cmd -width 60 -textvariable wrcomcmd
grid $top.clab $top.cmd -sticky w -pady 10
${NS}::label $top.flab -text [mc &quot;Output file:&quot;]
${NS}::entry $top.fname -width 60
$top.fname insert 0 [file normalize &quot;commit-[string range $rowmenuid 0 6]&quot;]
grid $top.flab $top.fname -sticky w
${NS}::frame $top.buts
${NS}::button $top.buts.gen -text [mc &quot;Write&quot;] -command wrcomgo
${NS}::button $top.buts.can -text [mc &quot;Cancel&quot;] -command wrcomcan
bind $top &lt;Key-Return&gt; wrcomgo
bind $top &lt;Key-Escape&gt; wrcomcan
grid $top.buts.gen $top.buts.can
grid columnconfigure $top.buts 0 -weight 1 -uniform a
grid columnconfigure $top.buts 1 -weight 1 -uniform a
grid $top.buts - -pady 10 -sticky ew
focus $top.fname</pre>

<p>}</p>

<p>proc wrcomgo {} {</p>

<pre>global wrcomtop

set id [$wrcomtop.sha1 get]
set cmd &quot;echo $id | [$wrcomtop.cmd get]&quot;
set fname [$wrcomtop.fname get]
if {[catch {exec sh -c $cmd &gt;$fname &amp;} err]} {
    error_popup &quot;[mc &quot;Error writing commit:&quot;] $err&quot; $wrcomtop
}
catch {destroy $wrcomtop}
unset wrcomtop</pre>

<p>}</p>

<p>proc wrcomcan {} {</p>

<pre>global wrcomtop

catch {destroy $wrcomtop}
unset wrcomtop</pre>

<p>}</p>

<p>proc mkbranch {} {</p>

<pre>global rowmenuid mkbrtop NS

set top .makebranch
catch {destroy $top}
ttk_toplevel $top
make_transient $top .
${NS}::label $top.title -text [mc &quot;Create new branch&quot;]
grid $top.title - -pady 10
${NS}::label $top.id -text [mc &quot;ID:&quot;]
${NS}::entry $top.sha1 -width 40
$top.sha1 insert 0 $rowmenuid
$top.sha1 conf -state readonly
grid $top.id $top.sha1 -sticky w
${NS}::label $top.nlab -text [mc &quot;Name:&quot;]
${NS}::entry $top.name -width 40
grid $top.nlab $top.name -sticky w
${NS}::frame $top.buts
${NS}::button $top.buts.go -text [mc &quot;Create&quot;] -command [list mkbrgo $top]
${NS}::button $top.buts.can -text [mc &quot;Cancel&quot;] -command &quot;catch {destroy $top}&quot;
bind $top &lt;Key-Return&gt; [list mkbrgo $top]
bind $top &lt;Key-Escape&gt; &quot;catch {destroy $top}&quot;
grid $top.buts.go $top.buts.can
grid columnconfigure $top.buts 0 -weight 1 -uniform a
grid columnconfigure $top.buts 1 -weight 1 -uniform a
grid $top.buts - -pady 10 -sticky ew
focus $top.name</pre>

<p>}</p>

<p>proc mkbrgo {top} {</p>

<pre>global headids idheads

set name [$top.name get]
set id [$top.sha1 get]
set cmdargs {}
set old_id {}
if {$name eq {}} {
    error_popup [mc &quot;Please specify a name for the new branch&quot;] $top
    return
}
if {[info exists headids($name)]} {
    if {![confirm_popup [mc \
            &quot;Branch &#39;%s&#39; already exists. Overwrite?&quot; $name] $top]} {
        return
    }
    set old_id $headids($name)
    lappend cmdargs -f
}
catch {destroy $top}
lappend cmdargs $name $id
nowbusy newbranch
update
if {[catch {
    eval exec git branch $cmdargs
} err]} {
    notbusy newbranch
    error_popup $err
} else {
    notbusy newbranch
    if {$old_id ne {}} {
        movehead $id $name
        movedhead $id $name
        redrawtags $old_id
        redrawtags $id
    } else {
        set headids($name) $id
        lappend idheads($id) $name
        addedhead $id $name
        redrawtags $id
    }
    dispneartags 0
    run refill_reflist
}</pre>

<p>}</p>

<p>proc exec_citool {tool_args {baseid {}}} {</p>

<pre>global commitinfo env

set save_env [array get env GIT_AUTHOR_*]

if {$baseid ne {}} {
    if {![info exists commitinfo($baseid)]} {
        getcommit $baseid
    }
    set author [lindex $commitinfo($baseid) 1]
    set date [lindex $commitinfo($baseid) 2]
    if {[regexp {^\s*(\S.*\S|\S)\s*&lt;(.*)&gt;\s*$} \
                $author author name email]
        &amp;&amp; $date ne {}} {
        set env(GIT_AUTHOR_NAME) $name
        set env(GIT_AUTHOR_EMAIL) $email
        set env(GIT_AUTHOR_DATE) $date
    }
}

eval exec git citool $tool_args &amp;

array unset env GIT_AUTHOR_*
array set env $save_env</pre>

<p>}</p>

<p>proc cherrypick {} {</p>

<pre>global rowmenuid curview
global mainhead mainheadid
global gitdir

set oldhead [exec git rev-parse HEAD]
set dheads [descheads $rowmenuid]
if {$dheads ne {} &amp;&amp; [lsearch -exact $dheads $oldhead] &gt;= 0} {
    set ok [confirm_popup [mc &quot;Commit %s is already\
            included in branch %s -- really re-apply it?&quot; \
                               [string range $rowmenuid 0 7] $mainhead]]
    if {!$ok} return
}
nowbusy cherrypick [mc &quot;Cherry-picking&quot;]
update
# Unfortunately git-cherry-pick writes stuff to stderr even when
# no error occurs, and exec takes that as an indication of error...
if {[catch {exec sh -c &quot;git cherry-pick -r $rowmenuid 2&gt;&amp;1&quot;} err]} {
    notbusy cherrypick
    if {[regexp -line \
             {Entry &#39;(.*)&#39; (would be overwritten by merge|not uptodate)} \
             $err msg fname]} {
        error_popup [mc &quot;Cherry-pick failed because of local changes\
                    to file &#39;%s&#39;.\nPlease commit, reset or stash\
                    your changes and try again.&quot; $fname]
    } elseif {[regexp -line \
                   {^(CONFLICT \(.*\):|Automatic cherry-pick failed|error: could not apply)} \
                   $err]} {
        if {[confirm_popup [mc &quot;Cherry-pick failed because of merge\
                    conflict.\nDo you wish to run git citool to\
                    resolve it?&quot;]]} {
            # Force citool to read MERGE_MSG
            file delete [file join $gitdir &quot;GITGUI_MSG&quot;]
            exec_citool {} $rowmenuid
        }
    } else {
        error_popup $err
    }
    run updatecommits
    return
}
set newhead [exec git rev-parse HEAD]
if {$newhead eq $oldhead} {
    notbusy cherrypick
    error_popup [mc &quot;No changes committed&quot;]
    return
}
addnewchild $newhead $oldhead
if {[commitinview $oldhead $curview]} {
    # XXX this isn&#39;t right if we have a path limit...
    insertrow $newhead $oldhead $curview
    if {$mainhead ne {}} {
        movehead $newhead $mainhead
        movedhead $newhead $mainhead
    }
    set mainheadid $newhead
    redrawtags $oldhead
    redrawtags $newhead
    selbyid $newhead
}
notbusy cherrypick</pre>

<p>}</p>

<p>proc revert {} {</p>

<pre>global rowmenuid curview
global mainhead mainheadid
global gitdir

set oldhead [exec git rev-parse HEAD]
set dheads [descheads $rowmenuid]
if { $dheads eq {} || [lsearch -exact $dheads $oldhead] == -1 } {
   set ok [confirm_popup [mc &quot;Commit %s is not\
       included in branch %s -- really revert it?&quot; \
                  [string range $rowmenuid 0 7] $mainhead]]
   if {!$ok} return
}
nowbusy revert [mc &quot;Reverting&quot;]
update

if [catch {exec git revert --no-edit $rowmenuid} err] {
    notbusy revert
    if [regexp {files would be overwritten by merge:(\n(( |\t)+[^\n]+\n)+)}\
            $err match files] {
        regsub {\n( |\t)+} $files &quot;\n&quot; files
        error_popup [mc &quot;Revert failed because of local changes to\
            the following files:%s Please commit, reset or stash \
            your changes and try again.&quot; $files]
    } elseif [regexp {error: could not revert} $err] {
        if [confirm_popup [mc &quot;Revert failed because of merge conflict.\n\
            Do you wish to run git citool to resolve it?&quot;]] {
            # Force citool to read MERGE_MSG
            file delete [file join $gitdir &quot;GITGUI_MSG&quot;]
            exec_citool {} $rowmenuid
        }
    } else { error_popup $err }
    run updatecommits
    return
}

set newhead [exec git rev-parse HEAD]
if { $newhead eq $oldhead } {
    notbusy revert
    error_popup [mc &quot;No changes committed&quot;]
    return
}

addnewchild $newhead $oldhead

if [commitinview $oldhead $curview] {
    # XXX this isn&#39;t right if we have a path limit...
    insertrow $newhead $oldhead $curview
    if {$mainhead ne {}} {
        movehead $newhead $mainhead
        movedhead $newhead $mainhead
    }
    set mainheadid $newhead
    redrawtags $oldhead
    redrawtags $newhead
    selbyid $newhead
}

notbusy revert</pre>

<p>}</p>

<p>proc resethead {} {</p>

<pre>global mainhead rowmenuid confirm_ok resettype NS

set confirm_ok 0
set w &quot;.confirmreset&quot;
ttk_toplevel $w
make_transient $w .
wm title $w [mc &quot;Confirm reset&quot;]
${NS}::label $w.m -text \
    [mc &quot;Reset branch %s to %s?&quot; $mainhead [string range $rowmenuid 0 7]]
pack $w.m -side top -fill x -padx 20 -pady 20
${NS}::labelframe $w.f -text [mc &quot;Reset type:&quot;]
set resettype mixed
${NS}::radiobutton $w.f.soft -value soft -variable resettype \
    -text [mc &quot;Soft: Leave working tree and index untouched&quot;]
grid $w.f.soft -sticky w
${NS}::radiobutton $w.f.mixed -value mixed -variable resettype \
    -text [mc &quot;Mixed: Leave working tree untouched, reset index&quot;]
grid $w.f.mixed -sticky w
${NS}::radiobutton $w.f.hard -value hard -variable resettype \
    -text [mc &quot;Hard: Reset working tree and index\n(discard ALL local changes)&quot;]
grid $w.f.hard -sticky w
pack $w.f -side top -fill x -padx 4
${NS}::button $w.ok -text [mc OK] -command &quot;set confirm_ok 1; destroy $w&quot;
pack $w.ok -side left -fill x -padx 20 -pady 20
${NS}::button $w.cancel -text [mc Cancel] -command &quot;destroy $w&quot;
bind $w &lt;Key-Escape&gt; [list destroy $w]
pack $w.cancel -side right -fill x -padx 20 -pady 20
bind $w &lt;Visibility&gt; &quot;grab $w; focus $w&quot;
tkwait window $w
if {!$confirm_ok} return
if {[catch {set fd [open \
        [list | git reset --$resettype $rowmenuid 2&gt;@1] r]} err]} {
    error_popup $err
} else {
    dohidelocalchanges
    filerun $fd [list readresetstat $fd]
    nowbusy reset [mc &quot;Resetting&quot;]
    selbyid $rowmenuid
}</pre>

<p>}</p>

<p>proc readresetstat {fd} {</p>

<pre>global mainhead mainheadid showlocalchanges rprogcoord

if {[gets $fd line] &gt;= 0} {
    if {[regexp {([0-9]+)% \(([0-9]+)/([0-9]+)\)} $line match p m n]} {
        set rprogcoord [expr {1.0 * $m / $n}]
        adjustprogress
    }
    return 1
}
set rprogcoord 0
adjustprogress
notbusy reset
if {[catch {close $fd} err]} {
    error_popup $err
}
set oldhead $mainheadid
set newhead [exec git rev-parse HEAD]
if {$newhead ne $oldhead} {
    movehead $newhead $mainhead
    movedhead $newhead $mainhead
    set mainheadid $newhead
    redrawtags $oldhead
    redrawtags $newhead
}
if {$showlocalchanges} {
    doshowlocalchanges
}
return 0</pre>

<p>}</p>

<p># context menu for a head proc headmenu {x y id head} {</p>

<pre>global headmenuid headmenuhead headctxmenu mainhead

stopfinding
set headmenuid $id
set headmenuhead $head
set state normal
if {[string match &quot;remotes/*&quot; $head]} {
    set state disabled
}
if {$head eq $mainhead} {
    set state disabled
}
$headctxmenu entryconfigure 0 -state $state
$headctxmenu entryconfigure 1 -state $state
tk_popup $headctxmenu $x $y</pre>

<p>}</p>

<p>proc cobranch {} {</p>

<pre>global headmenuid headmenuhead headids
global showlocalchanges

# check the tree is clean first??
nowbusy checkout [mc &quot;Checking out&quot;]
update
dohidelocalchanges
if {[catch {
    set fd [open [list | git checkout $headmenuhead 2&gt;@1] r]
} err]} {
    notbusy checkout
    error_popup $err
    if {$showlocalchanges} {
        dodiffindex
    }
} else {
    filerun $fd [list readcheckoutstat $fd $headmenuhead $headmenuid]
}</pre>

<p>}</p>

<p>proc readcheckoutstat {fd newhead newheadid} {</p>

<pre>global mainhead mainheadid headids showlocalchanges progresscoords
global viewmainheadid curview

if {[gets $fd line] &gt;= 0} {
    if {[regexp {([0-9]+)% \(([0-9]+)/([0-9]+)\)} $line match p m n]} {
        set progresscoords [list 0 [expr {1.0 * $m / $n}]]
        adjustprogress
    }
    return 1
}
set progresscoords {0 0}
adjustprogress
notbusy checkout
if {[catch {close $fd} err]} {
    error_popup $err
}
set oldmainid $mainheadid
set mainhead $newhead
set mainheadid $newheadid
set viewmainheadid($curview) $newheadid
redrawtags $oldmainid
redrawtags $newheadid
selbyid $newheadid
if {$showlocalchanges} {
    dodiffindex
}</pre>

<p>}</p>

<p>proc rmbranch {} {</p>

<pre>global headmenuid headmenuhead mainhead
global idheads

set head $headmenuhead
set id $headmenuid
# this check shouldn&#39;t be needed any more...
if {$head eq $mainhead} {
    error_popup [mc &quot;Cannot delete the currently checked-out branch&quot;]
    return
}
set dheads [descheads $id]
if {[llength $dheads] == 1 &amp;&amp; $idheads($dheads) eq $head} {
    # the stuff on this branch isn&#39;t on any other branch
    if {![confirm_popup [mc &quot;The commits on branch %s aren&#39;t on any other\
                    branch.\nReally delete branch %s?&quot; $head $head]]} return
}
nowbusy rmbranch
update
if {[catch {exec git branch -D $head} err]} {
    notbusy rmbranch
    error_popup $err
    return
}
removehead $id $head
removedhead $id $head
redrawtags $id
notbusy rmbranch
dispneartags 0
run refill_reflist</pre>

<p>}</p>

<p># Display a list of tags and heads proc showrefs {} {</p>

<pre>global showrefstop bgcolor fgcolor selectbgcolor NS
global bglist fglist reflistfilter reflist maincursor

set top .showrefs
set showrefstop $top
if {[winfo exists $top]} {
    raise $top
    refill_reflist
    return
}
ttk_toplevel $top
wm title $top [mc &quot;Tags and heads: %s&quot; [file tail [pwd]]]
make_transient $top .
text $top.list -background $bgcolor -foreground $fgcolor \
    -selectbackground $selectbgcolor -font mainfont \
    -xscrollcommand &quot;$top.xsb set&quot; -yscrollcommand &quot;$top.ysb set&quot; \
    -width 30 -height 20 -cursor $maincursor \
    -spacing1 1 -spacing3 1 -state disabled
$top.list tag configure highlight -background $selectbgcolor
lappend bglist $top.list
lappend fglist $top.list
${NS}::scrollbar $top.ysb -command &quot;$top.list yview&quot; -orient vertical
${NS}::scrollbar $top.xsb -command &quot;$top.list xview&quot; -orient horizontal
grid $top.list $top.ysb -sticky nsew
grid $top.xsb x -sticky ew
${NS}::frame $top.f
${NS}::label $top.f.l -text &quot;[mc &quot;Filter&quot;]: &quot;
${NS}::entry $top.f.e -width 20 -textvariable reflistfilter
set reflistfilter &quot;*&quot;
trace add variable reflistfilter write reflistfilter_change
pack $top.f.e -side right -fill x -expand 1
pack $top.f.l -side left
grid $top.f - -sticky ew -pady 2
${NS}::button $top.close -command [list destroy $top] -text [mc &quot;Close&quot;]
bind $top &lt;Key-Escape&gt; [list destroy $top]
grid $top.close -
grid columnconfigure $top 0 -weight 1
grid rowconfigure $top 0 -weight 1
bind $top.list &lt;1&gt; {break}
bind $top.list &lt;B1-Motion&gt; {break}
bind $top.list &lt;ButtonRelease-1&gt; {sel_reflist %W %x %y; break}
set reflist {}
refill_reflist</pre>

<p>}</p>

<p>proc sel_reflist {w x y} {</p>

<pre>global showrefstop reflist headids tagids otherrefids

if {![winfo exists $showrefstop]} return
set l [lindex [split [$w index &quot;@$x,$y&quot;] &quot;.&quot;] 0]
set ref [lindex $reflist [expr {$l-1}]]
set n [lindex $ref 0]
switch -- [lindex $ref 1] {
    &quot;H&quot; {selbyid $headids($n)}
    &quot;T&quot; {selbyid $tagids($n)}
    &quot;o&quot; {selbyid $otherrefids($n)}
}
$showrefstop.list tag add highlight $l.0 &quot;$l.0 lineend&quot;</pre>

<p>}</p>

<p>proc unsel_reflist {} {</p>

<pre>global showrefstop

if {![info exists showrefstop] || ![winfo exists $showrefstop]} return
$showrefstop.list tag remove highlight 0.0 end</pre>

<p>}</p>

<p>proc reflistfilter_change {n1 n2 op} {</p>

<pre>global reflistfilter

after cancel refill_reflist
after 200 refill_reflist</pre>

<p>}</p>

<p>proc refill_reflist {} {</p>

<pre>global reflist reflistfilter showrefstop headids tagids otherrefids
global curview

if {![info exists showrefstop] || ![winfo exists $showrefstop]} return
set refs {}
foreach n [array names headids] {
    if {[string match $reflistfilter $n]} {
        if {[commitinview $headids($n) $curview]} {
            lappend refs [list $n H]
        } else {
            interestedin $headids($n) {run refill_reflist}
        }
    }
}
foreach n [array names tagids] {
    if {[string match $reflistfilter $n]} {
        if {[commitinview $tagids($n) $curview]} {
            lappend refs [list $n T]
        } else {
            interestedin $tagids($n) {run refill_reflist}
        }
    }
}
foreach n [array names otherrefids] {
    if {[string match $reflistfilter $n]} {
        if {[commitinview $otherrefids($n) $curview]} {
            lappend refs [list $n o]
        } else {
            interestedin $otherrefids($n) {run refill_reflist}
        }
    }
}
set refs [lsort -index 0 $refs]
if {$refs eq $reflist} return

# Update the contents of $showrefstop.list according to the
# differences between $reflist (old) and $refs (new)
$showrefstop.list conf -state normal
$showrefstop.list insert end &quot;\n&quot;
set i 0
set j 0
while {$i &lt; [llength $reflist] || $j &lt; [llength $refs]} {
    if {$i &lt; [llength $reflist]} {
        if {$j &lt; [llength $refs]} {
            set cmp [string compare [lindex $reflist $i 0] \
                         [lindex $refs $j 0]]
            if {$cmp == 0} {
                set cmp [string compare [lindex $reflist $i 1] \
                             [lindex $refs $j 1]]
            }
        } else {
            set cmp -1
        }
    } else {
        set cmp 1
    }
    switch -- $cmp {
        -1 {
            $showrefstop.list delete &quot;[expr {$j+1}].0&quot; &quot;[expr {$j+2}].0&quot;
            incr i
        }
        0 {
            incr i
            incr j
        }
        1 {
            set l [expr {$j + 1}]
            $showrefstop.list image create $l.0 -align baseline \
                -image reficon-[lindex $refs $j 1] -padx 2
            $showrefstop.list insert $l.1 &quot;[lindex $refs $j 0]\n&quot;
            incr j
        }
    }
}
set reflist $refs
# delete last newline
$showrefstop.list delete end-2c end-1c
$showrefstop.list conf -state disabled</pre>

<p>}</p>

<p># Stuff for finding nearby tags proc getallcommits {} {</p>

<pre>global allcommits nextarc seeds allccache allcwait cachedarcs allcupdate
global idheads idtags idotherrefs allparents tagobjid
global gitdir

if {![info exists allcommits]} {
    set nextarc 0
    set allcommits 0
    set seeds {}
    set allcwait 0
    set cachedarcs 0
    set allccache [file join $gitdir &quot;gitk.cache&quot;]
    if {![catch {
        set f [open $allccache r]
        set allcwait 1
        getcache $f
    }]} return
}

if {$allcwait} {
    return
}
set cmd [list | git rev-list --parents]
set allcupdate [expr {$seeds ne {}}]
if {!$allcupdate} {
    set ids &quot;--all&quot;
} else {
    set refs [concat [array names idheads] [array names idtags] \
                  [array names idotherrefs]]
    set ids {}
    set tagobjs {}
    foreach name [array names tagobjid] {
        lappend tagobjs $tagobjid($name)
    }
    foreach id [lsort -unique $refs] {
        if {![info exists allparents($id)] &amp;&amp;
            [lsearch -exact $tagobjs $id] &lt; 0} {
            lappend ids $id
        }
    }
    if {$ids ne {}} {
        foreach id $seeds {
            lappend ids &quot;^$id&quot;
        }
    }
}
if {$ids ne {}} {
    set fd [open [concat $cmd $ids] r]
    fconfigure $fd -blocking 0
    incr allcommits
    nowbusy allcommits
    filerun $fd [list getallclines $fd]
} else {
    dispneartags 0
}</pre>

<p>}</p>

<p># Since most commits have 1 parent and 1 child, we group strings of # such
commits into “arcs” joining branch/merge points (BMPs), which # are commits
that either don&#39;t have 1 parent or don&#39;t have 1 child. # #
arcnos(id) - incoming arcs for BMP, arc we&#39;re on for other nodes #
arcout(id) - outgoing arcs for BMP # arcids(a) - list of IDs on arc
including end but not start # arcstart(a) - BMP ID at start of arc #
arcend(a) - BMP ID at end of arc # growing(a) - arc a is still growing #
arctags(a) - IDs out of arcids (excluding end) that have tags # archeads(a)
- IDs out of arcids (excluding end) that have heads # The start of an arc
is at the descendent end, so “incoming” means # coming from descendents,
and “outgoing” means going towards ancestors.</p>

<p>proc getallclines {fd} {</p>

<pre>global allparents allchildren idtags idheads nextarc
global arcnos arcids arctags arcout arcend arcstart archeads growing
global seeds allcommits cachedarcs allcupdate

set nid 0
while {[incr nid] &lt;= 1000 &amp;&amp; [gets $fd line] &gt;= 0} {
    set id [lindex $line 0]
    if {[info exists allparents($id)]} {
        # seen it already
        continue
    }
    set cachedarcs 0
    set olds [lrange $line 1 end]
    set allparents($id) $olds
    if {![info exists allchildren($id)]} {
        set allchildren($id) {}
        set arcnos($id) {}
        lappend seeds $id
    } else {
        set a $arcnos($id)
        if {[llength $olds] == 1 &amp;&amp; [llength $a] == 1} {
            lappend arcids($a) $id
            if {[info exists idtags($id)]} {
                lappend arctags($a) $id
            }
            if {[info exists idheads($id)]} {
                lappend archeads($a) $id
            }
            if {[info exists allparents($olds)]} {
                # seen parent already
                if {![info exists arcout($olds)]} {
                    splitarc $olds
                }
                lappend arcids($a) $olds
                set arcend($a) $olds
                unset growing($a)
            }
            lappend allchildren($olds) $id
            lappend arcnos($olds) $a
            continue
        }
    }
    foreach a $arcnos($id) {
        lappend arcids($a) $id
        set arcend($a) $id
        unset growing($a)
    }

    set ao {}
    foreach p $olds {
        lappend allchildren($p) $id
        set a [incr nextarc]
        set arcstart($a) $id
        set archeads($a) {}
        set arctags($a) {}
        set archeads($a) {}
        set arcids($a) {}
        lappend ao $a
        set growing($a) 1
        if {[info exists allparents($p)]} {
            # seen it already, may need to make a new branch
            if {![info exists arcout($p)]} {
                splitarc $p
            }
            lappend arcids($a) $p
            set arcend($a) $p
            unset growing($a)
        }
        lappend arcnos($p) $a
    }
    set arcout($id) $ao
}
if {$nid &gt; 0} {
    global cached_dheads cached_dtags cached_atags
    catch {unset cached_dheads}
    catch {unset cached_dtags}
    catch {unset cached_atags}
}
if {![eof $fd]} {
    return [expr {$nid &gt;= 1000? 2: 1}]
}
set cacheok 1
if {[catch {
    fconfigure $fd -blocking 1
    close $fd
} err]} {
    # got an error reading the list of commits
    # if we were updating, try rereading the whole thing again
    if {$allcupdate} {
        incr allcommits -1
        dropcache $err
        return
    }
    error_popup &quot;[mc &quot;Error reading commit topology information;\
            branch and preceding/following tag information\
            will be incomplete.&quot;]\n($err)&quot;
    set cacheok 0
}
if {[incr allcommits -1] == 0} {
    notbusy allcommits
    if {$cacheok} {
        run savecache
    }
}
dispneartags 0
return 0</pre>

<p>}</p>

<p>proc recalcarc {a} {</p>

<pre>global arctags archeads arcids idtags idheads

set at {}
set ah {}
foreach id [lrange $arcids($a) 0 end-1] {
    if {[info exists idtags($id)]} {
        lappend at $id
    }
    if {[info exists idheads($id)]} {
        lappend ah $id
    }
}
set arctags($a) $at
set archeads($a) $ah</pre>

<p>}</p>

<p>proc splitarc {p} {</p>

<pre>global arcnos arcids nextarc arctags archeads idtags idheads
global arcstart arcend arcout allparents growing

set a $arcnos($p)
if {[llength $a] != 1} {
    puts &quot;oops splitarc called but [llength $a] arcs already&quot;
    return
}
set a [lindex $a 0]
set i [lsearch -exact $arcids($a) $p]
if {$i &lt; 0} {
    puts &quot;oops splitarc $p not in arc $a&quot;
    return
}
set na [incr nextarc]
if {[info exists arcend($a)]} {
    set arcend($na) $arcend($a)
} else {
    set l [lindex $allparents([lindex $arcids($a) end]) 0]
    set j [lsearch -exact $arcnos($l) $a]
    set arcnos($l) [lreplace $arcnos($l) $j $j $na]
}
set tail [lrange $arcids($a) [expr {$i+1}] end]
set arcids($a) [lrange $arcids($a) 0 $i]
set arcend($a) $p
set arcstart($na) $p
set arcout($p) $na
set arcids($na) $tail
if {[info exists growing($a)]} {
    set growing($na) 1
    unset growing($a)
}

foreach id $tail {
    if {[llength $arcnos($id)] == 1} {
        set arcnos($id) $na
    } else {
        set j [lsearch -exact $arcnos($id) $a]
        set arcnos($id) [lreplace $arcnos($id) $j $j $na]
    }
}

# reconstruct tags and heads lists
if {$arctags($a) ne {} || $archeads($a) ne {}} {
    recalcarc $a
    recalcarc $na
} else {
    set arctags($na) {}
    set archeads($na) {}
}</pre>

<p>}</p>

<p># Update things for a new commit added that is a child of one # existing
commit.  Used when cherry-picking. proc addnewchild {id p} {</p>

<pre>global allparents allchildren idtags nextarc
global arcnos arcids arctags arcout arcend arcstart archeads growing
global seeds allcommits

if {![info exists allcommits] || ![info exists arcnos($p)]} return
set allparents($id) [list $p]
set allchildren($id) {}
set arcnos($id) {}
lappend seeds $id
lappend allchildren($p) $id
set a [incr nextarc]
set arcstart($a) $id
set archeads($a) {}
set arctags($a) {}
set arcids($a) [list $p]
set arcend($a) $p
if {![info exists arcout($p)]} {
    splitarc $p
}
lappend arcnos($p) $a
set arcout($id) [list $a]</pre>

<p>}</p>

<p># This implements a cache for the topology information. # The cache saves,
for each arc, the start and end of the arc, # the ids on the arc, and the
outgoing arcs from the end. proc readcache {f} {</p>

<pre>global arcnos arcids arcout arcstart arcend arctags archeads nextarc
global idtags idheads allparents cachedarcs possible_seeds seeds growing
global allcwait

set a $nextarc
set lim $cachedarcs
if {$lim - $a &gt; 500} {
    set lim [expr {$a + 500}]
}
if {[catch {
    if {$a == $lim} {
        # finish reading the cache and setting up arctags, etc.
        set line [gets $f]
        if {$line ne &quot;1&quot;} {error &quot;bad final version&quot;}
        close $f
        foreach id [array names idtags] {
            if {[info exists arcnos($id)] &amp;&amp; [llength $arcnos($id)] == 1 &amp;&amp;
                [llength $allparents($id)] == 1} {
                set a [lindex $arcnos($id) 0]
                if {$arctags($a) eq {}} {
                    recalcarc $a
                }
            }
        }
        foreach id [array names idheads] {
            if {[info exists arcnos($id)] &amp;&amp; [llength $arcnos($id)] == 1 &amp;&amp;
                [llength $allparents($id)] == 1} {
                set a [lindex $arcnos($id) 0]
                if {$archeads($a) eq {}} {
                    recalcarc $a
                }
            }
        }
        foreach id [lsort -unique $possible_seeds] {
            if {$arcnos($id) eq {}} {
                lappend seeds $id
            }
        }
        set allcwait 0
    } else {
        while {[incr a] &lt;= $lim} {
            set line [gets $f]
            if {[llength $line] != 3} {error &quot;bad line&quot;}
            set s [lindex $line 0]
            set arcstart($a) $s
            lappend arcout($s) $a
            if {![info exists arcnos($s)]} {
                lappend possible_seeds $s
                set arcnos($s) {}
            }
            set e [lindex $line 1]
            if {$e eq {}} {
                set growing($a) 1
            } else {
                set arcend($a) $e
                if {![info exists arcout($e)]} {
                    set arcout($e) {}
                }
            }
            set arcids($a) [lindex $line 2]
            foreach id $arcids($a) {
                lappend allparents($s) $id
                set s $id
                lappend arcnos($id) $a
            }
            if {![info exists allparents($s)]} {
                set allparents($s) {}
            }
            set arctags($a) {}
            set archeads($a) {}
        }
        set nextarc [expr {$a - 1}]
    }
} err]} {
    dropcache $err
    return 0
}
if {!$allcwait} {
    getallcommits
}
return $allcwait</pre>

<p>}</p>

<p>proc getcache {f} {</p>

<pre>global nextarc cachedarcs possible_seeds

if {[catch {
    set line [gets $f]
    if {[llength $line] != 2 || [lindex $line 0] ne &quot;1&quot;} {error &quot;bad version&quot;}
    # make sure it&#39;s an integer
    set cachedarcs [expr {int([lindex $line 1])}]
    if {$cachedarcs &lt; 0} {error &quot;bad number of arcs&quot;}
    set nextarc 0
    set possible_seeds {}
    run readcache $f
} err]} {
    dropcache $err
}
return 0</pre>

<p>}</p>

<p>proc dropcache {err} {</p>

<pre>global allcwait nextarc cachedarcs seeds

#puts &quot;dropping cache ($err)&quot;
foreach v {arcnos arcout arcids arcstart arcend growing \
               arctags archeads allparents allchildren} {
    global $v
    catch {unset $v}
}
set allcwait 0
set nextarc 0
set cachedarcs 0
set seeds {}
getallcommits</pre>

<p>}</p>

<p>proc writecache {f} {</p>

<pre>global cachearc cachedarcs allccache
global arcstart arcend arcnos arcids arcout

set a $cachearc
set lim $cachedarcs
if {$lim - $a &gt; 1000} {
    set lim [expr {$a + 1000}]
}
if {[catch {
    while {[incr a] &lt;= $lim} {
        if {[info exists arcend($a)]} {
            puts $f [list $arcstart($a) $arcend($a) $arcids($a)]
        } else {
            puts $f [list $arcstart($a) {} $arcids($a)]
        }
    }
} err]} {
    catch {close $f}
    catch {file delete $allccache}
    #puts &quot;writing cache failed ($err)&quot;
    return 0
}
set cachearc [expr {$a - 1}]
if {$a &gt; $cachedarcs} {
    puts $f &quot;1&quot;
    close $f
    return 0
}
return 1</pre>

<p>}</p>

<p>proc savecache {} {</p>

<pre>global nextarc cachedarcs cachearc allccache

if {$nextarc == $cachedarcs} return
set cachearc 0
set cachedarcs $nextarc
catch {
    set f [open $allccache w]
    puts $f [list 1 $cachedarcs]
    run writecache $f
}</pre>

<p>}</p>

<p># Returns 1 if a is an ancestor of b, -1 if b is an ancestor of a, # or 0
if neither is true. proc anc_or_desc {a b} {</p>

<pre>global arcout arcstart arcend arcnos cached_isanc

if {$arcnos($a) eq $arcnos($b)} {
    # Both are on the same arc(s); either both are the same BMP,
    # or if one is not a BMP, the other is also not a BMP or is
    # the BMP at end of the arc (and it only has 1 incoming arc).
    # Or both can be BMPs with no incoming arcs.
    if {$a eq $b || $arcnos($a) eq {}} {
        return 0
    }
    # assert {[llength $arcnos($a)] == 1}
    set arc [lindex $arcnos($a) 0]
    set i [lsearch -exact $arcids($arc) $a]
    set j [lsearch -exact $arcids($arc) $b]
    if {$i &lt; 0 || $i &gt; $j} {
        return 1
    } else {
        return -1
    }
}

if {![info exists arcout($a)]} {
    set arc [lindex $arcnos($a) 0]
    if {[info exists arcend($arc)]} {
        set aend $arcend($arc)
    } else {
        set aend {}
    }
    set a $arcstart($arc)
} else {
    set aend $a
}
if {![info exists arcout($b)]} {
    set arc [lindex $arcnos($b) 0]
    if {[info exists arcend($arc)]} {
        set bend $arcend($arc)
    } else {
        set bend {}
    }
    set b $arcstart($arc)
} else {
    set bend $b
}
if {$a eq $bend} {
    return 1
}
if {$b eq $aend} {
    return -1
}
if {[info exists cached_isanc($a,$bend)]} {
    if {$cached_isanc($a,$bend)} {
        return 1
    }
}
if {[info exists cached_isanc($b,$aend)]} {
    if {$cached_isanc($b,$aend)} {
        return -1
    }
    if {[info exists cached_isanc($a,$bend)]} {
        return 0
    }
}

set todo [list $a $b]
set anc($a) a
set anc($b) b
for {set i 0} {$i &lt; [llength $todo]} {incr i} {
    set x [lindex $todo $i]
    if {$anc($x) eq {}} {
        continue
    }
    foreach arc $arcnos($x) {
        set xd $arcstart($arc)
        if {$xd eq $bend} {
            set cached_isanc($a,$bend) 1
            set cached_isanc($b,$aend) 0
            return 1
        } elseif {$xd eq $aend} {
            set cached_isanc($b,$aend) 1
            set cached_isanc($a,$bend) 0
            return -1
        }
        if {![info exists anc($xd)]} {
            set anc($xd) $anc($x)
            lappend todo $xd
        } elseif {$anc($xd) ne $anc($x)} {
            set anc($xd) {}
        }
    }
}
set cached_isanc($a,$bend) 0
set cached_isanc($b,$aend) 0
return 0</pre>

<p>}</p>

<p># This identifies whether $desc has an ancestor that is # a growing tip of
the graph and which is not an ancestor of $anc # and returns 0 if so and 1
if not. # If we subsequently discover a tag on such a growing tip, and that
# turns out to be a descendent of $anc (which it could, since we #
don&#39;t necessarily see children before parents), then $desc # isn&#39;t
a good choice to display as a descendent tag of # $anc (since it is the
descendent of another tag which is # a descendent of $anc).  Similarly,
$anc isn&#39;t a good choice to # display as a ancestor tag of $desc. #
proc is_certain {desc anc} {</p>

<pre>global arcnos arcout arcstart arcend growing problems

set certain {}
if {[llength $arcnos($anc)] == 1} {
    # tags on the same arc are certain
    if {$arcnos($desc) eq $arcnos($anc)} {
        return 1
    }
    if {![info exists arcout($anc)]} {
        # if $anc is partway along an arc, use the start of the arc instead
        set a [lindex $arcnos($anc) 0]
        set anc $arcstart($a)
    }
}
if {[llength $arcnos($desc)] &gt; 1 || [info exists arcout($desc)]} {
    set x $desc
} else {
    set a [lindex $arcnos($desc) 0]
    set x $arcend($a)
}
if {$x == $anc} {
    return 1
}
set anclist [list $x]
set dl($x) 1
set nnh 1
set ngrowanc 0
for {set i 0} {$i &lt; [llength $anclist] &amp;&amp; ($nnh &gt; 0 || $ngrowanc &gt; 0)} {incr i} {
    set x [lindex $anclist $i]
    if {$dl($x)} {
        incr nnh -1
    }
    set done($x) 1
    foreach a $arcout($x) {
        if {[info exists growing($a)]} {
            if {![info exists growanc($x)] &amp;&amp; $dl($x)} {
                set growanc($x) 1
                incr ngrowanc
            }
        } else {
            set y $arcend($a)
            if {[info exists dl($y)]} {
                if {$dl($y)} {
                    if {!$dl($x)} {
                        set dl($y) 0
                        if {![info exists done($y)]} {
                            incr nnh -1
                        }
                        if {[info exists growanc($x)]} {
                            incr ngrowanc -1
                        }
                        set xl [list $y]
                        for {set k 0} {$k &lt; [llength $xl]} {incr k} {
                            set z [lindex $xl $k]
                            foreach c $arcout($z) {
                                if {[info exists arcend($c)]} {
                                    set v $arcend($c)
                                    if {[info exists dl($v)] &amp;&amp; $dl($v)} {
                                        set dl($v) 0
                                        if {![info exists done($v)]} {
                                            incr nnh -1
                                        }
                                        if {[info exists growanc($v)]} {
                                            incr ngrowanc -1
                                        }
                                        lappend xl $v
                                    }
                                }
                            }
                        }
                    }
                }
            } elseif {$y eq $anc || !$dl($x)} {
                set dl($y) 0
                lappend anclist $y
            } else {
                set dl($y) 1
                lappend anclist $y
                incr nnh
            }
        }
    }
}
foreach x [array names growanc] {
    if {$dl($x)} {
        return 0
    }
    return 0
}
return 1</pre>

<p>}</p>

<p>proc validate_arctags {a} {</p>

<pre>global arctags idtags

set i -1
set na $arctags($a)
foreach id $arctags($a) {
    incr i
    if {![info exists idtags($id)]} {
        set na [lreplace $na $i $i]
        incr i -1
    }
}
set arctags($a) $na</pre>

<p>}</p>

<p>proc validate_archeads {a} {</p>

<pre>global archeads idheads

set i -1
set na $archeads($a)
foreach id $archeads($a) {
    incr i
    if {![info exists idheads($id)]} {
        set na [lreplace $na $i $i]
        incr i -1
    }
}
set archeads($a) $na</pre>

<p>}</p>

<p># Return the list of IDs that have tags that are descendents of id, #
ignoring IDs that are descendents of IDs already reported. proc desctags
{id} {</p>

<pre>global arcnos arcstart arcids arctags idtags allparents
global growing cached_dtags

if {![info exists allparents($id)]} {
    return {}
}
set t1 [clock clicks -milliseconds]
set argid $id
if {[llength $arcnos($id)] == 1 &amp;&amp; [llength $allparents($id)] == 1} {
    # part-way along an arc; check that arc first
    set a [lindex $arcnos($id) 0]
    if {$arctags($a) ne {}} {
        validate_arctags $a
        set i [lsearch -exact $arcids($a) $id]
        set tid {}
        foreach t $arctags($a) {
            set j [lsearch -exact $arcids($a) $t]
            if {$j &gt;= $i} break
            set tid $t
        }
        if {$tid ne {}} {
            return $tid
        }
    }
    set id $arcstart($a)
    if {[info exists idtags($id)]} {
        return $id
    }
}
if {[info exists cached_dtags($id)]} {
    return $cached_dtags($id)
}

set origid $id
set todo [list $id]
set queued($id) 1
set nc 1
for {set i 0} {$i &lt; [llength $todo] &amp;&amp; $nc &gt; 0} {incr i} {
    set id [lindex $todo $i]
    set done($id) 1
    set ta [info exists hastaggedancestor($id)]
    if {!$ta} {
        incr nc -1
    }
    # ignore tags on starting node
    if {!$ta &amp;&amp; $i &gt; 0} {
        if {[info exists idtags($id)]} {
            set tagloc($id) $id
            set ta 1
        } elseif {[info exists cached_dtags($id)]} {
            set tagloc($id) $cached_dtags($id)
            set ta 1
        }
    }
    foreach a $arcnos($id) {
        set d $arcstart($a)
        if {!$ta &amp;&amp; $arctags($a) ne {}} {
            validate_arctags $a
            if {$arctags($a) ne {}} {
                lappend tagloc($id) [lindex $arctags($a) end]
            }
        }
        if {$ta || $arctags($a) ne {}} {
            set tomark [list $d]
            for {set j 0} {$j &lt; [llength $tomark]} {incr j} {
                set dd [lindex $tomark $j]
                if {![info exists hastaggedancestor($dd)]} {
                    if {[info exists done($dd)]} {
                        foreach b $arcnos($dd) {
                            lappend tomark $arcstart($b)
                        }
                        if {[info exists tagloc($dd)]} {
                            unset tagloc($dd)
                        }
                    } elseif {[info exists queued($dd)]} {
                        incr nc -1
                    }
                    set hastaggedancestor($dd) 1
                }
            }
        }
        if {![info exists queued($d)]} {
            lappend todo $d
            set queued($d) 1
            if {![info exists hastaggedancestor($d)]} {
                incr nc
            }
        }
    }
}
set tags {}
foreach id [array names tagloc] {
    if {![info exists hastaggedancestor($id)]} {
        foreach t $tagloc($id) {
            if {[lsearch -exact $tags $t] &lt; 0} {
                lappend tags $t
            }
        }
    }
}
set t2 [clock clicks -milliseconds]
set loopix $i

# remove tags that are descendents of other tags
for {set i 0} {$i &lt; [llength $tags]} {incr i} {
    set a [lindex $tags $i]
    for {set j 0} {$j &lt; $i} {incr j} {
        set b [lindex $tags $j]
        set r [anc_or_desc $a $b]
        if {$r == 1} {
            set tags [lreplace $tags $j $j]
            incr j -1
            incr i -1
        } elseif {$r == -1} {
            set tags [lreplace $tags $i $i]
            incr i -1
            break
        }
    }
}

if {[array names growing] ne {}} {
    # graph isn&#39;t finished, need to check if any tag could get
    # eclipsed by another tag coming later.  Simply ignore any
    # tags that could later get eclipsed.
    set ctags {}
    foreach t $tags {
        if {[is_certain $t $origid]} {
            lappend ctags $t
        }
    }
    if {$tags eq $ctags} {
        set cached_dtags($origid) $tags
    } else {
        set tags $ctags
    }
} else {
    set cached_dtags($origid) $tags
}
set t3 [clock clicks -milliseconds]
if {0 &amp;&amp; $t3 - $t1 &gt;= 100} {
    puts &quot;iterating descendents ($loopix/[llength $todo] nodes) took\
        [expr {$t2-$t1}]+[expr {$t3-$t2}]ms, $nc candidates left&quot;
}
return $tags</pre>

<p>}</p>

<p>proc anctags {id} {</p>

<pre>global arcnos arcids arcout arcend arctags idtags allparents
global growing cached_atags

if {![info exists allparents($id)]} {
    return {}
}
set t1 [clock clicks -milliseconds]
set argid $id
if {[llength $arcnos($id)] == 1 &amp;&amp; [llength $allparents($id)] == 1} {
    # part-way along an arc; check that arc first
    set a [lindex $arcnos($id) 0]
    if {$arctags($a) ne {}} {
        validate_arctags $a
        set i [lsearch -exact $arcids($a) $id]
        foreach t $arctags($a) {
            set j [lsearch -exact $arcids($a) $t]
            if {$j &gt; $i} {
                return $t
            }
        }
    }
    if {![info exists arcend($a)]} {
        return {}
    }
    set id $arcend($a)
    if {[info exists idtags($id)]} {
        return $id
    }
}
if {[info exists cached_atags($id)]} {
    return $cached_atags($id)
}

set origid $id
set todo [list $id]
set queued($id) 1
set taglist {}
set nc 1
for {set i 0} {$i &lt; [llength $todo] &amp;&amp; $nc &gt; 0} {incr i} {
    set id [lindex $todo $i]
    set done($id) 1
    set td [info exists hastaggeddescendent($id)]
    if {!$td} {
        incr nc -1
    }
    # ignore tags on starting node
    if {!$td &amp;&amp; $i &gt; 0} {
        if {[info exists idtags($id)]} {
            set tagloc($id) $id
            set td 1
        } elseif {[info exists cached_atags($id)]} {
            set tagloc($id) $cached_atags($id)
            set td 1
        }
    }
    foreach a $arcout($id) {
        if {!$td &amp;&amp; $arctags($a) ne {}} {
            validate_arctags $a
            if {$arctags($a) ne {}} {
                lappend tagloc($id) [lindex $arctags($a) 0]
            }
        }
        if {![info exists arcend($a)]} continue
        set d $arcend($a)
        if {$td || $arctags($a) ne {}} {
            set tomark [list $d]
            for {set j 0} {$j &lt; [llength $tomark]} {incr j} {
                set dd [lindex $tomark $j]
                if {![info exists hastaggeddescendent($dd)]} {
                    if {[info exists done($dd)]} {
                        foreach b $arcout($dd) {
                            if {[info exists arcend($b)]} {
                                lappend tomark $arcend($b)
                            }
                        }
                        if {[info exists tagloc($dd)]} {
                            unset tagloc($dd)
                        }
                    } elseif {[info exists queued($dd)]} {
                        incr nc -1
                    }
                    set hastaggeddescendent($dd) 1
                }
            }
        }
        if {![info exists queued($d)]} {
            lappend todo $d
            set queued($d) 1
            if {![info exists hastaggeddescendent($d)]} {
                incr nc
            }
        }
    }
}
set t2 [clock clicks -milliseconds]
set loopix $i
set tags {}
foreach id [array names tagloc] {
    if {![info exists hastaggeddescendent($id)]} {
        foreach t $tagloc($id) {
            if {[lsearch -exact $tags $t] &lt; 0} {
                lappend tags $t
            }
        }
    }
}

# remove tags that are ancestors of other tags
for {set i 0} {$i &lt; [llength $tags]} {incr i} {
    set a [lindex $tags $i]
    for {set j 0} {$j &lt; $i} {incr j} {
        set b [lindex $tags $j]
        set r [anc_or_desc $a $b]
        if {$r == -1} {
            set tags [lreplace $tags $j $j]
            incr j -1
            incr i -1
        } elseif {$r == 1} {
            set tags [lreplace $tags $i $i]
            incr i -1
            break
        }
    }
}

if {[array names growing] ne {}} {
    # graph isn&#39;t finished, need to check if any tag could get
    # eclipsed by another tag coming later.  Simply ignore any
    # tags that could later get eclipsed.
    set ctags {}
    foreach t $tags {
        if {[is_certain $origid $t]} {
            lappend ctags $t
        }
    }
    if {$tags eq $ctags} {
        set cached_atags($origid) $tags
    } else {
        set tags $ctags
    }
} else {
    set cached_atags($origid) $tags
}
set t3 [clock clicks -milliseconds]
if {0 &amp;&amp; $t3 - $t1 &gt;= 100} {
    puts &quot;iterating ancestors ($loopix/[llength $todo] nodes) took\
        [expr {$t2-$t1}]+[expr {$t3-$t2}]ms, $nc candidates left&quot;
}
return $tags</pre>

<p>}</p>

<p># Return the list of IDs that have heads that are descendents of id, #
including id itself if it has a head. proc descheads {id} {</p>

<pre>global arcnos arcstart arcids archeads idheads cached_dheads
global allparents arcout

if {![info exists allparents($id)]} {
    return {}
}
set aret {}
if {![info exists arcout($id)]} {
    # part-way along an arc; check it first
    set a [lindex $arcnos($id) 0]
    if {$archeads($a) ne {}} {
        validate_archeads $a
        set i [lsearch -exact $arcids($a) $id]
        foreach t $archeads($a) {
            set j [lsearch -exact $arcids($a) $t]
            if {$j &gt; $i} break
            lappend aret $t
        }
    }
    set id $arcstart($a)
}
set origid $id
set todo [list $id]
set seen($id) 1
set ret {}
for {set i 0} {$i &lt; [llength $todo]} {incr i} {
    set id [lindex $todo $i]
    if {[info exists cached_dheads($id)]} {
        set ret [concat $ret $cached_dheads($id)]
    } else {
        if {[info exists idheads($id)]} {
            lappend ret $id
        }
        foreach a $arcnos($id) {
            if {$archeads($a) ne {}} {
                validate_archeads $a
                if {$archeads($a) ne {}} {
                    set ret [concat $ret $archeads($a)]
                }
            }
            set d $arcstart($a)
            if {![info exists seen($d)]} {
                lappend todo $d
                set seen($d) 1
            }
        }
    }
}
set ret [lsort -unique $ret]
set cached_dheads($origid) $ret
return [concat $ret $aret]</pre>

<p>}</p>

<p>proc addedtag {id} {</p>

<pre>global arcnos arcout cached_dtags cached_atags

if {![info exists arcnos($id)]} return
if {![info exists arcout($id)]} {
    recalcarc [lindex $arcnos($id) 0]
}
catch {unset cached_dtags}
catch {unset cached_atags}</pre>

<p>}</p>

<p>proc addedhead {hid head} {</p>

<pre>global arcnos arcout cached_dheads

if {![info exists arcnos($hid)]} return
if {![info exists arcout($hid)]} {
    recalcarc [lindex $arcnos($hid) 0]
}
catch {unset cached_dheads}</pre>

<p>}</p>

<p>proc removedhead {hid head} {</p>

<pre>global cached_dheads

catch {unset cached_dheads}</pre>

<p>}</p>

<p>proc movedhead {hid head} {</p>

<pre>global arcnos arcout cached_dheads

if {![info exists arcnos($hid)]} return
if {![info exists arcout($hid)]} {
    recalcarc [lindex $arcnos($hid) 0]
}
catch {unset cached_dheads}</pre>

<p>}</p>

<p>proc changedrefs {} {</p>

<pre>global cached_dheads cached_dtags cached_atags cached_tagcontent
global arctags archeads arcnos arcout idheads idtags

foreach id [concat [array names idheads] [array names idtags]] {
    if {[info exists arcnos($id)] &amp;&amp; ![info exists arcout($id)]} {
        set a [lindex $arcnos($id) 0]
        if {![info exists donearc($a)]} {
            recalcarc $a
            set donearc($a) 1
        }
    }
}
catch {unset cached_tagcontent}
catch {unset cached_dtags}
catch {unset cached_atags}
catch {unset cached_dheads}</pre>

<p>}</p>

<p>proc rereadrefs {} {</p>

<pre>global idtags idheads idotherrefs mainheadid

set refids [concat [array names idtags] \
                [array names idheads] [array names idotherrefs]]
foreach id $refids {
    if {![info exists ref($id)]} {
        set ref($id) [listrefs $id]
    }
}
set oldmainhead $mainheadid
readrefs
changedrefs
set refids [lsort -unique [concat $refids [array names idtags] \
                    [array names idheads] [array names idotherrefs]]]
foreach id $refids {
    set v [listrefs $id]
    if {![info exists ref($id)] || $ref($id) != $v} {
        redrawtags $id
    }
}
if {$oldmainhead ne $mainheadid} {
    redrawtags $oldmainhead
    redrawtags $mainheadid
}
run refill_reflist</pre>

<p>}</p>

<p>proc listrefs {id} {</p>

<pre>global idtags idheads idotherrefs

set x {}
if {[info exists idtags($id)]} {
    set x $idtags($id)
}
set y {}
if {[info exists idheads($id)]} {
    set y $idheads($id)
}
set z {}
if {[info exists idotherrefs($id)]} {
    set z $idotherrefs($id)
}
return [list $x $y $z]</pre>

<p>}</p>

<p>proc showtag {tag isnew} {</p>

<pre>global ctext cached_tagcontent tagids linknum tagobjid

if {$isnew} {
    addtohistory [list showtag $tag 0] savectextpos
}
$ctext conf -state normal
clear_ctext
settabs 0
set linknum 0
if {![info exists cached_tagcontent($tag)]} {
    catch {
       set cached_tagcontent($tag) [exec git cat-file -p $tag]
    }
}
if {[info exists cached_tagcontent($tag)]} {
    set text $cached_tagcontent($tag)
} else {
    set text &quot;[mc &quot;Tag&quot;]: $tag\n[mc &quot;Id&quot;]:  $tagids($tag)&quot;
}
appendwithlinks $text {}
maybe_scroll_ctext 1
$ctext conf -state disabled
init_flist {}</pre>

<p>}</p>

<p>proc doquit {} {</p>

<pre>global stopped
global gitktmpdir

set stopped 100
savestuff .
destroy .

if {[info exists gitktmpdir]} {
    catch {file delete -force $gitktmpdir}
}</pre>

<p>}</p>

<p>proc mkfontdisp {font top which} {</p>

<pre>global fontattr fontpref $font NS use_ttk

set fontpref($font) [set $font]
${NS}::button $top.${font}but -text $which \
    -command [list choosefont $font $which]
${NS}::label $top.$font -relief flat -font $font \
    -text $fontattr($font,family) -justify left
grid x $top.${font}but $top.$font -sticky w</pre>

<p>}</p>

<p>proc choosefont {font which} {</p>

<pre>global fontparam fontlist fonttop fontattr
global prefstop NS

set fontparam(which) $which
set fontparam(font) $font
set fontparam(family) [font actual $font -family]
set fontparam(size) $fontattr($font,size)
set fontparam(weight) $fontattr($font,weight)
set fontparam(slant) $fontattr($font,slant)
set top .gitkfont
set fonttop $top
if {![winfo exists $top]} {
    font create sample
    eval font config sample [font actual $font]
    ttk_toplevel $top
    make_transient $top $prefstop
    wm title $top [mc &quot;Gitk font chooser&quot;]
    ${NS}::label $top.l -textvariable fontparam(which)
    pack $top.l -side top
    set fontlist [lsort [font families]]
    ${NS}::frame $top.f
    listbox $top.f.fam -listvariable fontlist \
        -yscrollcommand [list $top.f.sb set]
    bind $top.f.fam &lt;&lt;ListboxSelect&gt;&gt; selfontfam
    ${NS}::scrollbar $top.f.sb -command [list $top.f.fam yview]
    pack $top.f.sb -side right -fill y
    pack $top.f.fam -side left -fill both -expand 1
    pack $top.f -side top -fill both -expand 1
    ${NS}::frame $top.g
    spinbox $top.g.size -from 4 -to 40 -width 4 \
        -textvariable fontparam(size) \
        -validatecommand {string is integer -strict %s}
    checkbutton $top.g.bold -padx 5 \
        -font {{Times New Roman} 12 bold} -text [mc &quot;B&quot;] -indicatoron 0 \
        -variable fontparam(weight) -onvalue bold -offvalue normal
    checkbutton $top.g.ital -padx 5 \
        -font {{Times New Roman} 12 italic} -text [mc &quot;I&quot;] -indicatoron 0  \
        -variable fontparam(slant) -onvalue italic -offvalue roman
    pack $top.g.size $top.g.bold $top.g.ital -side left
    pack $top.g -side top
    canvas $top.c -width 150 -height 50 -border 2 -relief sunk \
        -background white
    $top.c create text 100 25 -anchor center -text $which -font sample \
        -fill black -tags text
    bind $top.c &lt;Configure&gt; [list centertext $top.c]
    pack $top.c -side top -fill x
    ${NS}::frame $top.buts
    ${NS}::button $top.buts.ok -text [mc &quot;OK&quot;] -command fontok -default active
    ${NS}::button $top.buts.can -text [mc &quot;Cancel&quot;] -command fontcan -default normal
    bind $top &lt;Key-Return&gt; fontok
    bind $top &lt;Key-Escape&gt; fontcan
    grid $top.buts.ok $top.buts.can
    grid columnconfigure $top.buts 0 -weight 1 -uniform a
    grid columnconfigure $top.buts 1 -weight 1 -uniform a
    pack $top.buts -side bottom -fill x
    trace add variable fontparam write chg_fontparam
} else {
    raise $top
    $top.c itemconf text -text $which
}
set i [lsearch -exact $fontlist $fontparam(family)]
if {$i &gt;= 0} {
    $top.f.fam selection set $i
    $top.f.fam see $i
}</pre>

<p>}</p>

<p>proc centertext {w} {</p>

<pre>$w coords text [expr {[winfo width $w] / 2}] [expr {[winfo height $w] / 2}]</pre>

<p>}</p>

<p>proc fontok {} {</p>

<pre>global fontparam fontpref prefstop

set f $fontparam(font)
set fontpref($f) [list $fontparam(family) $fontparam(size)]
if {$fontparam(weight) eq &quot;bold&quot;} {
    lappend fontpref($f) &quot;bold&quot;
}
if {$fontparam(slant) eq &quot;italic&quot;} {
    lappend fontpref($f) &quot;italic&quot;
}
set w $prefstop.notebook.fonts.$f
$w conf -text $fontparam(family) -font $fontpref($f)

fontcan</pre>

<p>}</p>

<p>proc fontcan {} {</p>

<pre>global fonttop fontparam

if {[info exists fonttop]} {
    catch {destroy $fonttop}
    catch {font delete sample}
    unset fonttop
    unset fontparam
}</pre>

<p>}</p>

<p>if {[package vsatisfies [package provide Tk] 8.6]} {</p>

<pre># In Tk 8.6 we have a native font chooser dialog. Overwrite the above
# function to make use of it.
proc choosefont {font which} {
    tk fontchooser configure -title $which -font $font \
        -command [list on_choosefont $font $which]
    tk fontchooser show
}
proc on_choosefont {font which newfont} {
    global fontparam
    puts stderr &quot;$font $newfont&quot;
    array set f [font actual $newfont]
    set fontparam(which) $which
    set fontparam(font) $font
    set fontparam(family) $f(-family)
    set fontparam(size) $f(-size)
    set fontparam(weight) $f(-weight)
    set fontparam(slant) $f(-slant)
    fontok
}</pre>

<p>}</p>

<p>proc selfontfam {} {</p>

<pre>global fonttop fontparam

set i [$fonttop.f.fam curselection]
if {$i ne {}} {
    set fontparam(family) [$fonttop.f.fam get $i]
}</pre>

<p>}</p>

<p>proc chg_fontparam {v sub op} {</p>

<pre>global fontparam

font config sample -$sub $fontparam($sub)</pre>

<p>}</p>

<p># Create a property sheet tab page proc create_prefs_page {w} {</p>

<pre class="ruby"><span class="ruby-identifier">global</span> <span class="ruby-constant">NS</span>
<span class="ruby-identifier">set</span> <span class="ruby-identifier">parent</span> [<span class="ruby-identifier">join</span> [<span class="ruby-identifier">lrange</span> [<span class="ruby-identifier">split</span> <span class="ruby-identifier">$w</span> .] <span class="ruby-value">0</span> <span class="ruby-keyword">end</span><span class="ruby-operator">-</span><span class="ruby-value">1</span>] .]
<span class="ruby-keyword">if</span> {[<span class="ruby-identifier">winfo</span> <span class="ruby-identifier">class</span> <span class="ruby-identifier">$parent</span>] <span class="ruby-identifier">eq</span> <span class="ruby-string">&quot;TNotebook&quot;</span>} {
    ${<span class="ruby-constant">NS</span>}<span class="ruby-operator">::</span><span class="ruby-identifier">frame</span> <span class="ruby-identifier">$w</span>
} <span class="ruby-keyword">else</span> {
    ${<span class="ruby-constant">NS</span>}<span class="ruby-operator">::</span><span class="ruby-identifier">labelframe</span> <span class="ruby-identifier">$w</span>
}
</pre>

<p>}</p>

<p>proc prefspage_general {notebook} {</p>

<pre>global NS maxwidth maxgraphpct showneartags showlocalchanges
global tabstop limitdiffs autoselect autosellen extdifftool perfile_attrs
global hideremotes want_ttk have_ttk maxrefs

set page [create_prefs_page $notebook.general]

${NS}::label $page.ldisp -text [mc &quot;Commit list display options&quot;]
grid $page.ldisp - -sticky w -pady 10
${NS}::label $page.spacer -text &quot; &quot;
${NS}::label $page.maxwidthl -text [mc &quot;Maximum graph width (lines)&quot;]
spinbox $page.maxwidth -from 0 -to 100 -width 4 -textvariable maxwidth
grid $page.spacer $page.maxwidthl $page.maxwidth -sticky w
${NS}::label $page.maxpctl -text [mc &quot;Maximum graph width (% of pane)&quot;]
spinbox $page.maxpct -from 1 -to 100 -width 4 -textvariable maxgraphpct
grid x $page.maxpctl $page.maxpct -sticky w
${NS}::checkbutton $page.showlocal -text [mc &quot;Show local changes&quot;] \
    -variable showlocalchanges
grid x $page.showlocal -sticky w
${NS}::checkbutton $page.autoselect -text [mc &quot;Auto-select SHA1 (length)&quot;] \
    -variable autoselect
spinbox $page.autosellen -from 1 -to 40 -width 4 -textvariable autosellen
grid x $page.autoselect $page.autosellen -sticky w
${NS}::checkbutton $page.hideremotes -text [mc &quot;Hide remote refs&quot;] \
    -variable hideremotes
grid x $page.hideremotes -sticky w

${NS}::label $page.ddisp -text [mc &quot;Diff display options&quot;]
grid $page.ddisp - -sticky w -pady 10
${NS}::label $page.tabstopl -text [mc &quot;Tab spacing&quot;]
spinbox $page.tabstop -from 1 -to 20 -width 4 -textvariable tabstop
grid x $page.tabstopl $page.tabstop -sticky w
${NS}::checkbutton $page.ntag -text [mc &quot;Display nearby tags/heads&quot;] \
    -variable showneartags
grid x $page.ntag -sticky w
${NS}::label $page.maxrefsl -text [mc &quot;Maximum # tags/heads to show&quot;]
spinbox $page.maxrefs -from 1 -to 1000 -width 4 -textvariable maxrefs
grid x $page.maxrefsl $page.maxrefs -sticky w
${NS}::checkbutton $page.ldiff -text [mc &quot;Limit diffs to listed paths&quot;] \
    -variable limitdiffs
grid x $page.ldiff -sticky w
${NS}::checkbutton $page.lattr -text [mc &quot;Support per-file encodings&quot;] \
    -variable perfile_attrs
grid x $page.lattr -sticky w

${NS}::entry $page.extdifft -textvariable extdifftool
${NS}::frame $page.extdifff
${NS}::label $page.extdifff.l -text [mc &quot;External diff tool&quot; ]
${NS}::button $page.extdifff.b -text [mc &quot;Choose...&quot;] -command choose_extdiff
pack $page.extdifff.l $page.extdifff.b -side left
pack configure $page.extdifff.l -padx 10
grid x $page.extdifff $page.extdifft -sticky ew

${NS}::label $page.lgen -text [mc &quot;General options&quot;]
grid $page.lgen - -sticky w -pady 10
${NS}::checkbutton $page.want_ttk -variable want_ttk \
    -text [mc &quot;Use themed widgets&quot;]
if {$have_ttk} {
    ${NS}::label $page.ttk_note -text [mc &quot;(change requires restart)&quot;]
} else {
    ${NS}::label $page.ttk_note -text [mc &quot;(currently unavailable)&quot;]
}
grid x $page.want_ttk $page.ttk_note -sticky w
return $page</pre>

<p>}</p>

<p>proc prefspage_colors {notebook} {</p>

<pre>global NS uicolor bgcolor fgcolor ctext diffcolors selectbgcolor markbgcolor

set page [create_prefs_page $notebook.colors]

${NS}::label $page.cdisp -text [mc &quot;Colors: press to choose&quot;]
grid $page.cdisp - -sticky w -pady 10
label $page.ui -padx 40 -relief sunk -background $uicolor
${NS}::button $page.uibut -text [mc &quot;Interface&quot;] \
   -command [list choosecolor uicolor {} $page.ui [mc &quot;interface&quot;] setui]
grid x $page.uibut $page.ui -sticky w
label $page.bg -padx 40 -relief sunk -background $bgcolor
${NS}::button $page.bgbut -text [mc &quot;Background&quot;] \
    -command [list choosecolor bgcolor {} $page.bg [mc &quot;background&quot;] setbg]
grid x $page.bgbut $page.bg -sticky w
label $page.fg -padx 40 -relief sunk -background $fgcolor
${NS}::button $page.fgbut -text [mc &quot;Foreground&quot;] \
    -command [list choosecolor fgcolor {} $page.fg [mc &quot;foreground&quot;] setfg]
grid x $page.fgbut $page.fg -sticky w
label $page.diffold -padx 40 -relief sunk -background [lindex $diffcolors 0]
${NS}::button $page.diffoldbut -text [mc &quot;Diff: old lines&quot;] \
    -command [list choosecolor diffcolors 0 $page.diffold [mc &quot;diff old lines&quot;] \
                  [list $ctext tag conf d0 -foreground]]
grid x $page.diffoldbut $page.diffold -sticky w
label $page.diffnew -padx 40 -relief sunk -background [lindex $diffcolors 1]
${NS}::button $page.diffnewbut -text [mc &quot;Diff: new lines&quot;] \
    -command [list choosecolor diffcolors 1 $page.diffnew [mc &quot;diff new lines&quot;] \
                  [list $ctext tag conf dresult -foreground]]
grid x $page.diffnewbut $page.diffnew -sticky w
label $page.hunksep -padx 40 -relief sunk -background [lindex $diffcolors 2]
${NS}::button $page.hunksepbut -text [mc &quot;Diff: hunk header&quot;] \
    -command [list choosecolor diffcolors 2 $page.hunksep \
                  [mc &quot;diff hunk header&quot;] \
                  [list $ctext tag conf hunksep -foreground]]
grid x $page.hunksepbut $page.hunksep -sticky w
label $page.markbgsep -padx 40 -relief sunk -background $markbgcolor
${NS}::button $page.markbgbut -text [mc &quot;Marked line bg&quot;] \
    -command [list choosecolor markbgcolor {} $page.markbgsep \
                  [mc &quot;marked line background&quot;] \
                  [list $ctext tag conf omark -background]]
grid x $page.markbgbut $page.markbgsep -sticky w
label $page.selbgsep -padx 40 -relief sunk -background $selectbgcolor
${NS}::button $page.selbgbut -text [mc &quot;Select bg&quot;] \
    -command [list choosecolor selectbgcolor {} $page.selbgsep [mc &quot;background&quot;] setselbg]
grid x $page.selbgbut $page.selbgsep -sticky w
return $page</pre>

<p>}</p>

<p>proc prefspage_fonts {notebook} {</p>

<pre>global NS
set page [create_prefs_page $notebook.fonts]
${NS}::label $page.cfont -text [mc &quot;Fonts: press to choose&quot;]
grid $page.cfont - -sticky w -pady 10
mkfontdisp mainfont $page [mc &quot;Main font&quot;]
mkfontdisp textfont $page [mc &quot;Diff display font&quot;]
mkfontdisp uifont $page [mc &quot;User interface font&quot;]
return $page</pre>

<p>}</p>

<p>proc doprefs {} {</p>

<pre>global maxwidth maxgraphpct use_ttk NS
global oldprefs prefstop showneartags showlocalchanges
global uicolor bgcolor fgcolor ctext diffcolors selectbgcolor markbgcolor
global tabstop limitdiffs autoselect autosellen extdifftool perfile_attrs
global hideremotes want_ttk have_ttk

set top .gitkprefs
set prefstop $top
if {[winfo exists $top]} {
    raise $top
    return
}
foreach v {maxwidth maxgraphpct showneartags showlocalchanges \
               limitdiffs tabstop perfile_attrs hideremotes want_ttk} {
    set oldprefs($v) [set $v]
}
ttk_toplevel $top
wm title $top [mc &quot;Gitk preferences&quot;]
make_transient $top .

if {[set use_notebook [expr {$use_ttk &amp;&amp; [info command ::ttk::notebook] ne &quot;&quot;}]]} {
    set notebook [ttk::notebook $top.notebook]
} else {
    set notebook [${NS}::frame $top.notebook -borderwidth 0 -relief flat]
}

lappend pages [prefspage_general $notebook] [mc &quot;General&quot;]
lappend pages [prefspage_colors $notebook] [mc &quot;Colors&quot;]
lappend pages [prefspage_fonts $notebook] [mc &quot;Fonts&quot;]
set col 0
foreach {page title} $pages {
    if {$use_notebook} {
        $notebook add $page -text $title
    } else {
        set btn [${NS}::button $notebook.b_[string map {. X} $page] \
                     -text $title -command [list raise $page]]
        $page configure -text $title
        grid $btn -row 0 -column [incr col] -sticky w
        grid $page -row 1 -column 0 -sticky news -columnspan 100
    }
}

if {!$use_notebook} {
    grid columnconfigure $notebook 0 -weight 1
    grid rowconfigure $notebook 1 -weight 1
    raise [lindex $pages 0]
}

grid $notebook -sticky news -padx 2 -pady 2
grid rowconfigure $top 0 -weight 1
grid columnconfigure $top 0 -weight 1

${NS}::frame $top.buts
${NS}::button $top.buts.ok -text [mc &quot;OK&quot;] -command prefsok -default active
${NS}::button $top.buts.can -text [mc &quot;Cancel&quot;] -command prefscan -default normal
bind $top &lt;Key-Return&gt; prefsok
bind $top &lt;Key-Escape&gt; prefscan
grid $top.buts.ok $top.buts.can
grid columnconfigure $top.buts 0 -weight 1 -uniform a
grid columnconfigure $top.buts 1 -weight 1 -uniform a
grid $top.buts - - -pady 10 -sticky ew
grid columnconfigure $top 2 -weight 1
bind $top &lt;Visibility&gt; [list focus $top.buts.ok]</pre>

<p>}</p>

<p>proc choose_extdiff {} {</p>

<pre>global extdifftool

set prog [tk_getOpenFile -title [mc &quot;External diff tool&quot;] -multiple false]
if {$prog ne {}} {
    set extdifftool $prog
}</pre>

<p>}</p>

<p>proc choosecolor {v vi w x cmd} {</p>

<pre>global $v

set c [tk_chooseColor -initialcolor [lindex [set $v] $vi] \
           -title [mc &quot;Gitk: choose color for %s&quot; $x]]
if {$c eq {}} return
$w conf -background $c
lset $v $vi $c
eval $cmd $c</pre>

<p>}</p>

<p>proc setselbg {c} {</p>

<pre>global bglist cflist
foreach w $bglist {
    $w configure -selectbackground $c
}
$cflist tag configure highlight \
    -background [$cflist cget -selectbackground]
allcanvs itemconf secsel -fill $c</pre>

<p>}</p>

<p># This sets the background color and the color scheme for the whole UI. #
For some reason, tk_setPalette chooses a nasty dark red for selectColor #
if we don&#39;t specify one ourselves, which makes the checkbuttons and #
radiobuttons look bad.  This chooses white for selectColor if the #
background color is light, or black if it is dark. proc setui {c} {</p>

<pre>if {[tk windowingsystem] eq &quot;win32&quot;} { return }
set bg [winfo rgb . $c]
set selc black
if {[lindex $bg 0] + 1.5 * [lindex $bg 1] + 0.5 * [lindex $bg 2] &gt; 100000} {
    set selc white
}
tk_setPalette background $c selectColor $selc</pre>

<p>}</p>

<p>proc setbg {c} {</p>

<pre>global bglist

foreach w $bglist {
    $w conf -background $c
}</pre>

<p>}</p>

<p>proc setfg {c} {</p>

<pre>global fglist canv

foreach w $fglist {
    $w conf -foreground $c
}
allcanvs itemconf text -fill $c
$canv itemconf circle -outline $c
$canv itemconf markid -outline $c</pre>

<p>}</p>

<p>proc prefscan {} {</p>

<pre>global oldprefs prefstop

foreach v {maxwidth maxgraphpct showneartags showlocalchanges \
               limitdiffs tabstop perfile_attrs hideremotes want_ttk} {
    global $v
    set $v $oldprefs($v)
}
catch {destroy $prefstop}
unset prefstop
fontcan</pre>

<p>}</p>

<p>proc prefsok {} {</p>

<pre>global maxwidth maxgraphpct
global oldprefs prefstop showneartags showlocalchanges
global fontpref mainfont textfont uifont
global limitdiffs treediffs perfile_attrs
global hideremotes

catch {destroy $prefstop}
unset prefstop
fontcan
set fontchanged 0
if {$mainfont ne $fontpref(mainfont)} {
    set mainfont $fontpref(mainfont)
    parsefont mainfont $mainfont
    eval font configure mainfont [fontflags mainfont]
    eval font configure mainfontbold [fontflags mainfont 1]
    setcoords
    set fontchanged 1
}
if {$textfont ne $fontpref(textfont)} {
    set textfont $fontpref(textfont)
    parsefont textfont $textfont
    eval font configure textfont [fontflags textfont]
    eval font configure textfontbold [fontflags textfont 1]
}
if {$uifont ne $fontpref(uifont)} {
    set uifont $fontpref(uifont)
    parsefont uifont $uifont
    eval font configure uifont [fontflags uifont]
}
settabs
if {$showlocalchanges != $oldprefs(showlocalchanges)} {
    if {$showlocalchanges} {
        doshowlocalchanges
    } else {
        dohidelocalchanges
    }
}
if {$limitdiffs != $oldprefs(limitdiffs) ||
    ($perfile_attrs &amp;&amp; !$oldprefs(perfile_attrs))} {
    # treediffs elements are limited by path;
    # won&#39;t have encodings cached if perfile_attrs was just turned on
    catch {unset treediffs}
}
if {$fontchanged || $maxwidth != $oldprefs(maxwidth)
    || $maxgraphpct != $oldprefs(maxgraphpct)} {
    redisplay
} elseif {$showneartags != $oldprefs(showneartags) ||
      $limitdiffs != $oldprefs(limitdiffs)} {
    reselectline
}
if {$hideremotes != $oldprefs(hideremotes)} {
    rereadrefs
}</pre>

<p>}</p>

<p>proc formatdate {d} {</p>

<pre>global datetimeformat
if {$d ne {}} {
    set d [clock format [lindex $d 0] -format $datetimeformat]
}
return $d</pre>

<p>}</p>

<p># This list of encoding names and aliases is distilled from # <a
href="http://www.iana.org/assignments/character-sets">www.iana.org/assignments/character-sets</a>.
# Not all of them are supported by Tcl. set encoding_aliases {</p>

<pre>{ ANSI_X3.4-1968 iso-ir-6 ANSI_X3.4-1986 ISO_646.irv:1991 ASCII
  ISO646-US US-ASCII us IBM367 cp367 csASCII }
{ ISO-10646-UTF-1 csISO10646UTF1 }
{ ISO_646.basic:1983 ref csISO646basic1983 }
{ INVARIANT csINVARIANT }
{ ISO_646.irv:1983 iso-ir-2 irv csISO2IntlRefVersion }
{ BS_4730 iso-ir-4 ISO646-GB gb uk csISO4UnitedKingdom }
{ NATS-SEFI iso-ir-8-1 csNATSSEFI }
{ NATS-SEFI-ADD iso-ir-8-2 csNATSSEFIADD }
{ NATS-DANO iso-ir-9-1 csNATSDANO }
{ NATS-DANO-ADD iso-ir-9-2 csNATSDANOADD }
{ SEN_850200_B iso-ir-10 FI ISO646-FI ISO646-SE se csISO10Swedish }
{ SEN_850200_C iso-ir-11 ISO646-SE2 se2 csISO11SwedishForNames }
{ KS_C_5601-1987 iso-ir-149 KS_C_5601-1989 KSC_5601 korean csKSC56011987 }
{ ISO-2022-KR csISO2022KR }
{ EUC-KR csEUCKR }
{ ISO-2022-JP csISO2022JP }
{ ISO-2022-JP-2 csISO2022JP2 }
{ JIS_C6220-1969-jp JIS_C6220-1969 iso-ir-13 katakana x0201-7
  csISO13JISC6220jp }
{ JIS_C6220-1969-ro iso-ir-14 jp ISO646-JP csISO14JISC6220ro }
{ IT iso-ir-15 ISO646-IT csISO15Italian }
{ PT iso-ir-16 ISO646-PT csISO16Portuguese }
{ ES iso-ir-17 ISO646-ES csISO17Spanish }
{ greek7-old iso-ir-18 csISO18Greek7Old }
{ latin-greek iso-ir-19 csISO19LatinGreek }
{ DIN_66003 iso-ir-21 de ISO646-DE csISO21German }
{ NF_Z_62-010_(1973) iso-ir-25 ISO646-FR1 csISO25French }
{ Latin-greek-1 iso-ir-27 csISO27LatinGreek1 }
{ ISO_5427 iso-ir-37 csISO5427Cyrillic }
{ JIS_C6226-1978 iso-ir-42 csISO42JISC62261978 }
{ BS_viewdata iso-ir-47 csISO47BSViewdata }
{ INIS iso-ir-49 csISO49INIS }
{ INIS-8 iso-ir-50 csISO50INIS8 }
{ INIS-cyrillic iso-ir-51 csISO51INISCyrillic }
{ ISO_5427:1981 iso-ir-54 ISO5427Cyrillic1981 }
{ ISO_5428:1980 iso-ir-55 csISO5428Greek }
{ GB_1988-80 iso-ir-57 cn ISO646-CN csISO57GB1988 }
{ GB_2312-80 iso-ir-58 chinese csISO58GB231280 }
{ NS_4551-1 iso-ir-60 ISO646-NO no csISO60DanishNorwegian
  csISO60Norwegian1 }
{ NS_4551-2 ISO646-NO2 iso-ir-61 no2 csISO61Norwegian2 }
{ NF_Z_62-010 iso-ir-69 ISO646-FR fr csISO69French }
{ videotex-suppl iso-ir-70 csISO70VideotexSupp1 }
{ PT2 iso-ir-84 ISO646-PT2 csISO84Portuguese2 }
{ ES2 iso-ir-85 ISO646-ES2 csISO85Spanish2 }
{ MSZ_7795.3 iso-ir-86 ISO646-HU hu csISO86Hungarian }
{ JIS_C6226-1983 iso-ir-87 x0208 JIS_X0208-1983 csISO87JISX0208 }
{ greek7 iso-ir-88 csISO88Greek7 }
{ ASMO_449 ISO_9036 arabic7 iso-ir-89 csISO89ASMO449 }
{ iso-ir-90 csISO90 }
{ JIS_C6229-1984-a iso-ir-91 jp-ocr-a csISO91JISC62291984a }
{ JIS_C6229-1984-b iso-ir-92 ISO646-JP-OCR-B jp-ocr-b
  csISO92JISC62991984b }
{ JIS_C6229-1984-b-add iso-ir-93 jp-ocr-b-add csISO93JIS62291984badd }
{ JIS_C6229-1984-hand iso-ir-94 jp-ocr-hand csISO94JIS62291984hand }
{ JIS_C6229-1984-hand-add iso-ir-95 jp-ocr-hand-add
  csISO95JIS62291984handadd }
{ JIS_C6229-1984-kana iso-ir-96 csISO96JISC62291984kana }
{ ISO_2033-1983 iso-ir-98 e13b csISO2033 }
{ ANSI_X3.110-1983 iso-ir-99 CSA_T500-1983 NAPLPS csISO99NAPLPS }
{ ISO_8859-1:1987 iso-ir-100 ISO_8859-1 ISO-8859-1 latin1 l1 IBM819
  CP819 csISOLatin1 }
{ ISO_8859-2:1987 iso-ir-101 ISO_8859-2 ISO-8859-2 latin2 l2 csISOLatin2 }
{ T.61-7bit iso-ir-102 csISO102T617bit }
{ T.61-8bit T.61 iso-ir-103 csISO103T618bit }
{ ISO_8859-3:1988 iso-ir-109 ISO_8859-3 ISO-8859-3 latin3 l3 csISOLatin3 }
{ ISO_8859-4:1988 iso-ir-110 ISO_8859-4 ISO-8859-4 latin4 l4 csISOLatin4 }
{ ECMA-cyrillic iso-ir-111 KOI8-E csISO111ECMACyrillic }
{ CSA_Z243.4-1985-1 iso-ir-121 ISO646-CA csa7-1 ca csISO121Canadian1 }
{ CSA_Z243.4-1985-2 iso-ir-122 ISO646-CA2 csa7-2 csISO122Canadian2 }
{ CSA_Z243.4-1985-gr iso-ir-123 csISO123CSAZ24341985gr }
{ ISO_8859-6:1987 iso-ir-127 ISO_8859-6 ISO-8859-6 ECMA-114 ASMO-708
  arabic csISOLatinArabic }
{ ISO_8859-6-E csISO88596E ISO-8859-6-E }
{ ISO_8859-6-I csISO88596I ISO-8859-6-I }
{ ISO_8859-7:1987 iso-ir-126 ISO_8859-7 ISO-8859-7 ELOT_928 ECMA-118
  greek greek8 csISOLatinGreek }
{ T.101-G2 iso-ir-128 csISO128T101G2 }
{ ISO_8859-8:1988 iso-ir-138 ISO_8859-8 ISO-8859-8 hebrew
  csISOLatinHebrew }
{ ISO_8859-8-E csISO88598E ISO-8859-8-E }
{ ISO_8859-8-I csISO88598I ISO-8859-8-I }
{ CSN_369103 iso-ir-139 csISO139CSN369103 }
{ JUS_I.B1.002 iso-ir-141 ISO646-YU js yu csISO141JUSIB1002 }
{ ISO_6937-2-add iso-ir-142 csISOTextComm }
{ IEC_P27-1 iso-ir-143 csISO143IECP271 }
{ ISO_8859-5:1988 iso-ir-144 ISO_8859-5 ISO-8859-5 cyrillic
  csISOLatinCyrillic }
{ JUS_I.B1.003-serb iso-ir-146 serbian csISO146Serbian }
{ JUS_I.B1.003-mac macedonian iso-ir-147 csISO147Macedonian }
{ ISO_8859-9:1989 iso-ir-148 ISO_8859-9 ISO-8859-9 latin5 l5 csISOLatin5 }
{ greek-ccitt iso-ir-150 csISO150 csISO150GreekCCITT }
{ NC_NC00-10:81 cuba iso-ir-151 ISO646-CU csISO151Cuba }
{ ISO_6937-2-25 iso-ir-152 csISO6937Add }
{ GOST_19768-74 ST_SEV_358-88 iso-ir-153 csISO153GOST1976874 }
{ ISO_8859-supp iso-ir-154 latin1-2-5 csISO8859Supp }
{ ISO_10367-box iso-ir-155 csISO10367Box }
{ ISO-8859-10 iso-ir-157 l6 ISO_8859-10:1992 csISOLatin6 latin6 }
{ latin-lap lap iso-ir-158 csISO158Lap }
{ JIS_X0212-1990 x0212 iso-ir-159 csISO159JISX02121990 }
{ DS_2089 DS2089 ISO646-DK dk csISO646Danish }
{ us-dk csUSDK }
{ dk-us csDKUS }
{ JIS_X0201 X0201 csHalfWidthKatakana }
{ KSC5636 ISO646-KR csKSC5636 }
{ ISO-10646-UCS-2 csUnicode }
{ ISO-10646-UCS-4 csUCS4 }
{ DEC-MCS dec csDECMCS }
{ hp-roman8 roman8 r8 csHPRoman8 }
{ macintosh mac csMacintosh }
{ IBM037 cp037 ebcdic-cp-us ebcdic-cp-ca ebcdic-cp-wt ebcdic-cp-nl
  csIBM037 }
{ IBM038 EBCDIC-INT cp038 csIBM038 }
{ IBM273 CP273 csIBM273 }
{ IBM274 EBCDIC-BE CP274 csIBM274 }
{ IBM275 EBCDIC-BR cp275 csIBM275 }
{ IBM277 EBCDIC-CP-DK EBCDIC-CP-NO csIBM277 }
{ IBM278 CP278 ebcdic-cp-fi ebcdic-cp-se csIBM278 }
{ IBM280 CP280 ebcdic-cp-it csIBM280 }
{ IBM281 EBCDIC-JP-E cp281 csIBM281 }
{ IBM284 CP284 ebcdic-cp-es csIBM284 }
{ IBM285 CP285 ebcdic-cp-gb csIBM285 }
{ IBM290 cp290 EBCDIC-JP-kana csIBM290 }
{ IBM297 cp297 ebcdic-cp-fr csIBM297 }
{ IBM420 cp420 ebcdic-cp-ar1 csIBM420 }
{ IBM423 cp423 ebcdic-cp-gr csIBM423 }
{ IBM424 cp424 ebcdic-cp-he csIBM424 }
{ IBM437 cp437 437 csPC8CodePage437 }
{ IBM500 CP500 ebcdic-cp-be ebcdic-cp-ch csIBM500 }
{ IBM775 cp775 csPC775Baltic }
{ IBM850 cp850 850 csPC850Multilingual }
{ IBM851 cp851 851 csIBM851 }
{ IBM852 cp852 852 csPCp852 }
{ IBM855 cp855 855 csIBM855 }
{ IBM857 cp857 857 csIBM857 }
{ IBM860 cp860 860 csIBM860 }
{ IBM861 cp861 861 cp-is csIBM861 }
{ IBM862 cp862 862 csPC862LatinHebrew }
{ IBM863 cp863 863 csIBM863 }
{ IBM864 cp864 csIBM864 }
{ IBM865 cp865 865 csIBM865 }
{ IBM866 cp866 866 csIBM866 }
{ IBM868 CP868 cp-ar csIBM868 }
{ IBM869 cp869 869 cp-gr csIBM869 }
{ IBM870 CP870 ebcdic-cp-roece ebcdic-cp-yu csIBM870 }
{ IBM871 CP871 ebcdic-cp-is csIBM871 }
{ IBM880 cp880 EBCDIC-Cyrillic csIBM880 }
{ IBM891 cp891 csIBM891 }
{ IBM903 cp903 csIBM903 }
{ IBM904 cp904 904 csIBBM904 }
{ IBM905 CP905 ebcdic-cp-tr csIBM905 }
{ IBM918 CP918 ebcdic-cp-ar2 csIBM918 }
{ IBM1026 CP1026 csIBM1026 }
{ EBCDIC-AT-DE csIBMEBCDICATDE }
{ EBCDIC-AT-DE-A csEBCDICATDEA }
{ EBCDIC-CA-FR csEBCDICCAFR }
{ EBCDIC-DK-NO csEBCDICDKNO }
{ EBCDIC-DK-NO-A csEBCDICDKNOA }
{ EBCDIC-FI-SE csEBCDICFISE }
{ EBCDIC-FI-SE-A csEBCDICFISEA }
{ EBCDIC-FR csEBCDICFR }
{ EBCDIC-IT csEBCDICIT }
{ EBCDIC-PT csEBCDICPT }
{ EBCDIC-ES csEBCDICES }
{ EBCDIC-ES-A csEBCDICESA }
{ EBCDIC-ES-S csEBCDICESS }
{ EBCDIC-UK csEBCDICUK }
{ EBCDIC-US csEBCDICUS }
{ UNKNOWN-8BIT csUnknown8BiT }
{ MNEMONIC csMnemonic }
{ MNEM csMnem }
{ VISCII csVISCII }
{ VIQR csVIQR }
{ KOI8-R csKOI8R }
{ IBM00858 CCSID00858 CP00858 PC-Multilingual-850+euro }
{ IBM00924 CCSID00924 CP00924 ebcdic-Latin9--euro }
{ IBM01140 CCSID01140 CP01140 ebcdic-us-37+euro }
{ IBM01141 CCSID01141 CP01141 ebcdic-de-273+euro }
{ IBM01142 CCSID01142 CP01142 ebcdic-dk-277+euro ebcdic-no-277+euro }
{ IBM01143 CCSID01143 CP01143 ebcdic-fi-278+euro ebcdic-se-278+euro }
{ IBM01144 CCSID01144 CP01144 ebcdic-it-280+euro }
{ IBM01145 CCSID01145 CP01145 ebcdic-es-284+euro }
{ IBM01146 CCSID01146 CP01146 ebcdic-gb-285+euro }
{ IBM01147 CCSID01147 CP01147 ebcdic-fr-297+euro }
{ IBM01148 CCSID01148 CP01148 ebcdic-international-500+euro }
{ IBM01149 CCSID01149 CP01149 ebcdic-is-871+euro }
{ IBM1047 IBM-1047 }
{ PTCP154 csPTCP154 PT154 CP154 Cyrillic-Asian }
{ Amiga-1251 Ami1251 Amiga1251 Ami-1251 }
{ UNICODE-1-1 csUnicode11 }
{ CESU-8 csCESU-8 }
{ BOCU-1 csBOCU-1 }
{ UNICODE-1-1-UTF-7 csUnicode11UTF7 }
{ ISO-8859-14 iso-ir-199 ISO_8859-14:1998 ISO_8859-14 latin8 iso-celtic
  l8 }
{ ISO-8859-15 ISO_8859-15 Latin-9 }
{ ISO-8859-16 iso-ir-226 ISO_8859-16:2001 ISO_8859-16 latin10 l10 }
{ GBK CP936 MS936 windows-936 }
{ JIS_Encoding csJISEncoding }
{ Shift_JIS MS_Kanji csShiftJIS ShiftJIS Shift-JIS }
{ Extended_UNIX_Code_Packed_Format_for_Japanese csEUCPkdFmtJapanese
  EUC-JP }
{ Extended_UNIX_Code_Fixed_Width_for_Japanese csEUCFixWidJapanese }
{ ISO-10646-UCS-Basic csUnicodeASCII }
{ ISO-10646-Unicode-Latin1 csUnicodeLatin1 ISO-10646 }
{ ISO-Unicode-IBM-1261 csUnicodeIBM1261 }
{ ISO-Unicode-IBM-1268 csUnicodeIBM1268 }
{ ISO-Unicode-IBM-1276 csUnicodeIBM1276 }
{ ISO-Unicode-IBM-1264 csUnicodeIBM1264 }
{ ISO-Unicode-IBM-1265 csUnicodeIBM1265 }
{ ISO-8859-1-Windows-3.0-Latin-1 csWindows30Latin1 }
{ ISO-8859-1-Windows-3.1-Latin-1 csWindows31Latin1 }
{ ISO-8859-2-Windows-Latin-2 csWindows31Latin2 }
{ ISO-8859-9-Windows-Latin-5 csWindows31Latin5 }
{ Adobe-Standard-Encoding csAdobeStandardEncoding }
{ Ventura-US csVenturaUS }
{ Ventura-International csVenturaInternational }
{ PC8-Danish-Norwegian csPC8DanishNorwegian }
{ PC8-Turkish csPC8Turkish }
{ IBM-Symbols csIBMSymbols }
{ IBM-Thai csIBMThai }
{ HP-Legal csHPLegal }
{ HP-Pi-font csHPPiFont }
{ HP-Math8 csHPMath8 }
{ Adobe-Symbol-Encoding csHPPSMath }
{ HP-DeskTop csHPDesktop }
{ Ventura-Math csVenturaMath }
{ Microsoft-Publishing csMicrosoftPublishing }
{ Windows-31J csWindows31J }
{ GB2312 csGB2312 }
{ Big5 csBig5 }</pre>

<p>}</p>

<p>proc tcl_encoding {enc} {</p>

<pre>global encoding_aliases tcl_encoding_cache
if {[info exists tcl_encoding_cache($enc)]} {
    return $tcl_encoding_cache($enc)
}
set names [encoding names]
set lcnames [string tolower $names]
set enc [string tolower $enc]
set i [lsearch -exact $lcnames $enc]
if {$i &lt; 0} {
    # look for &quot;isonnn&quot; instead of &quot;iso-nnn&quot; or &quot;iso_nnn&quot;
    if {[regsub {^(iso|cp|ibm|jis)[-_]} $enc {\1} encx]} {
        set i [lsearch -exact $lcnames $encx]
    }
}
if {$i &lt; 0} {
    foreach l $encoding_aliases {
        set ll [string tolower $l]
        if {[lsearch -exact $ll $enc] &lt; 0} continue
        # look through the aliases for one that tcl knows about
        foreach e $ll {
            set i [lsearch -exact $lcnames $e]
            if {$i &lt; 0} {
                if {[regsub {^(iso|cp|ibm|jis)[-_]} $e {\1} ex]} {
                    set i [lsearch -exact $lcnames $ex]
                }
            }
            if {$i &gt;= 0} break
        }
        break
    }
}
set tclenc {}
if {$i &gt;= 0} {
    set tclenc [lindex $names $i]
}
set tcl_encoding_cache($enc) $tclenc
return $tclenc</pre>

<p>}</p>

<p>proc gitattr {path attr default} {</p>

<pre>global path_attr_cache
if {[info exists path_attr_cache($attr,$path)]} {
    set r $path_attr_cache($attr,$path)
} else {
    set r &quot;unspecified&quot;
    if {![catch {set line [exec git check-attr $attr -- $path]}]} {
        regexp &quot;(.*): $attr: (.*)&quot; $line m f r
    }
    set path_attr_cache($attr,$path) $r
}
if {$r eq &quot;unspecified&quot;} {
    return $default
}
return $r</pre>

<p>}</p>

<p>proc cache_gitattr {attr pathlist} {</p>

<pre>global path_attr_cache
set newlist {}
foreach path $pathlist {
    if {![info exists path_attr_cache($attr,$path)]} {
        lappend newlist $path
    }
}
set lim 1000
if {[tk windowingsystem] == &quot;win32&quot;} {
    # windows has a 32k limit on the arguments to a command...
    set lim 30
}
while {$newlist ne {}} {
    set head [lrange $newlist 0 [expr {$lim - 1}]]
    set newlist [lrange $newlist $lim end]
    if {![catch {set rlist [eval exec git check-attr $attr -- $head]}]} {
        foreach row [split $rlist &quot;\n&quot;] {
            if {[regexp &quot;(.*): $attr: (.*)&quot; $row m path value]} {
                if {[string index $path 0] eq &quot;\&quot;&quot;} {
                    set path [encoding convertfrom [lindex $path 0]]
                }
                set path_attr_cache($attr,$path) $value
            }
        }
    }
}</pre>

<p>}</p>

<p>proc get_path_encoding {path} {</p>

<pre>global gui_encoding perfile_attrs
set tcl_enc $gui_encoding
if {$path ne {} &amp;&amp; $perfile_attrs} {
    set enc2 [tcl_encoding [gitattr $path encoding $tcl_enc]]
    if {$enc2 ne {}} {
        set tcl_enc $enc2
    }
}
return $tcl_enc</pre>

<p>}</p>

<p># First check that Tcl/Tk is recent enough if {[catch {package require Tk
8.4} err]} {</p>

<pre>show_error {} . &quot;Sorry, gitk cannot run with this version of Tcl/Tk.\n\
                 Gitk requires at least Tcl/Tk 8.4.&quot; list
exit 1</pre>

<p>}</p>

<p># on OSX bring the current Wish process window to front if {[tk
windowingsystem] eq “aqua”} {</p>

<pre>exec osascript -e [format {
    tell application &quot;System Events&quot;
        set frontmost of processes whose unix id is %d to true
    end tell
} [pid] ]</pre>

<p>}</p>

<p># Unset GIT_TRACE var if set if { [info exists ::env(GIT_TRACE)] } {</p>

<pre>unset ::env(GIT_TRACE)</pre>

<p>}</p>

<p># defaults… set wrcomcmd “git diff-tree –stdin -p –pretty”</p>

<p>set gitencoding {} catch {</p>

<pre>set gitencoding [exec git config --get i18n.commitencoding]</pre>

<p>} catch {</p>

<pre>set gitencoding [exec git config --get i18n.logoutputencoding]</pre>

<p>} if {$gitencoding == “”} {</p>

<pre>set gitencoding &quot;utf-8&quot;</pre>

<p>} set tclencoding [tcl_encoding $gitencoding] if {$tclencoding == {}} {</p>

<pre>puts stderr &quot;Warning: encoding $gitencoding is not supported by Tcl/Tk&quot;</pre>

<p>}</p>

<p>set gui_encoding [encoding system] catch {</p>

<pre>set enc [exec git config --get gui.encoding]
if {$enc ne {}} {
    set tclenc [tcl_encoding $enc]
    if {$tclenc ne {}} {
        set gui_encoding $tclenc
    } else {
        puts stderr &quot;Warning: encoding $enc is not supported by Tcl/Tk&quot;
    }
}</pre>

<p>}</p>

<p>set log_showroot true catch {</p>

<pre>set log_showroot [exec git config --bool --get log.showroot]</pre>

<p>}</p>

<p>if {[tk windowingsystem] eq “aqua”} {</p>

<pre>set mainfont {{Lucida Grande} 9}
set textfont {Monaco 9}
set uifont {{Lucida Grande} 9 bold}</pre>

<p>} elseif {![catch {::tk::pkgconfig get fontsystem} xft] &amp;&amp; $xft eq
“xft”} {</p>

<pre># fontconfig!
set mainfont {sans 9}
set textfont {monospace 9}
set uifont {sans 9 bold}</pre>

<p>} else {</p>

<pre>set mainfont {Helvetica 9}
set textfont {Courier 9}
set uifont {Helvetica 9 bold}</pre>

<p>} set tabstop 8 set findmergefiles 0 set maxgraphpct 50 set maxwidth 16 set
revlistorder 0 set fastdate 0 set uparrowlen 5 set downarrowlen 5 set
mingaplen 100 set cmitmode “patch” set wrapcomment “none” set showneartags
1 set hideremotes 0 set maxrefs 20 set maxlinelen 200 set showlocalchanges
1 set limitdiffs 1 set datetimeformat “%Y-%m-%d %H:%M:%S” set autoselect 1
set autosellen 40 set perfile_attrs 0 set want_ttk 1</p>

<p>if {[tk windowingsystem] eq “aqua”} {</p>

<pre>set extdifftool &quot;opendiff&quot;</pre>

<p>} else {</p>

<pre>set extdifftool &quot;meld&quot;</pre>

<p>}</p>

<p>set colors {green red blue magenta darkgrey brown orange} if {[tk
windowingsystem] eq “win32”} {</p>

<pre>set uicolor SystemButtonFace
set uifgcolor SystemButtonText
set uifgdisabledcolor SystemDisabledText
set bgcolor SystemWindow
set fgcolor SystemWindowText
set selectbgcolor SystemHighlight</pre>

<p>} else {</p>

<pre>set uicolor grey85
set uifgcolor black
set uifgdisabledcolor &quot;#999&quot;
set bgcolor white
set fgcolor black
set selectbgcolor gray85</pre>

<p>} set diffcolors {red “#00a000” blue} set diffcontext 3 set mergecolors
{red blue green purple brown “#009090” magenta “#808000” “#009000”
“#ff0080” cyan “#b07070” “#70b0f0” “#70f0b0” “#f0b070” “#ff70b0”} set
ignorespace 0 set worddiff “” set markbgcolor “#e0e0ff”</p>

<p>set headbgcolor green set headfgcolor black set headoutlinecolor black set
remotebgcolor ffddaa set tagbgcolor yellow set tagfgcolor black set
tagoutlinecolor black set reflinecolor black set filesepbgcolor aaaaaa set
filesepfgcolor black set linehoverbgcolor ffff80 set linehoverfgcolor black
set linehoveroutlinecolor black set mainheadcirclecolor yellow set
workingfilescirclecolor red set indexcirclecolor green set circlecolors
{white blue gray blue blue} set linkfgcolor blue set circleoutlinecolor
$fgcolor set foundbgcolor yellow set currentsearchhitbgcolor orange</p>

<p># button for popping up context menus if {[tk windowingsystem] eq “aqua”} {</p>

<pre>set ctxbut &lt;Button-2&gt;</pre>

<p>} else {</p>

<pre>set ctxbut &lt;Button-3&gt;</pre>

<p>}</p>

<p>## For msgcat loading, first locate the installation location. if { [info
exists ::env(GITK_MSGSDIR)] } {</p>

<pre>## Msgsdir was manually set in the environment.
set gitk_msgsdir $::env(GITK_MSGSDIR)</pre>

<p>} else {</p>

<pre>## Let&#39;s guess the prefix from argv0.
set gitk_prefix [file dirname [file dirname [file normalize $argv0]]]
set gitk_libdir [file join $gitk_prefix share gitk lib]
set gitk_msgsdir [file join $gitk_libdir msgs]
unset gitk_prefix</pre>

<p>}</p>

<p>## Internationalization (i18n) through msgcat and gettext. See ## <a
href="http://www.gnu.org/software/gettext/manual/html_node/Tcl.html">www.gnu.org/software/gettext/manual/html_node/Tcl.html</a>
package require msgcat namespace import ::msgcat::mc ## And eventually load
the actual message catalog ::msgcat::mcload $gitk_msgsdir</p>

<p>catch {source ~/.gitk}</p>

<p>parsefont mainfont $mainfont eval font create mainfont [fontflags mainfont]
eval font create mainfontbold [fontflags mainfont 1]</p>

<p>parsefont textfont $textfont eval font create textfont [fontflags textfont]
eval font create textfontbold [fontflags textfont 1]</p>

<p>parsefont uifont $uifont eval font create uifont [fontflags uifont]</p>

<p>setui $uicolor</p>

<p>setoptions</p>

<p># check that we can find a .git directory somewhere… if {[catch {set gitdir
[exec git rev-parse –git-dir]}]} {</p>

<pre>show_error {} . [mc &quot;Cannot find a git repository here.&quot;]
exit 1</pre>

<p>}</p>

<p>set selecthead {} set selectheadid {}</p>

<p>set revtreeargs {} set cmdline_files {} set i 0 set revtreeargscmd {}
foreach arg $argv {</p>

<pre>switch -glob -- $arg {
    &quot;&quot; { }
    &quot;--&quot; {
        set cmdline_files [lrange $argv [expr {$i + 1}] end]
        break
    }
    &quot;--select-commit=*&quot; {
        set selecthead [string range $arg 16 end]
    }
    &quot;--argscmd=*&quot; {
        set revtreeargscmd [string range $arg 10 end]
    }
    default {
        lappend revtreeargs $arg
    }
}
incr i</pre>

<p>}</p>

<p>if {$selecthead eq “HEAD”} {</p>

<pre>set selecthead {}</pre>

<p>}</p>

<p>if {$i &gt;= [llength $argv] &amp;&amp; $revtreeargs ne {}} {</p>

<pre># no -- on command line, but some arguments (other than --argscmd)
if {[catch {
    set f [eval exec git rev-parse --no-revs --no-flags $revtreeargs]
    set cmdline_files [split $f &quot;\n&quot;]
    set n [llength $cmdline_files]
    set revtreeargs [lrange $revtreeargs 0 end-$n]
    # Unfortunately git rev-parse doesn&#39;t produce an error when
    # something is both a revision and a filename.  To be consistent
    # with git log and git rev-list, check revtreeargs for filenames.
    foreach arg $revtreeargs {
        if {[file exists $arg]} {
            show_error {} . [mc &quot;Ambiguous argument &#39;%s&#39;: both revision\
                             and filename&quot; $arg]
            exit 1
        }
    }
} err]} {
    # unfortunately we get both stdout and stderr in $err,
    # so look for &quot;fatal:&quot;.
    set i [string first &quot;fatal:&quot; $err]
    if {$i &gt; 0} {
        set err [string range $err [expr {$i + 6}] end]
    }
    show_error {} . &quot;[mc &quot;Bad arguments to gitk:&quot;]\n$err&quot;
    exit 1
}</pre>

<p>}</p>

<p>set nullid “0000000000000000000000000000000000000000” set nullid2
“0000000000000000000000000000000000000001” set nullfile “/dev/null”</p>

<p>set have_tk85 [expr {[package vcompare $tk_version “8.5”] &gt;= 0}] if
{![info exists have_ttk]} {</p>

<pre>set have_ttk [llength [info commands ::ttk::style]]</pre>

<p>} set use_ttk [expr {$have_ttk &amp;&amp; $want_ttk}] set NS [expr
{$use_ttk ? “ttk” : “”}]</p>

<p>regexp {^git version ([d.]*d)} [exec git version] _ git_version</p>

<p>set show_notes {} if {[package vcompare $git_version “1.6.6.2”] &gt;= 0} {</p>

<pre>set show_notes &quot;--show-notes&quot;</pre>

<p>}</p>

<p>set appname “gitk”</p>

<p>set runq {} set history {} set historyindex 0 set fh_serial 0 set nhl_names
{} set highlight_paths {} set findpattern {} set searchdirn -forwards set
boldids {} set boldnameids {} set diffelide {0 0} set markingmatches 0 set
linkentercount 0 set need_redisplay 0 set nrows_drawn 0 set firsttabstop 0</p>

<p>set nextviewnum 1 set curview 0 set selectedview 0 set selectedhlview [mc
“None”] set highlight_related [mc “None”] set highlight_files {} set
viewfiles(0) {} set viewperm(0) 0 set viewargs(0) {} set viewargscmd(0) {}</p>

<p>set selectedline {} set numcommits 0 set loginstance 0 set cmdlineok 0 set
stopped 0 set stuffsaved 0 set patchnum 0 set lserial 0 set hasworktree
[hasworktree] set cdup {} if {[expr {[exec git rev-parse
–is-inside-work-tree] == “true”}]} {</p>

<pre>set cdup [exec git rev-parse --show-cdup]</pre>

<p>} set worktree [exec git rev-parse –show-toplevel] setcoords makewindow
catch {</p>

<pre>image create photo gitlogo      -width 16 -height 16

image create photo gitlogominus -width  4 -height  2
gitlogominus put #C00000 -to 0 0 4 2
gitlogo copy gitlogominus -to  1 5
gitlogo copy gitlogominus -to  6 5
gitlogo copy gitlogominus -to 11 5
image delete gitlogominus

image create photo gitlogoplus  -width  4 -height  4
gitlogoplus  put #008000 -to 1 0 3 4
gitlogoplus  put #008000 -to 0 1 4 3
gitlogo copy gitlogoplus  -to  1 9
gitlogo copy gitlogoplus  -to  6 9
gitlogo copy gitlogoplus  -to 11 9
image delete gitlogoplus

image create photo gitlogo32    -width 32 -height 32
gitlogo32 copy gitlogo -zoom 2 2

wm iconphoto . -default gitlogo gitlogo32</pre>

<p>} # wait for the window to become visible tkwait visibility . wm title .
“$appname: [reponame]” update readrefs</p>

<p>if {$cmdline_files ne {} || $revtreeargs ne {} || $revtreeargscmd ne {}} {</p>

<pre># create a view for the files/dirs specified on the command line
set curview 1
set selectedview 1
set nextviewnum 2
set viewname(1) [mc &quot;Command line&quot;]
set viewfiles(1) $cmdline_files
set viewargs(1) $revtreeargs
set viewargscmd(1) $revtreeargscmd
set viewperm(1) 0
set vdatemode(1) 0
addviewmenu 1
.bar.view entryconf [mca &quot;Edit view...&quot;] -state normal
.bar.view entryconf [mca &quot;Delete view&quot;] -state normal</pre>

<p>}</p>

<p>if {[info exists permviews]} {</p>

<pre>foreach v $permviews {
    set n $nextviewnum
    incr nextviewnum
    set viewname($n) [lindex $v 0]
    set viewfiles($n) [lindex $v 1]
    set viewargs($n) [lindex $v 2]
    set viewargscmd($n) [lindex $v 3]
    set viewperm($n) 1
    addviewmenu $n
}</pre>

<p>}</p>

<p>if {[tk windowingsystem] eq “win32”} {</p>

<pre>focus -force .</pre>

<p>}</p>

<p>getcommits {}</p>

<p># Local variables: # mode: tcl # indent-tabs-mode: t # tab-width: 8 # End:</p>
</dd></dl>
</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="http://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="http://rdoc.rubyforge.org">RDoc</a> 4.1.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

